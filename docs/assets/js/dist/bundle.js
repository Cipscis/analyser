/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./docs/assets/js/src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./analyser.js":
/*!*********************!*\
  !*** ./analyser.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var csv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csv */ \"./node_modules/csv/csv.js\");\n/* harmony import */ var fileio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fileio */ \"./node_modules/fileio/fileio.js\");\n\r\n\r\n\r\nclass AnalyserRows extends Array {\r\n\tconstructor(sourceArray) {\r\n\t\t// Don't use spread operator as it will cause a\r\n\t\t// stack overflow error with very large arrays\r\n\t\t// super(...sourceArray);\r\n\t\tsuper(sourceArray.length);\r\n\t\tfor (let i = 0; i < sourceArray.length; i++) {\r\n\t\t\tthis[i] = sourceArray[i];\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//////////////////////\r\n\t// HELPER FUNCTIONS //\r\n\t//////////////////////\r\n\tgetCol(colNum) {\r\n\t\tlet col = this.map((row) => row[colNum]);\r\n\t\treturn col;\r\n\t}\r\n\r\n\r\n\t//////////////////////////////\r\n\t// TRANSFORMING INFORMATION //\r\n\t//////////////////////////////\r\n\taddCol(col) {\r\n\t\t// Edits the passed rows array to add an extra column\r\n\t\t// to it, then returns the index of that new column\r\n\r\n\t\tif (this.length !== col.length) {\r\n\t\t\tthrow new Error(`Cannot add col of length ${col.length} to rows of length ${this.length}`);\r\n\t\t}\r\n\r\n\t\tlet colIndex = this[0].length;\r\n\r\n\t\tfor (let [i, row] of this.entries()) {\r\n\t\t\trow.push(col[i]);\r\n\t\t}\r\n\r\n\t\treturn colIndex;\r\n\t}\r\n\r\n\tgetDerivedCol(processFn, ...cols) {\r\n\t\t// Creates an array analogous to a column as returns\r\n\t\t// by the getCol function, where its output is the\r\n\t\t// result of applying the processFn function to the row\r\n\t\t// any number of values from optional column arguments\r\n\r\n\t\tlet derivedCol = this.map((row, i) => {\r\n\t\t\tlet derivedValues = [row];\r\n\r\n\t\t\tfor (let col of cols) {\r\n\t\t\t\tderivedValues.push(col[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn processFn.apply(this, derivedValues);\r\n\t\t});\r\n\r\n\t\treturn derivedCol;\r\n\t}\r\n\r\n\taddDerivedCol(callback, ...cols) {\r\n\t\t// Works like getDerivedCol, but instead of returning\r\n\t\t// the derived column directly it uses addCol to add\r\n\t\t// it to rows and returns the new column index.\r\n\r\n\t\tlet derivedCol = this.getDerivedCol.apply(this, arguments);\r\n\r\n\t\treturn this.addCol(derivedCol);\r\n\t}\r\n\r\n\r\n\t///////////////////\r\n\t// SUMMARY TOOLS //\r\n\t///////////////////\r\n\tcreateSubTable(cols, arraySeparator) {\r\n\t\t// Takes in a set of rows and a cols object formatted like this:\r\n\t\t// {\r\n\t\t// \tETHNICITY: 3,\r\n\t\t// \tAGE: 6\r\n\t\t// }\r\n\r\n\t\t// Outputs an array of objects,\r\n\t\t// each of which has the same indices as cols and represents a row\r\n\t\t// The output can be used with console.table\r\n\r\n\t\tarraySeparator = arraySeparator || ', ';\r\n\r\n\t\tlet table = this.map((row) => {\r\n\t\t\tlet newRow = {};\r\n\r\n\t\t\tfor (let colName in cols) {\r\n\t\t\t\tlet col = cols[colName];\r\n\t\t\t\tlet cell = row[col]\r\n\t\t\t\t// Join arrays so they display in console.table\r\n\t\t\t\tif (cell instanceof Array) {\r\n\t\t\t\t\tnewRow[colName] = cell.join(arraySeparator);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewRow[colName] = cell;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn newRow;\r\n\t\t});\r\n\r\n\t\treturn table;\r\n\t}\r\n\r\n\tcreateSubTableString(cols) {\r\n\t\tlet table = this.createSubTable(cols, ',');\r\n\t\tlet tableString = Analyser._convertTableToString(table);\r\n\r\n\t\treturn tableString;\r\n\t}\r\n\r\n\tgetColSummary(cols, aliasList) {\r\n\t\t// Takes in a set of rows and one or more column numbers, and optionally\r\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\r\n\r\n\t\t// Outputs an object summarising the number of times each value\r\n\t\t// appeared in the given column of the given rows\r\n\r\n\r\n\t\t// Allow the passing of a single number or an array of column indices\r\n\t\tif (!(cols instanceof Array)) {\r\n\t\t\tcols = [cols];\r\n\t\t}\r\n\r\n\t\tlet summary = {};\r\n\t\tfor (let row of this) {\r\n\t\t\tfor (let col of cols) {\r\n\t\t\t\tlet cellValue = row[col];\r\n\r\n\t\t\t\tif (typeof cellValue !== 'undefined' && cellValue !== '') {\r\n\r\n\t\t\t\t\tlet values;\r\n\t\t\t\t\tif (cellValue instanceof Array) {\r\n\t\t\t\t\t\tvalues = cellValue;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalues = [cellValue];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (let value of values) {\r\n\t\t\t\t\t\tif (value in summary) {\r\n\t\t\t\t\t\t\tsummary[value]++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tsummary[value] = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (typeof aliasList !== 'undefined') {\r\n\t\t\tsummary = Analyser._groupColSummaryByAliases(summary, aliasList);\r\n\t\t}\r\n\r\n\t\treturn summary;\r\n\t}\r\n\r\n\tgetColAsDataSeries(col, labels) {\r\n\t\t// Takes in a set of rows and a column number,\r\n\t\t// and an array of labels. Outputs an array where\r\n\t\t// each element is the count of the values matching\r\n\t\t// the element of labels at the same index\r\n\r\n\t\tlet colSummary = this.getColSummary(col);\r\n\r\n\t\tlet dataSeries = [];\r\n\r\n\t\tfor (let i = 0; i < labels.length; i++) {\r\n\t\t\tdataSeries[i] = 0;\r\n\t\t}\r\n\r\n\t\tfor (let i in colSummary) {\r\n\t\t\tlet value = colSummary[i];\r\n\t\t\tlet index = labels.indexOf(i);\r\n\t\t\tif (index === -1) {\r\n\t\t\t\t// Couldn't find index, try forcing it to be a number\r\n\t\t\t\tindex = labels.indexOf(parseInt(i, 10));\r\n\t\t\t}\r\n\r\n\t\t\tif (index !== -1) {\r\n\t\t\t\tdataSeries[index] = value;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn dataSeries;\r\n\t}\r\n\r\n\tgetComparisonSummary(headerCol, headerAliases, varCol, varAliases) {\r\n\t\t// Takes in a set of rows and two column numbers\r\n\t\t// Creates an object that can be used with console.table\r\n\t\t// with the values of headerCol used in the header, and\r\n\t\t// the values of varCol used for each row, with the cells\r\n\t\t// denoting the number of times these values coincided\r\n\t\t// using filterRows with the passed sets of aliases\r\n\r\n\t\t// Also optionally takes a set of aliases for one or both columns\r\n\r\n\t\tif (arguments.length === 2) {\r\n\t\t\t// No aliases specified\r\n\t\t\tvarCol = headerAliases;\r\n\t\t\theaderAliases = undefined;\r\n\t\t} else if (arguments.length === 3) {\r\n\t\t\t// One alias specified\r\n\t\t\tif (!(headerAliases instanceof Array)) {\r\n\t\t\t\t// headerAliases was not passed\r\n\t\t\t\tvarAliases = varCol;\r\n\t\t\t\tvarCol = headerAliases;\r\n\t\t\t\theaderAliases = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log(this);\r\n\t\tconsole.trace();\r\n\t\tlet headerSummary = this.getColSummary(headerCol, headerAliases);\r\n\t\tlet varSummary = this.getColSummary(varCol, varAliases);\r\n\r\n\t\tlet aliases = {};\r\n\t\tif (headerAliases) {\r\n\t\t\taliases.HEADERS = headerAliases;\r\n\t\t}\r\n\t\tif (varAliases) {\r\n\t\t\taliases.VARS = varAliases;\r\n\t\t}\r\n\t\tlet filters = Analyser._getAliasFilters(aliases);\r\n\r\n\t\tlet comparisonSummary = {};\r\n\t\tfor (let i in varSummary) {\r\n\t\t\tcomparisonSummary[i] = {};\r\n\t\t\tfor (let j in headerSummary) {\r\n\t\t\t\tcomparisonSummary[i][j] = filters.filterRows(this,\r\n\t\t\t\t\tvarCol, Analyser._extractValue(i),\r\n\t\t\t\t\theaderCol, Analyser._extractValue(j)\r\n\t\t\t\t).length;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn comparisonSummary;\r\n\t}\r\n\r\n\tgetComparisonSummaryString(headerCol, headerAliases, varCol, varAliases) {\r\n\t\t// Calls getComparisonSummary with all arguments passed,\r\n\t\t// then returns a string of the data that can be copy/pasted\r\n\t\t// into a spreadsheet\r\n\r\n\t\tlet comparisonSummary = this.getComparisonSummary.apply(this, arguments);\r\n\t\tlet comparisonSummaryString = Analyser._convertTableToString(comparisonSummary, true);\r\n\r\n\t\treturn comparisonSummaryString;\r\n\t}\r\n\r\n\tsaveComparisonSummaryCsv(filename, headerCol, headerAliases, varCol, varAliases) {\r\n\t\t// Calls getComparisonSummary with all arguments passed,\r\n\t\t// then returns a string of the data that can be copy/pasted\r\n\t\t// into a spreadsheet\r\n\t\tlet args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\t\tlet comparisonSummary = this.getComparisonSummary.apply(this, args);\r\n\t\tlet comparisonSummaryCsv = Analyser._convertTableToString(comparisonSummary, true, ',', '\\n');\r\n\r\n\t\tlet options = {\r\n\t\t\tfilename,\r\n\t\t\ttype: 'text/csv',\r\n\t\t};\r\n\r\n\t\tfileio__WEBPACK_IMPORTED_MODULE_1__[\"default\"].save(comparisonSummaryCsv, options);\r\n\t}\r\n}\r\n\r\nconst Analyser = {\r\n\t/////////////////////\r\n\t// FILE PROCESSING //\r\n\t/////////////////////\r\n\t_loadFile: async function (fileConfig) {\r\n\t\tlet response = await fetch(fileConfig.path);\r\n\r\n\t\tif (response.ok) {\r\n\t\t\tlet data = await response.text();\r\n\r\n\t\t\tlet rows = Analyser._parseCsv(data);\r\n\t\t\tlet dataConfig = Analyser._processData(rows, fileConfig);\r\n\t\t\treturn dataConfig;\r\n\t\t} else {\r\n\t\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\r\n\t\t}\r\n\t},\r\n\r\n\tloadFile: function (...fileConfigArr) {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\t// Load each file, then resolve the wrapping promise once all are loaded\r\n\t\t\tlet promises = fileConfigArr.map((fileConfig) => Analyser._loadFile(fileConfig))\r\n\t\t\tPromise.all(promises).then(resolve);\r\n\t\t});\r\n\t},\r\n\r\n\t_processData: function (rows, fileConfig) {\r\n\t\t// Takes in fileConfig with the following properties:\r\n\t\t// The number of header rows to remove from rows\r\n\t\t// A fileConfig object for column names\r\n\t\t// An optional set of aliases\r\n\t\t// An optional set of columns whose values should be treated as arrays\r\n\t\t// An optional set of columns with default values\r\n\t\t// An optional map of columns that should be combined when collecting enums\r\n\r\n\t\t// The output contains the following properties:\r\n\t\t// The header rows that were removed\r\n\t\t// The fileConfig object for column names\r\n\t\t// A set of filters respecting the given aliases\r\n\t\t// Enums collected according to the specified column names and optional enumsMap\r\n\r\n\t\t// Example data:\r\n\t\t// headerRows = 2;\r\n\t\t// footerRows = 1;\r\n\r\n\t\t// cols = Analyser.getColNumbers({\r\n\t\t// \tETHNICITY: 'K',\r\n\t\t// \tTACTICS: 'M'\r\n\t\t// });\r\n\r\n\t\t// arrayCols = {};\r\n\t\t// arrayCols[cols.TACTICS] = ' ';\r\n\r\n\t\t// defaultCols = {};\r\n\t\t// defaultCols[cols.VALUE] = 0;\r\n\r\n\t\t// defaultColValues = {};\r\n\t\t// defaultColValues[cols.VALUE] = '-';\r\n\r\n\t\t// aliases = {\r\n\t\t// \tETHNICITY: [\r\n\t\t// \t\t[\r\n\t\t// \t\t\t'Pacific', //Not represented in data, but used as a label\r\n\t\t// \t\t\t'Pacific Island',\r\n\t\t// \t\t\t'Pacific Islander'\r\n\t\t// \t\t]\r\n\t\t// \t]\r\n\t\t// };\r\n\r\n\t\t// enumsMap = {\r\n\t\t// \tTASER_METHOD: [cols.TASER_METHOD_1, cols.TASER_METHOD_2, cols.TASER_METHOD_3]\r\n\t\t// };\r\n\r\n\t\tfileConfig.headerRows = fileConfig.headerRows || 0;\r\n\t\tfileConfig.footerRows = fileConfig.footerRows || 0;\r\n\t\tfileConfig.cols = fileConfig.cols || {};\r\n\t\tfileConfig.aliases = fileConfig.aliases || {};\r\n\t\tfileConfig.arrayCols = fileConfig.arrayCols || {};\r\n\t\tfileConfig.enumsMap = fileConfig.enumsMap || {};\r\n\t\tfileConfig.uniqueCols = fileConfig.uniqueCols || [];\r\n\r\n\t\tlet dataConfig = {};\r\n\t\tdataConfig.cols = fileConfig.cols;\r\n\t\tdataConfig.aliases = fileConfig.aliases;\r\n\t\tdataConfig.filters = Analyser._getAliasFilters(fileConfig.aliases);\r\n\t\tdataConfig.enumsMap = fileConfig.enumsMap; // Keep this for combining data\r\n\r\n\t\tif (fileConfig.headerRows !== 0) {\r\n\t\t\t// Remove header rows\r\n\t\t\trows.splice(0, fileConfig.headerRows);\r\n\t\t}\r\n\r\n\t\tif (fileConfig.footerRows !== 0) {\r\n\t\t\t// Remove footer rows\r\n\t\t\trows.splice(-fileConfig.footerRows);\r\n\t\t}\r\n\r\n\t\t// Convert cells that are lists into arrays\r\n\t\tdataConfig.rows = new AnalyserRows(rows);\r\n\t\tfor (let i = 0; i < dataConfig.rows.length; i++) {\r\n\t\t\tlet row = dataConfig.rows[i];\r\n\r\n\t\t\tfor (let j in fileConfig.arrayCols) {\r\n\t\t\t\trow[j] = (row[j] + '').trim().split(fileConfig.arrayCols[j] || ' ');\r\n\t\t\t}\r\n\r\n\t\t\t// Remove default values from specified columns\r\n\t\t\tfor (let j in fileConfig.defaultColValues) {\r\n\t\t\t\tif (j in fileConfig.arrayCols) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif ((row[j] + '') === (fileConfig.defaultColValues[j] + '')) {\r\n\t\t\t\t\trow[j] = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Add default values to empty cells in default cols\r\n\t\t\tfor (let j in fileConfig.defaultCols) {\r\n\t\t\t\tif (j in fileConfig.arrayCols) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif ((row[j] + '').trim() === '') {\r\n\t\t\t\t\trow[j] = fileConfig.defaultCols[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set filters on rows object\r\n\t\tAnalyser._createRowFilterFunctions(dataConfig.rows, dataConfig.filters);\r\n\r\n\t\t// Build enums\r\n\t\tdataConfig.enums = Analyser._buildEnums(rows, fileConfig);\r\n\r\n\t\treturn dataConfig;\r\n\t},\r\n\r\n\t_buildEnums: function (rows, config) {\r\n\t\tlet enums = {};\r\n\r\n\t\tfor (let col in config.cols) {\r\n\r\n\t\t\t// Don't collect enums for columns specified in uniqueCols or enumsMap\r\n\t\t\tlet collect = true;\r\n\t\t\tif (config.uniqueCols.includes(config.cols[col])) {\r\n\t\t\t\tcollect = false;\r\n\t\t\t}\r\n\t\t\tfor (let enumCol in config.enumsMap) {\r\n\t\t\t\tif (config.enumsMap[enumCol].includes(config.cols[col])) {\r\n\t\t\t\t\tcollect = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (collect) {\r\n\t\t\t\tenums[col] = [];\r\n\t\t\t\tAnalyser._collectEnums(rows, enums[col], config.cols[col]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let enumCol in config.enumsMap) {\r\n\t\t\tenums[enumCol] = [];\r\n\t\t\tAnalyser._collectEnums.apply(this, [rows, enums[enumCol]].concat(config.enumsMap[enumCol]));\r\n\t\t}\r\n\r\n\t\treturn enums;\r\n\t},\r\n\r\n\t_collectEnums: function (rows, enumsArr, ...cols) {\r\n\t\t// Go through all cells in a given set of columns\r\n\t\t// and add all unique entries found to enumsArr\r\n\r\n\t\tenumsArr = enumsArr || [];\r\n\r\n\t\tfor (let i = 0; i < rows.length; i++) {\r\n\t\t\tlet row = rows[i];\r\n\t\t\tfor (let j = 0; j < cols.length; j++) {\r\n\t\t\t\tlet col = cols[j];\r\n\r\n\t\t\t\tif (row[col] instanceof Array) {\r\n\t\t\t\t\tfor (let k = 0; k < row[col].length; k++) {\r\n\t\t\t\t\t\tif ((row[col][k] !== '') && (enumsArr.indexOf(row[col][k]) === -1)) {\r\n\t\t\t\t\t\t\tenumsArr.push(row[col][k]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ((row[col] !== '') && (enumsArr.indexOf(row[col]) === -1)) {\r\n\t\t\t\t\t\tenumsArr.push(row[col]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn enumsArr;\r\n\t},\r\n\r\n\tcombineData: function (...dataConfigs) {\r\n\t\t// Takes in any number of dataConfig objects from _processData\r\n\t\t// Combines the rows and relevant dataConfig objects (e.g. aliases, enums)\r\n\t\t// Keeps only columns shared by all dataConfig objects\r\n\r\n\t\t// Assumes there is no data shared between different sets,\r\n\t\t// so duplicates will *not* be detected or removed\r\n\r\n\t\t// The output is in the same format as for _processData\r\n\r\n\t\tlet combinedDataConfig = {\r\n\t\t\tcols: {},\r\n\t\t\trows: new AnalyserRows([]),\r\n\t\t\taliases: {}\r\n\t\t};\r\n\r\n\t\tif (!dataConfigs || dataConfigs.length < 2) {\r\n\t\t\tconsole.error('Invalid inputs passed to combineData', arguments);\r\n\t\t}\r\n\r\n\t\t// Combine cols first //\r\n\r\n\t\t// Build base set from first cols object\r\n\t\tfor (let j in dataConfigs[0].cols) {\r\n\t\t\tcombinedDataConfig.cols[j] = true;\r\n\t\t}\r\n\r\n\t\t// Remove any cols not shared by every other cols object\r\n\t\tfor (let i = 1; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\r\n\t\t\tfor (let j in combinedDataConfig.cols) {\r\n\t\t\t\tif (!(j in dataConfig.cols)) {\r\n\t\t\t\t\tdelete combinedDataConfig.cols[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet colIndex = 0;\r\n\t\tfor (let j in combinedDataConfig.cols) {\r\n\t\t\tcombinedDataConfig.cols[j] = colIndex;\r\n\t\t\tcolIndex++;\r\n\t\t}\r\n\r\n\t\t// Now that we have the combined cols object, combine rows and aliases\r\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\t\t\t// Combine rows //\r\n\r\n\t\t\tfor (let j = 0; j < dataConfig.rows.length; j++) {\r\n\t\t\t\tlet row = [];\r\n\t\t\t\tfor (let k in combinedDataConfig.cols) {\r\n\t\t\t\t\trow[combinedDataConfig.cols[k]] = dataConfig.rows[j][dataConfig.cols[k]];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcombinedDataConfig.rows.push(row);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// Combine aliases //\r\n\r\n\t\t\t// Loop through each row's aliases to combine\r\n\t\t\tfor (let j in dataConfig.aliases) {\r\n\r\n\t\t\t\t// If we don't have an alias for this column, make an empty placeholder\r\n\t\t\t\tif (!(j in combinedDataConfig.aliases)) {\r\n\t\t\t\t\tcombinedDataConfig.aliases[j] = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Loop through each aliasSet for this column\r\n\t\t\t\tfor (let k = 0; k < dataConfig.aliases[j].length; k++) {\r\n\t\t\t\t\tlet aliasSet = dataConfig.aliases[j][k];\r\n\r\n\t\t\t\t\t// Combine aliasSets based off their first element, which is used as a label\r\n\t\t\t\t\tlet combinedAliasSet = [];\r\n\t\t\t\t\tlet l;\r\n\t\t\t\t\tfor (l = 0; l < combinedDataConfig.aliases[j].length; l++) {\r\n\t\t\t\t\t\tif (combinedDataConfig.aliases[j][l][0] === aliasSet[0]) {\r\n\t\t\t\t\t\t\tcombinedAliasSet = combinedDataConfig.aliases[j][l];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcombinedAliasSet = combinedAliasSet.concat(aliasSet);\r\n\r\n\t\t\t\t\t// Remove duplicates\r\n\t\t\t\t\tcombinedAliasSet = combinedAliasSet.filter(function (alias, index, array) {\r\n\t\t\t\t\t\treturn array.indexOf(alias) === index;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// Append or replace aliasSet in combinedDataConfig\r\n\t\t\t\t\tif (l < combinedDataConfig.aliases[j].length) {\r\n\t\t\t\t\t\tcombinedDataConfig.aliases[j][l] = combinedAliasSet;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcombinedDataConfig.aliases[j].push(combinedAliasSet);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Create new filters using combined aliases\r\n\t\tcombinedDataConfig.filters = Analyser._getAliasFilters(combinedDataConfig.aliases);\r\n\t\tAnalyser._createRowFilterFunctions(combinedDataConfig.rows, combinedDataConfig.filters);\r\n\r\n\t\t// Combine uniqueCols\r\n\t\tcombinedDataConfig.uniqueCols = [];\r\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\r\n\t\t\tfor (let j in dataConfig.uniqueCols) {\r\n\t\t\t\tlet originalCol = dataConfig.uniqueCols[j];\r\n\t\t\t\tlet originalColName = undefined;\r\n\t\t\t\tfor (let k in dataConfig.cols) {\r\n\t\t\t\t\tif (dataConfig.cols[l] === originalCol) {\r\n\t\t\t\t\t\toriginalColName = l;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (originalColName) {\r\n\t\t\t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\r\n\r\n\t\t\t\t\tif (combinedDataConfig.uniqueCols.indexOf(originalColIndex) === -1) {\r\n\t\t\t\t\t\tcombinedDataConfig.uniqueCols.push(combinedDataConfig.cols[originalColName]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Combine the enumsMaps, then build combined enums\r\n\t\tcombinedDataConfig.enumsMap = {};\r\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\r\n\t\t\tfor (let j in dataConfig.enumsMap) {\r\n\t\t\t\tlet originalEnumsMap = dataConfig.enumsMap[j];\r\n\r\n\t\t\t\tif (!originalEnumsMap) {\r\n\t\t\t\t\t// Mark this enumsMap as null to denote that it doesn't\r\n\t\t\t\t\t// exist across all dataConfigs we are combining\r\n\t\t\t\t\tcombinedDataConfig.enumsMap[j] = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (combinedDataConfig.enumsMap[j] !== null) {\r\n\t\t\t\t\t\tcombinedDataConfig.enumsMap[j] = combinedDataConfig.enumsMap[j] || [];\r\n\r\n\t\t\t\t\t\tfor (let k = 0; k < originalEnumsMap.length; k++) {\r\n\t\t\t\t\t\t\tlet originalCol = originalEnumsMap[k];\r\n\t\t\t\t\t\t\tlet originalColName = undefined;\r\n\t\t\t\t\t\t\tfor (let l in dataConfig.cols) {\r\n\t\t\t\t\t\t\t\tif (dataConfig.cols[l] === originalCol) {\r\n\t\t\t\t\t\t\t\t\toriginalColName = l;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (originalColName) {\r\n\t\t\t\t\t\t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\r\n\r\n\t\t\t\t\t\t\t\tif (combinedDataConfig.enumsMap[j].indexOf(originalColIndex) === -1) {\r\n\t\t\t\t\t\t\t\t\tcombinedDataConfig.enumsMap[j].push(combinedDataConfig.cols[originalColName]);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (let j in combinedDataConfig.enumsMap) {\r\n\t\t\t\tif (combinedDataConfig.enumsMap[j] === null) {\r\n\t\t\t\t\tdelete combinedDataConfig[enumsMap[j]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcombinedDataConfig.enums = Analyser._buildEnums(combinedDataConfig.rows, combinedDataConfig);\r\n\r\n\t\treturn combinedDataConfig;\r\n\t},\r\n\r\n\t/////////////////\r\n\t// CSV PARSING //\r\n\t/////////////////\r\n\t_parseCsv: function (csv) {\r\n\t\t// Parse a CSV file then process the data\r\n\t\t// Convert strings to numbers where appropriate,\r\n\t\t// then pass the data to a callback function\r\n\r\n\t\tlet data = Object(csv__WEBPACK_IMPORTED_MODULE_0__[\"parse\"])(csv);\r\n\t\tdata = Analyser._extractCellValues(data);\r\n\r\n\t\treturn data;\r\n\t},\r\n\r\n\t_extractCellValues: function (rawRows) {\r\n\t\t// Use _extractValue on each cell\r\n\t\tlet rows = rawRows.map((row) => row.map(Analyser._extractValue));\r\n\t\treturn rows;\r\n\t},\r\n\r\n\t_extractValue: function (string) {\r\n\t\t// Convert strings to booleans or numbers where possible\r\n\r\n\t\tif (string === 'true') {\r\n\t\t\treturn true;\r\n\t\t} else if (string === 'false') {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn Analyser._extractNumber(string);\r\n\t\t}\r\n\t},\r\n\r\n\t_extractNumber: function (string) {\r\n\t\t// Convert strings to numbers where possible\r\n\r\n\t\tlet val = string.replace(/,|%$/g, '');\r\n\r\n\t\tif (parseFloat(val) === +val) {\r\n\t\t\tif (string.match(/%$/)) {\r\n\t\t\t\t// If the value is a percentage, divide by 100\r\n\r\n\t\t\t\t// Convert to string to see how many places after the point, to round after dividing\r\n\t\t\t\t// Otherwise you'll get numbers like 0.10800000000000001\r\n\t\t\t\tlet length = (val + '');\r\n\t\t\t\tlength.replace(/^[^.]+/, '');\r\n\t\t\t\tlength = length.length;\r\n\r\n\t\t\t\tval = val / 100;\r\n\t\t\t\tval = val.toFixed(length+2);\r\n\t\t\t}\r\n\t\t\treturn +val;\r\n\t\t} else {\r\n\t\t\treturn string;\r\n\t\t}\r\n\t},\r\n\r\n\t///////////////\r\n\t// FILTERING //\r\n\t///////////////\r\n\t_getAliasFilters: function (aliases) {\r\n\t\tconst filterRows = function (rows, orToggle, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\r\n\t\t\t// Takes in a rows object (imported from csv),\r\n\t\t\t// a boolean specifying whether it's an \"and\" or an \"or\" filter,\r\n\t\t\t// and any number of pairs (at least one) of\r\n\t\t\t// the index of the column to consider, and an array of values\r\n\r\n\t\t\t// Returns an array of rows where the cell in the column\r\n\t\t\t// specified contains a value in the array of values given\r\n\t\t\t// for all column and value pairs\r\n\r\n\t\t\tlet and = !orToggle;\r\n\t\t\tlet startAt = 2;\r\n\r\n\t\t\tlet filteredRows = [];\r\n\r\n\t\t\tif ((arguments.length < 4) || (((arguments.length-2) % 2) !== 0)) {\r\n\t\t\t\t// Assume \"andToggle\" has not been passed\r\n\t\t\t\tand = true;\r\n\t\t\t\tstartAt = 1;\r\n\t\t\t\tif ((arguments.length < 3) || (((arguments.length-1) % 2) !== 0)) {\r\n\t\t\t\t\tconsole.error('An invalid set of arguments was passed to filterRows');\r\n\t\t\t\t\treturn [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet filters = [];\r\n\t\t\tfor (let i = startAt; i < arguments.length-1; i += 2) {\r\n\t\t\t\tlet filter = {\r\n\t\t\t\t\tcolIndex: arguments[i],\r\n\t\t\t\t\tvalues: arguments[i+1]\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (!(Array.isArray(filter.values) || filter.values instanceof Function)) {\r\n\t\t\t\t\tfilter.values = [filter.values];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfilters.push(filter);\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < rows.length; i++) {\r\n\t\t\t\tlet row = rows[i];\r\n\r\n\t\t\t\tlet isMatch = !!and;\r\n\r\n\t\t\t\tfor (let j = 0; j < filters.length; j++) {\r\n\t\t\t\t\tlet filter = filters[j];\r\n\r\n\t\t\t\t\tif (and) {\r\n\t\t\t\t\t\tisMatch = isMatch && Analyser._applyFilter(row, filter.colIndex, filter.values, aliases);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tisMatch = isMatch || Analyser._applyFilter(row, filter.colIndex, filter.values, aliases);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isMatch) {\r\n\t\t\t\t\tfilteredRows.push(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfilteredRows = new AnalyserRows(filteredRows);\r\n\t\t\tfilteredRows.filter = rows.filter;\r\n\t\t\tfilteredRows.filterAnd = rows.filterAnd;\r\n\t\t\tfilteredRows.filterOr = rows.filterOr;\r\n\r\n\t\t\treturn filteredRows;\r\n\t\t};\r\n\r\n\t\tconst filterRowsAnd = function (rows, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\r\n\t\t\tlet args = Array.prototype.slice.apply(arguments);\r\n\r\n\t\t\targs = args.slice(1);\r\n\t\t\targs.splice(0, 0, false);\r\n\t\t\targs.splice(0, 0, rows);\r\n\r\n\t\t\treturn filterRows.apply(this, args);\r\n\t\t};\r\n\r\n\t\tconst filterRowsOr = function (rows, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\r\n\t\t\tlet args = Array.prototype.slice.apply(arguments);\r\n\r\n\t\t\targs = args.slice(1);\r\n\t\t\targs.splice(0, 0, true);\r\n\t\t\targs.splice(0, 0, rows);\r\n\r\n\t\t\treturn filterRows.apply(this, args);\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tfilterRows: filterRows,\r\n\t\t\tfilterRowsAnd: filterRowsAnd,\r\n\t\t\tfilterRowsOr: filterRowsOr\r\n\t\t};\r\n\t},\r\n\r\n\t_createRowFilterFunctions: function (rows, filters) {\r\n\t\trows.filter = function () {\r\n\t\t\tvar args = [this].concat(Array.from(arguments));\r\n\r\n\t\t\treturn filters.filterRows.apply(this, args);\r\n\t\t};\r\n\r\n\t\trows.filterOr = function () {\r\n\t\t\tvar args = [this].concat(Array.from(arguments));\r\n\r\n\t\t\treturn filters.filterRowsOr.apply(this, args);\r\n\t\t};\r\n\r\n\t\trows.filterAnd = function () {\r\n\t\t\tvar args = [this].concat(Array.from(arguments));\r\n\r\n\t\t\treturn filters.filterRowsAnd.apply(this, args);\r\n\t\t};\r\n\t},\r\n\r\n\t_applyFilter: function (row, colIndex, values, aliases) {\r\n\t\t// Allow functions to be passed as filter tests\r\n\t\tif (values instanceof Function) {\r\n\t\t\treturn values(row[colIndex]);\r\n\t\t}\r\n\r\n\t\t// If one or more values is passed, test it against aliases\r\n\t\tif (!(values instanceof Array)) {\r\n\t\t\tvalues = [values];\r\n\t\t}\r\n\r\n\t\tlet cell = row[colIndex];\r\n\t\tlet cellValues;\r\n\r\n\t\tif (cell instanceof Array) {\r\n\t\t\tcellValues = cell;\r\n\t\t} else {\r\n\t\t\tcellValues = [cell];\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < cellValues.length; i++) {\r\n\t\t\tlet cellValue = cellValues[i];\r\n\r\n\t\t\tfor (let k = 0; k < values.length; k++) {\r\n\t\t\t\tif (Analyser._matchAlias(values[k], cellValue, aliases)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_matchAlias: function (cell, value, aliasSuperset) {\r\n\t\t// Checks if the value of a cell matches the value passed,\r\n\t\t// optionally taking one or more sets of aliases to match\r\n\r\n\t\t// The aliasSuperset is used because the default set of all\r\n\t\t// aliases will be used if no aliasSet is specified\r\n\r\n\t\tif (cell === value) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Could be array or object\r\n\t\tfor (let i in aliasSuperset) {\r\n\t\t\tlet aliasSet = aliasSuperset[i];\r\n\t\t\tfor (let j = 0; j < aliasSet.length; j++) {\r\n\t\t\t\tlet aliasList = aliasSet[j];\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\t(aliasList.indexOf(cell) !== -1) &&\r\n\t\t\t\t\t(aliasList.indexOf(value) !== -1)\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t//////////////////////\r\n\t// HELPER FUNCTIONS //\r\n\t//////////////////////\r\n\tgetColNumber: function (colName) {\r\n\t\t// Takes in a string like \"CE\" and converts it to a row number like 82\r\n\r\n\t\tif (!(typeof colName === 'string' || colName instanceof String)) {\r\n\t\t\t// Not a string\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tlet alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\r\n\t\tlet rowNumber = -1; // Adjust for 0-based counting\r\n\r\n\t\tfor (let i = 0; i < colName.length; i++) {\r\n\t\t\tlet char = colName.toUpperCase()[i];\r\n\t\t\tlet charIndex = alphabet.indexOf(char);\r\n\r\n\t\t\tif (charIndex === -1) {\r\n\t\t\t\t// String contains invalid character\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\r\n\t\t}\r\n\r\n\t\treturn rowNumber;\r\n\t},\r\n\r\n\tgetColNumbers: function (cols) {\r\n\t\t// Takes in a flat object and runs each property through getColNumber\r\n\t\tlet newCols = {};\r\n\r\n\t\tfor (let key in cols) {\r\n\t\t\tlet val = cols[key];\r\n\r\n\t\t\tif (typeof val === 'string' || val instanceof String) {\r\n\t\t\t\tval = Analyser.getColNumber(cols[key]);\r\n\t\t\t}\r\n\r\n\t\t\tif (Number.isInteger(val) && val >= 0) {\r\n\t\t\t\tnewCols[key] = val;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newCols;\r\n\t},\r\n\r\n\t///////////////////\r\n\t// SUMMARY TOOLS //\r\n\t///////////////////\r\n\t_convertTableToString: function (table, useKeys, cellSeparatorOption, rowSeparatorOption) {\r\n\t\tconst cellSeparator = cellSeparatorOption || '\\t';\r\n\t\tconst rowSeparator = rowSeparatorOption || '\\n';\r\n\r\n\t\tlet tableString = '';\r\n\r\n\t\tlet addCell = (cellString) => {\r\n\t\t\tif (typeof cellString !== 'string') {\r\n\t\t\t\tcellString = '' + cellString;\r\n\t\t\t}\r\n\r\n\t\t\tif (cellString.indexOf(cellSeparator) !== -1) {\r\n\t\t\t\t// If the cell string contains the separator sequence,\r\n\t\t\t\t// wrap it in \" and escape any existing \" as \"\"\r\n\t\t\t\tcellString = '\"' + cellString.replace(/\"/g, '\"\"') + '\"';\r\n\t\t\t}\r\n\r\n\t\t\ttableString += cellString + cellSeparator;\r\n\t\t};\r\n\t\tlet endLine = () => {\r\n\t\t\t// Trim off last cell separator, replace with newline\r\n\t\t\ttableString = tableString.substr(0, tableString.length - cellSeparator.length) + rowSeparator;\r\n\t\t};\r\n\r\n\t\t// Render headers and create array of labels\r\n\t\tif (useKeys) {\r\n\t\t\ttableString += cellSeparator;\r\n\t\t}\r\n\r\n\t\tlet firstRowComplete = false;\r\n\t\tfor (let rowName in table) {\r\n\t\t\tif (firstRowComplete === true) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tfirstRowComplete = true;\r\n\r\n\t\t\tlet row = table[rowName];\r\n\t\t\tfor (let colName in row) {\r\n\t\t\t\taddCell(colName);\r\n\t\t\t}\r\n\t\t}\r\n\t\tendLine();\r\n\r\n\t\tfor (let rowName in table) {\r\n\t\t\tlet isFirstRow = false;\r\n\t\t\tlet row = table[rowName];\r\n\t\t\tfor (let colName in row) {\r\n\t\t\t\tlet cell = row[colName];\r\n\t\t\t\tif (useKeys) {\r\n\t\t\t\t\tif (isFirstRow === false) {\r\n\t\t\t\t\t\taddCell(rowName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tisFirstRow = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddCell(cell);\r\n\t\t\t}\r\n\t\t\tendLine();\r\n\t\t}\r\n\r\n\t\treturn tableString;\r\n\t},\r\n\r\n\t_groupColSummaryByAliases: function (summary, aliasList) {\r\n\t\t// Takes a summary object like the output from getColSummary, and\r\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\r\n\r\n\t\t// Outputs a summary object where values within the same set of aliases are grouped\r\n\r\n\t\tlet newSummary = {};\r\n\t\tfor (let i in summary) {\r\n\t\t\tlet inAlias = false;\r\n\t\t\tfor (let j = 0; j < aliasList.length; j++) {\r\n\t\t\t\tlet aliases = aliasList[j];\r\n\r\n\t\t\t\tif (aliases.indexOf(i) !== -1) {\r\n\t\t\t\t\tinAlias = true;\r\n\t\t\t\t\tif (aliases[0] in newSummary) {\r\n\t\t\t\t\t\tnewSummary[aliases[0]] += summary[i];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnewSummary[aliases[0]] = summary[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (inAlias === false) {\r\n\t\t\t\tnewSummary[i] = summary[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newSummary;\r\n\t}\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n\tloadFile: Analyser.loadFile,\r\n\tcombineData: Analyser.combineData,\r\n\r\n\tgetColNumber: Analyser.getColNumber,\r\n\tgetColNumbers: Analyser.getColNumbers,\r\n\tgetCol: Analyser.getCol\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hbmFseXNlci5qcz9hM2MxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUE0QjtBQUNBOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxXQUFXLHFCQUFxQixZQUFZO0FBQzNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw4Q0FBTTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhDQUE4QyxnQkFBZ0IsSUFBSSxnQkFBZ0I7QUFDbEY7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBOztBQUVBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQ0FBa0M7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEscUJBQXFCLDZCQUE2QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxpREFBSztBQUNsQjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQixpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQyIsImZpbGUiOiIuL2FuYWx5c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdjc3YnO1xyXG5pbXBvcnQgZmlsZWlvIGZyb20gJ2ZpbGVpbyc7XHJcblxyXG5jbGFzcyBBbmFseXNlclJvd3MgZXh0ZW5kcyBBcnJheSB7XHJcblx0Y29uc3RydWN0b3Ioc291cmNlQXJyYXkpIHtcclxuXHRcdC8vIERvbid0IHVzZSBzcHJlYWQgb3BlcmF0b3IgYXMgaXQgd2lsbCBjYXVzZSBhXHJcblx0XHQvLyBzdGFjayBvdmVyZmxvdyBlcnJvciB3aXRoIHZlcnkgbGFyZ2UgYXJyYXlzXHJcblx0XHQvLyBzdXBlciguLi5zb3VyY2VBcnJheSk7XHJcblx0XHRzdXBlcihzb3VyY2VBcnJheS5sZW5ndGgpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VBcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR0aGlzW2ldID0gc291cmNlQXJyYXlbaV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cdC8vIEhFTFBFUiBGVU5DVElPTlMgLy9cclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblx0Z2V0Q29sKGNvbE51bSkge1xyXG5cdFx0bGV0IGNvbCA9IHRoaXMubWFwKChyb3cpID0+IHJvd1tjb2xOdW1dKTtcclxuXHRcdHJldHVybiBjb2w7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblx0Ly8gVFJBTlNGT1JNSU5HIElORk9STUFUSU9OIC8vXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXHJcblx0YWRkQ29sKGNvbCkge1xyXG5cdFx0Ly8gRWRpdHMgdGhlIHBhc3NlZCByb3dzIGFycmF5IHRvIGFkZCBhbiBleHRyYSBjb2x1bW5cclxuXHRcdC8vIHRvIGl0LCB0aGVuIHJldHVybnMgdGhlIGluZGV4IG9mIHRoYXQgbmV3IGNvbHVtblxyXG5cclxuXHRcdGlmICh0aGlzLmxlbmd0aCAhPT0gY29sLmxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhZGQgY29sIG9mIGxlbmd0aCAke2NvbC5sZW5ndGh9IHRvIHJvd3Mgb2YgbGVuZ3RoICR7dGhpcy5sZW5ndGh9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGNvbEluZGV4ID0gdGhpc1swXS5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yIChsZXQgW2ksIHJvd10gb2YgdGhpcy5lbnRyaWVzKCkpIHtcclxuXHRcdFx0cm93LnB1c2goY29sW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29sSW5kZXg7XHJcblx0fVxyXG5cclxuXHRnZXREZXJpdmVkQ29sKHByb2Nlc3NGbiwgLi4uY29scykge1xyXG5cdFx0Ly8gQ3JlYXRlcyBhbiBhcnJheSBhbmFsb2dvdXMgdG8gYSBjb2x1bW4gYXMgcmV0dXJuc1xyXG5cdFx0Ly8gYnkgdGhlIGdldENvbCBmdW5jdGlvbiwgd2hlcmUgaXRzIG91dHB1dCBpcyB0aGVcclxuXHRcdC8vIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgcHJvY2Vzc0ZuIGZ1bmN0aW9uIHRvIHRoZSByb3dcclxuXHRcdC8vIGFueSBudW1iZXIgb2YgdmFsdWVzIGZyb20gb3B0aW9uYWwgY29sdW1uIGFyZ3VtZW50c1xyXG5cclxuXHRcdGxldCBkZXJpdmVkQ29sID0gdGhpcy5tYXAoKHJvdywgaSkgPT4ge1xyXG5cdFx0XHRsZXQgZGVyaXZlZFZhbHVlcyA9IFtyb3ddO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgY29sIG9mIGNvbHMpIHtcclxuXHRcdFx0XHRkZXJpdmVkVmFsdWVzLnB1c2goY29sW2ldKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbi5hcHBseSh0aGlzLCBkZXJpdmVkVmFsdWVzKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBkZXJpdmVkQ29sO1xyXG5cdH1cclxuXHJcblx0YWRkRGVyaXZlZENvbChjYWxsYmFjaywgLi4uY29scykge1xyXG5cdFx0Ly8gV29ya3MgbGlrZSBnZXREZXJpdmVkQ29sLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmdcclxuXHRcdC8vIHRoZSBkZXJpdmVkIGNvbHVtbiBkaXJlY3RseSBpdCB1c2VzIGFkZENvbCB0byBhZGRcclxuXHRcdC8vIGl0IHRvIHJvd3MgYW5kIHJldHVybnMgdGhlIG5ldyBjb2x1bW4gaW5kZXguXHJcblxyXG5cdFx0bGV0IGRlcml2ZWRDb2wgPSB0aGlzLmdldERlcml2ZWRDb2wuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRDb2woZGVyaXZlZENvbCk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cdC8vIFNVTU1BUlkgVE9PTFMgLy9cclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vXHJcblx0Y3JlYXRlU3ViVGFibGUoY29scywgYXJyYXlTZXBhcmF0b3IpIHtcclxuXHRcdC8vIFRha2VzIGluIGEgc2V0IG9mIHJvd3MgYW5kIGEgY29scyBvYmplY3QgZm9ybWF0dGVkIGxpa2UgdGhpczpcclxuXHRcdC8vIHtcclxuXHRcdC8vIFx0RVRITklDSVRZOiAzLFxyXG5cdFx0Ly8gXHRBR0U6IDZcclxuXHRcdC8vIH1cclxuXHJcblx0XHQvLyBPdXRwdXRzIGFuIGFycmF5IG9mIG9iamVjdHMsXHJcblx0XHQvLyBlYWNoIG9mIHdoaWNoIGhhcyB0aGUgc2FtZSBpbmRpY2VzIGFzIGNvbHMgYW5kIHJlcHJlc2VudHMgYSByb3dcclxuXHRcdC8vIFRoZSBvdXRwdXQgY2FuIGJlIHVzZWQgd2l0aCBjb25zb2xlLnRhYmxlXHJcblxyXG5cdFx0YXJyYXlTZXBhcmF0b3IgPSBhcnJheVNlcGFyYXRvciB8fCAnLCAnO1xyXG5cclxuXHRcdGxldCB0YWJsZSA9IHRoaXMubWFwKChyb3cpID0+IHtcclxuXHRcdFx0bGV0IG5ld1JvdyA9IHt9O1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgY29sTmFtZSBpbiBjb2xzKSB7XHJcblx0XHRcdFx0bGV0IGNvbCA9IGNvbHNbY29sTmFtZV07XHJcblx0XHRcdFx0bGV0IGNlbGwgPSByb3dbY29sXVxyXG5cdFx0XHRcdC8vIEpvaW4gYXJyYXlzIHNvIHRoZXkgZGlzcGxheSBpbiBjb25zb2xlLnRhYmxlXHJcblx0XHRcdFx0aWYgKGNlbGwgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdFx0XHRcdFx0bmV3Um93W2NvbE5hbWVdID0gY2VsbC5qb2luKGFycmF5U2VwYXJhdG9yKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmV3Um93W2NvbE5hbWVdID0gY2VsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBuZXdSb3c7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gdGFibGU7XHJcblx0fVxyXG5cclxuXHRjcmVhdGVTdWJUYWJsZVN0cmluZyhjb2xzKSB7XHJcblx0XHRsZXQgdGFibGUgPSB0aGlzLmNyZWF0ZVN1YlRhYmxlKGNvbHMsICcsJyk7XHJcblx0XHRsZXQgdGFibGVTdHJpbmcgPSBBbmFseXNlci5fY29udmVydFRhYmxlVG9TdHJpbmcodGFibGUpO1xyXG5cclxuXHRcdHJldHVybiB0YWJsZVN0cmluZztcclxuXHR9XHJcblxyXG5cdGdldENvbFN1bW1hcnkoY29scywgYWxpYXNMaXN0KSB7XHJcblx0XHQvLyBUYWtlcyBpbiBhIHNldCBvZiByb3dzIGFuZCBvbmUgb3IgbW9yZSBjb2x1bW4gbnVtYmVycywgYW5kIG9wdGlvbmFsbHlcclxuXHRcdC8vIGEgbGlzdCBvZiBhbGlhc2VzIC0gYW4gYXJyYXkgb2YgYXJyYXlzIG9mIHN0cmluZ3MgdG8gYmUgZ3JvdXBlZCB0b2dldGhlclxyXG5cclxuXHRcdC8vIE91dHB1dHMgYW4gb2JqZWN0IHN1bW1hcmlzaW5nIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCB2YWx1ZVxyXG5cdFx0Ly8gYXBwZWFyZWQgaW4gdGhlIGdpdmVuIGNvbHVtbiBvZiB0aGUgZ2l2ZW4gcm93c1xyXG5cclxuXHJcblx0XHQvLyBBbGxvdyB0aGUgcGFzc2luZyBvZiBhIHNpbmdsZSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgY29sdW1uIGluZGljZXNcclxuXHRcdGlmICghKGNvbHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuXHRcdFx0Y29scyA9IFtjb2xzXTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgc3VtbWFyeSA9IHt9O1xyXG5cdFx0Zm9yIChsZXQgcm93IG9mIHRoaXMpIHtcclxuXHRcdFx0Zm9yIChsZXQgY29sIG9mIGNvbHMpIHtcclxuXHRcdFx0XHRsZXQgY2VsbFZhbHVlID0gcm93W2NvbF07XHJcblxyXG5cdFx0XHRcdGlmICh0eXBlb2YgY2VsbFZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiBjZWxsVmFsdWUgIT09ICcnKSB7XHJcblxyXG5cdFx0XHRcdFx0bGV0IHZhbHVlcztcclxuXHRcdFx0XHRcdGlmIChjZWxsVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBjZWxsVmFsdWU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBbY2VsbFZhbHVlXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlIGluIHN1bW1hcnkpIHtcclxuXHRcdFx0XHRcdFx0XHRzdW1tYXJ5W3ZhbHVlXSsrO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN1bW1hcnlbdmFsdWVdID0gMTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBhbGlhc0xpc3QgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdHN1bW1hcnkgPSBBbmFseXNlci5fZ3JvdXBDb2xTdW1tYXJ5QnlBbGlhc2VzKHN1bW1hcnksIGFsaWFzTGlzdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1bW1hcnk7XHJcblx0fVxyXG5cclxuXHRnZXRDb2xBc0RhdGFTZXJpZXMoY29sLCBsYWJlbHMpIHtcclxuXHRcdC8vIFRha2VzIGluIGEgc2V0IG9mIHJvd3MgYW5kIGEgY29sdW1uIG51bWJlcixcclxuXHRcdC8vIGFuZCBhbiBhcnJheSBvZiBsYWJlbHMuIE91dHB1dHMgYW4gYXJyYXkgd2hlcmVcclxuXHRcdC8vIGVhY2ggZWxlbWVudCBpcyB0aGUgY291bnQgb2YgdGhlIHZhbHVlcyBtYXRjaGluZ1xyXG5cdFx0Ly8gdGhlIGVsZW1lbnQgb2YgbGFiZWxzIGF0IHRoZSBzYW1lIGluZGV4XHJcblxyXG5cdFx0bGV0IGNvbFN1bW1hcnkgPSB0aGlzLmdldENvbFN1bW1hcnkoY29sKTtcclxuXHJcblx0XHRsZXQgZGF0YVNlcmllcyA9IFtdO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGRhdGFTZXJpZXNbaV0gPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgaW4gY29sU3VtbWFyeSkge1xyXG5cdFx0XHRsZXQgdmFsdWUgPSBjb2xTdW1tYXJ5W2ldO1xyXG5cdFx0XHRsZXQgaW5kZXggPSBsYWJlbHMuaW5kZXhPZihpKTtcclxuXHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdC8vIENvdWxkbid0IGZpbmQgaW5kZXgsIHRyeSBmb3JjaW5nIGl0IHRvIGJlIGEgbnVtYmVyXHJcblx0XHRcdFx0aW5kZXggPSBsYWJlbHMuaW5kZXhPZihwYXJzZUludChpLCAxMCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XHJcblx0XHRcdFx0ZGF0YVNlcmllc1tpbmRleF0gPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhU2VyaWVzO1xyXG5cdH1cclxuXHJcblx0Z2V0Q29tcGFyaXNvblN1bW1hcnkoaGVhZGVyQ29sLCBoZWFkZXJBbGlhc2VzLCB2YXJDb2wsIHZhckFsaWFzZXMpIHtcclxuXHRcdC8vIFRha2VzIGluIGEgc2V0IG9mIHJvd3MgYW5kIHR3byBjb2x1bW4gbnVtYmVyc1xyXG5cdFx0Ly8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGNvbnNvbGUudGFibGVcclxuXHRcdC8vIHdpdGggdGhlIHZhbHVlcyBvZiBoZWFkZXJDb2wgdXNlZCBpbiB0aGUgaGVhZGVyLCBhbmRcclxuXHRcdC8vIHRoZSB2YWx1ZXMgb2YgdmFyQ29sIHVzZWQgZm9yIGVhY2ggcm93LCB3aXRoIHRoZSBjZWxsc1xyXG5cdFx0Ly8gZGVub3RpbmcgdGhlIG51bWJlciBvZiB0aW1lcyB0aGVzZSB2YWx1ZXMgY29pbmNpZGVkXHJcblx0XHQvLyB1c2luZyBmaWx0ZXJSb3dzIHdpdGggdGhlIHBhc3NlZCBzZXRzIG9mIGFsaWFzZXNcclxuXHJcblx0XHQvLyBBbHNvIG9wdGlvbmFsbHkgdGFrZXMgYSBzZXQgb2YgYWxpYXNlcyBmb3Igb25lIG9yIGJvdGggY29sdW1uc1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcblx0XHRcdC8vIE5vIGFsaWFzZXMgc3BlY2lmaWVkXHJcblx0XHRcdHZhckNvbCA9IGhlYWRlckFsaWFzZXM7XHJcblx0XHRcdGhlYWRlckFsaWFzZXMgPSB1bmRlZmluZWQ7XHJcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0Ly8gT25lIGFsaWFzIHNwZWNpZmllZFxyXG5cdFx0XHRpZiAoIShoZWFkZXJBbGlhc2VzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcblx0XHRcdFx0Ly8gaGVhZGVyQWxpYXNlcyB3YXMgbm90IHBhc3NlZFxyXG5cdFx0XHRcdHZhckFsaWFzZXMgPSB2YXJDb2w7XHJcblx0XHRcdFx0dmFyQ29sID0gaGVhZGVyQWxpYXNlcztcclxuXHRcdFx0XHRoZWFkZXJBbGlhc2VzID0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc29sZS5sb2codGhpcyk7XHJcblx0XHRjb25zb2xlLnRyYWNlKCk7XHJcblx0XHRsZXQgaGVhZGVyU3VtbWFyeSA9IHRoaXMuZ2V0Q29sU3VtbWFyeShoZWFkZXJDb2wsIGhlYWRlckFsaWFzZXMpO1xyXG5cdFx0bGV0IHZhclN1bW1hcnkgPSB0aGlzLmdldENvbFN1bW1hcnkodmFyQ29sLCB2YXJBbGlhc2VzKTtcclxuXHJcblx0XHRsZXQgYWxpYXNlcyA9IHt9O1xyXG5cdFx0aWYgKGhlYWRlckFsaWFzZXMpIHtcclxuXHRcdFx0YWxpYXNlcy5IRUFERVJTID0gaGVhZGVyQWxpYXNlcztcclxuXHRcdH1cclxuXHRcdGlmICh2YXJBbGlhc2VzKSB7XHJcblx0XHRcdGFsaWFzZXMuVkFSUyA9IHZhckFsaWFzZXM7XHJcblx0XHR9XHJcblx0XHRsZXQgZmlsdGVycyA9IEFuYWx5c2VyLl9nZXRBbGlhc0ZpbHRlcnMoYWxpYXNlcyk7XHJcblxyXG5cdFx0bGV0IGNvbXBhcmlzb25TdW1tYXJ5ID0ge307XHJcblx0XHRmb3IgKGxldCBpIGluIHZhclN1bW1hcnkpIHtcclxuXHRcdFx0Y29tcGFyaXNvblN1bW1hcnlbaV0gPSB7fTtcclxuXHRcdFx0Zm9yIChsZXQgaiBpbiBoZWFkZXJTdW1tYXJ5KSB7XHJcblx0XHRcdFx0Y29tcGFyaXNvblN1bW1hcnlbaV1bal0gPSBmaWx0ZXJzLmZpbHRlclJvd3ModGhpcyxcclxuXHRcdFx0XHRcdHZhckNvbCwgQW5hbHlzZXIuX2V4dHJhY3RWYWx1ZShpKSxcclxuXHRcdFx0XHRcdGhlYWRlckNvbCwgQW5hbHlzZXIuX2V4dHJhY3RWYWx1ZShqKVxyXG5cdFx0XHRcdCkubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbXBhcmlzb25TdW1tYXJ5O1xyXG5cdH1cclxuXHJcblx0Z2V0Q29tcGFyaXNvblN1bW1hcnlTdHJpbmcoaGVhZGVyQ29sLCBoZWFkZXJBbGlhc2VzLCB2YXJDb2wsIHZhckFsaWFzZXMpIHtcclxuXHRcdC8vIENhbGxzIGdldENvbXBhcmlzb25TdW1tYXJ5IHdpdGggYWxsIGFyZ3VtZW50cyBwYXNzZWQsXHJcblx0XHQvLyB0aGVuIHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIGRhdGEgdGhhdCBjYW4gYmUgY29weS9wYXN0ZWRcclxuXHRcdC8vIGludG8gYSBzcHJlYWRzaGVldFxyXG5cclxuXHRcdGxldCBjb21wYXJpc29uU3VtbWFyeSA9IHRoaXMuZ2V0Q29tcGFyaXNvblN1bW1hcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdGxldCBjb21wYXJpc29uU3VtbWFyeVN0cmluZyA9IEFuYWx5c2VyLl9jb252ZXJ0VGFibGVUb1N0cmluZyhjb21wYXJpc29uU3VtbWFyeSwgdHJ1ZSk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbXBhcmlzb25TdW1tYXJ5U3RyaW5nO1xyXG5cdH1cclxuXHJcblx0c2F2ZUNvbXBhcmlzb25TdW1tYXJ5Q3N2KGZpbGVuYW1lLCBoZWFkZXJDb2wsIGhlYWRlckFsaWFzZXMsIHZhckNvbCwgdmFyQWxpYXNlcykge1xyXG5cdFx0Ly8gQ2FsbHMgZ2V0Q29tcGFyaXNvblN1bW1hcnkgd2l0aCBhbGwgYXJndW1lbnRzIHBhc3NlZCxcclxuXHRcdC8vIHRoZW4gcmV0dXJucyBhIHN0cmluZyBvZiB0aGUgZGF0YSB0aGF0IGNhbiBiZSBjb3B5L3Bhc3RlZFxyXG5cdFx0Ly8gaW50byBhIHNwcmVhZHNoZWV0XHJcblx0XHRsZXQgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblxyXG5cdFx0bGV0IGNvbXBhcmlzb25TdW1tYXJ5ID0gdGhpcy5nZXRDb21wYXJpc29uU3VtbWFyeS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdGxldCBjb21wYXJpc29uU3VtbWFyeUNzdiA9IEFuYWx5c2VyLl9jb252ZXJ0VGFibGVUb1N0cmluZyhjb21wYXJpc29uU3VtbWFyeSwgdHJ1ZSwgJywnLCAnXFxuJyk7XHJcblxyXG5cdFx0bGV0IG9wdGlvbnMgPSB7XHJcblx0XHRcdGZpbGVuYW1lLFxyXG5cdFx0XHR0eXBlOiAndGV4dC9jc3YnLFxyXG5cdFx0fTtcclxuXHJcblx0XHRmaWxlaW8uc2F2ZShjb21wYXJpc29uU3VtbWFyeUNzdiwgb3B0aW9ucyk7XHJcblx0fVxyXG59XHJcblxyXG5jb25zdCBBbmFseXNlciA9IHtcclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHQvLyBGSUxFIFBST0NFU1NJTkcgLy9cclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHRfbG9hZEZpbGU6IGFzeW5jIGZ1bmN0aW9uIChmaWxlQ29uZmlnKSB7XHJcblx0XHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlQ29uZmlnLnBhdGgpO1xyXG5cclxuXHRcdGlmIChyZXNwb25zZS5vaykge1xyXG5cdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuXHJcblx0XHRcdGxldCByb3dzID0gQW5hbHlzZXIuX3BhcnNlQ3N2KGRhdGEpO1xyXG5cdFx0XHRsZXQgZGF0YUNvbmZpZyA9IEFuYWx5c2VyLl9wcm9jZXNzRGF0YShyb3dzLCBmaWxlQ29uZmlnKTtcclxuXHRcdFx0cmV0dXJuIGRhdGFDb25maWc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBmaWxlIGF0ICR7ZmlsZUNvbmZpZy5wYXRofTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0bG9hZEZpbGU6IGZ1bmN0aW9uICguLi5maWxlQ29uZmlnQXJyKSB7XHJcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cdFx0XHQvLyBMb2FkIGVhY2ggZmlsZSwgdGhlbiByZXNvbHZlIHRoZSB3cmFwcGluZyBwcm9taXNlIG9uY2UgYWxsIGFyZSBsb2FkZWRcclxuXHRcdFx0bGV0IHByb21pc2VzID0gZmlsZUNvbmZpZ0Fyci5tYXAoKGZpbGVDb25maWcpID0+IEFuYWx5c2VyLl9sb2FkRmlsZShmaWxlQ29uZmlnKSlcclxuXHRcdFx0UHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4ocmVzb2x2ZSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfcHJvY2Vzc0RhdGE6IGZ1bmN0aW9uIChyb3dzLCBmaWxlQ29uZmlnKSB7XHJcblx0XHQvLyBUYWtlcyBpbiBmaWxlQ29uZmlnIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG5cdFx0Ly8gVGhlIG51bWJlciBvZiBoZWFkZXIgcm93cyB0byByZW1vdmUgZnJvbSByb3dzXHJcblx0XHQvLyBBIGZpbGVDb25maWcgb2JqZWN0IGZvciBjb2x1bW4gbmFtZXNcclxuXHRcdC8vIEFuIG9wdGlvbmFsIHNldCBvZiBhbGlhc2VzXHJcblx0XHQvLyBBbiBvcHRpb25hbCBzZXQgb2YgY29sdW1ucyB3aG9zZSB2YWx1ZXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXJyYXlzXHJcblx0XHQvLyBBbiBvcHRpb25hbCBzZXQgb2YgY29sdW1ucyB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblx0XHQvLyBBbiBvcHRpb25hbCBtYXAgb2YgY29sdW1ucyB0aGF0IHNob3VsZCBiZSBjb21iaW5lZCB3aGVuIGNvbGxlY3RpbmcgZW51bXNcclxuXHJcblx0XHQvLyBUaGUgb3V0cHV0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuXHRcdC8vIFRoZSBoZWFkZXIgcm93cyB0aGF0IHdlcmUgcmVtb3ZlZFxyXG5cdFx0Ly8gVGhlIGZpbGVDb25maWcgb2JqZWN0IGZvciBjb2x1bW4gbmFtZXNcclxuXHRcdC8vIEEgc2V0IG9mIGZpbHRlcnMgcmVzcGVjdGluZyB0aGUgZ2l2ZW4gYWxpYXNlc1xyXG5cdFx0Ly8gRW51bXMgY29sbGVjdGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGNvbHVtbiBuYW1lcyBhbmQgb3B0aW9uYWwgZW51bXNNYXBcclxuXHJcblx0XHQvLyBFeGFtcGxlIGRhdGE6XHJcblx0XHQvLyBoZWFkZXJSb3dzID0gMjtcclxuXHRcdC8vIGZvb3RlclJvd3MgPSAxO1xyXG5cclxuXHRcdC8vIGNvbHMgPSBBbmFseXNlci5nZXRDb2xOdW1iZXJzKHtcclxuXHRcdC8vIFx0RVRITklDSVRZOiAnSycsXHJcblx0XHQvLyBcdFRBQ1RJQ1M6ICdNJ1xyXG5cdFx0Ly8gfSk7XHJcblxyXG5cdFx0Ly8gYXJyYXlDb2xzID0ge307XHJcblx0XHQvLyBhcnJheUNvbHNbY29scy5UQUNUSUNTXSA9ICcgJztcclxuXHJcblx0XHQvLyBkZWZhdWx0Q29scyA9IHt9O1xyXG5cdFx0Ly8gZGVmYXVsdENvbHNbY29scy5WQUxVRV0gPSAwO1xyXG5cclxuXHRcdC8vIGRlZmF1bHRDb2xWYWx1ZXMgPSB7fTtcclxuXHRcdC8vIGRlZmF1bHRDb2xWYWx1ZXNbY29scy5WQUxVRV0gPSAnLSc7XHJcblxyXG5cdFx0Ly8gYWxpYXNlcyA9IHtcclxuXHRcdC8vIFx0RVRITklDSVRZOiBbXHJcblx0XHQvLyBcdFx0W1xyXG5cdFx0Ly8gXHRcdFx0J1BhY2lmaWMnLCAvL05vdCByZXByZXNlbnRlZCBpbiBkYXRhLCBidXQgdXNlZCBhcyBhIGxhYmVsXHJcblx0XHQvLyBcdFx0XHQnUGFjaWZpYyBJc2xhbmQnLFxyXG5cdFx0Ly8gXHRcdFx0J1BhY2lmaWMgSXNsYW5kZXInXHJcblx0XHQvLyBcdFx0XVxyXG5cdFx0Ly8gXHRdXHJcblx0XHQvLyB9O1xyXG5cclxuXHRcdC8vIGVudW1zTWFwID0ge1xyXG5cdFx0Ly8gXHRUQVNFUl9NRVRIT0Q6IFtjb2xzLlRBU0VSX01FVEhPRF8xLCBjb2xzLlRBU0VSX01FVEhPRF8yLCBjb2xzLlRBU0VSX01FVEhPRF8zXVxyXG5cdFx0Ly8gfTtcclxuXHJcblx0XHRmaWxlQ29uZmlnLmhlYWRlclJvd3MgPSBmaWxlQ29uZmlnLmhlYWRlclJvd3MgfHwgMDtcclxuXHRcdGZpbGVDb25maWcuZm9vdGVyUm93cyA9IGZpbGVDb25maWcuZm9vdGVyUm93cyB8fCAwO1xyXG5cdFx0ZmlsZUNvbmZpZy5jb2xzID0gZmlsZUNvbmZpZy5jb2xzIHx8IHt9O1xyXG5cdFx0ZmlsZUNvbmZpZy5hbGlhc2VzID0gZmlsZUNvbmZpZy5hbGlhc2VzIHx8IHt9O1xyXG5cdFx0ZmlsZUNvbmZpZy5hcnJheUNvbHMgPSBmaWxlQ29uZmlnLmFycmF5Q29scyB8fCB7fTtcclxuXHRcdGZpbGVDb25maWcuZW51bXNNYXAgPSBmaWxlQ29uZmlnLmVudW1zTWFwIHx8IHt9O1xyXG5cdFx0ZmlsZUNvbmZpZy51bmlxdWVDb2xzID0gZmlsZUNvbmZpZy51bmlxdWVDb2xzIHx8IFtdO1xyXG5cclxuXHRcdGxldCBkYXRhQ29uZmlnID0ge307XHJcblx0XHRkYXRhQ29uZmlnLmNvbHMgPSBmaWxlQ29uZmlnLmNvbHM7XHJcblx0XHRkYXRhQ29uZmlnLmFsaWFzZXMgPSBmaWxlQ29uZmlnLmFsaWFzZXM7XHJcblx0XHRkYXRhQ29uZmlnLmZpbHRlcnMgPSBBbmFseXNlci5fZ2V0QWxpYXNGaWx0ZXJzKGZpbGVDb25maWcuYWxpYXNlcyk7XHJcblx0XHRkYXRhQ29uZmlnLmVudW1zTWFwID0gZmlsZUNvbmZpZy5lbnVtc01hcDsgLy8gS2VlcCB0aGlzIGZvciBjb21iaW5pbmcgZGF0YVxyXG5cclxuXHRcdGlmIChmaWxlQ29uZmlnLmhlYWRlclJvd3MgIT09IDApIHtcclxuXHRcdFx0Ly8gUmVtb3ZlIGhlYWRlciByb3dzXHJcblx0XHRcdHJvd3Muc3BsaWNlKDAsIGZpbGVDb25maWcuaGVhZGVyUm93cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZpbGVDb25maWcuZm9vdGVyUm93cyAhPT0gMCkge1xyXG5cdFx0XHQvLyBSZW1vdmUgZm9vdGVyIHJvd3NcclxuXHRcdFx0cm93cy5zcGxpY2UoLWZpbGVDb25maWcuZm9vdGVyUm93cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29udmVydCBjZWxscyB0aGF0IGFyZSBsaXN0cyBpbnRvIGFycmF5c1xyXG5cdFx0ZGF0YUNvbmZpZy5yb3dzID0gbmV3IEFuYWx5c2VyUm93cyhyb3dzKTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUNvbmZpZy5yb3dzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCByb3cgPSBkYXRhQ29uZmlnLnJvd3NbaV07XHJcblxyXG5cdFx0XHRmb3IgKGxldCBqIGluIGZpbGVDb25maWcuYXJyYXlDb2xzKSB7XHJcblx0XHRcdFx0cm93W2pdID0gKHJvd1tqXSArICcnKS50cmltKCkuc3BsaXQoZmlsZUNvbmZpZy5hcnJheUNvbHNbal0gfHwgJyAnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIGRlZmF1bHQgdmFsdWVzIGZyb20gc3BlY2lmaWVkIGNvbHVtbnNcclxuXHRcdFx0Zm9yIChsZXQgaiBpbiBmaWxlQ29uZmlnLmRlZmF1bHRDb2xWYWx1ZXMpIHtcclxuXHRcdFx0XHRpZiAoaiBpbiBmaWxlQ29uZmlnLmFycmF5Q29scykge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICgocm93W2pdICsgJycpID09PSAoZmlsZUNvbmZpZy5kZWZhdWx0Q29sVmFsdWVzW2pdICsgJycpKSB7XHJcblx0XHRcdFx0XHRyb3dbal0gPSAnJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFkZCBkZWZhdWx0IHZhbHVlcyB0byBlbXB0eSBjZWxscyBpbiBkZWZhdWx0IGNvbHNcclxuXHRcdFx0Zm9yIChsZXQgaiBpbiBmaWxlQ29uZmlnLmRlZmF1bHRDb2xzKSB7XHJcblx0XHRcdFx0aWYgKGogaW4gZmlsZUNvbmZpZy5hcnJheUNvbHMpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoKHJvd1tqXSArICcnKS50cmltKCkgPT09ICcnKSB7XHJcblx0XHRcdFx0XHRyb3dbal0gPSBmaWxlQ29uZmlnLmRlZmF1bHRDb2xzW2pdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCBmaWx0ZXJzIG9uIHJvd3Mgb2JqZWN0XHJcblx0XHRBbmFseXNlci5fY3JlYXRlUm93RmlsdGVyRnVuY3Rpb25zKGRhdGFDb25maWcucm93cywgZGF0YUNvbmZpZy5maWx0ZXJzKTtcclxuXHJcblx0XHQvLyBCdWlsZCBlbnVtc1xyXG5cdFx0ZGF0YUNvbmZpZy5lbnVtcyA9IEFuYWx5c2VyLl9idWlsZEVudW1zKHJvd3MsIGZpbGVDb25maWcpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhQ29uZmlnO1xyXG5cdH0sXHJcblxyXG5cdF9idWlsZEVudW1zOiBmdW5jdGlvbiAocm93cywgY29uZmlnKSB7XHJcblx0XHRsZXQgZW51bXMgPSB7fTtcclxuXHJcblx0XHRmb3IgKGxldCBjb2wgaW4gY29uZmlnLmNvbHMpIHtcclxuXHJcblx0XHRcdC8vIERvbid0IGNvbGxlY3QgZW51bXMgZm9yIGNvbHVtbnMgc3BlY2lmaWVkIGluIHVuaXF1ZUNvbHMgb3IgZW51bXNNYXBcclxuXHRcdFx0bGV0IGNvbGxlY3QgPSB0cnVlO1xyXG5cdFx0XHRpZiAoY29uZmlnLnVuaXF1ZUNvbHMuaW5jbHVkZXMoY29uZmlnLmNvbHNbY29sXSkpIHtcclxuXHRcdFx0XHRjb2xsZWN0ID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChsZXQgZW51bUNvbCBpbiBjb25maWcuZW51bXNNYXApIHtcclxuXHRcdFx0XHRpZiAoY29uZmlnLmVudW1zTWFwW2VudW1Db2xdLmluY2x1ZGVzKGNvbmZpZy5jb2xzW2NvbF0pKSB7XHJcblx0XHRcdFx0XHRjb2xsZWN0ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb2xsZWN0KSB7XHJcblx0XHRcdFx0ZW51bXNbY29sXSA9IFtdO1xyXG5cdFx0XHRcdEFuYWx5c2VyLl9jb2xsZWN0RW51bXMocm93cywgZW51bXNbY29sXSwgY29uZmlnLmNvbHNbY29sXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAobGV0IGVudW1Db2wgaW4gY29uZmlnLmVudW1zTWFwKSB7XHJcblx0XHRcdGVudW1zW2VudW1Db2xdID0gW107XHJcblx0XHRcdEFuYWx5c2VyLl9jb2xsZWN0RW51bXMuYXBwbHkodGhpcywgW3Jvd3MsIGVudW1zW2VudW1Db2xdXS5jb25jYXQoY29uZmlnLmVudW1zTWFwW2VudW1Db2xdKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVudW1zO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsZWN0RW51bXM6IGZ1bmN0aW9uIChyb3dzLCBlbnVtc0FyciwgLi4uY29scykge1xyXG5cdFx0Ly8gR28gdGhyb3VnaCBhbGwgY2VsbHMgaW4gYSBnaXZlbiBzZXQgb2YgY29sdW1uc1xyXG5cdFx0Ly8gYW5kIGFkZCBhbGwgdW5pcXVlIGVudHJpZXMgZm91bmQgdG8gZW51bXNBcnJcclxuXHJcblx0XHRlbnVtc0FyciA9IGVudW1zQXJyIHx8IFtdO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgcm93ID0gcm93c1tpXTtcclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBjb2xzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0bGV0IGNvbCA9IGNvbHNbal07XHJcblxyXG5cdFx0XHRcdGlmIChyb3dbY29sXSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gMDsgayA8IHJvd1tjb2xdLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdGlmICgocm93W2NvbF1ba10gIT09ICcnKSAmJiAoZW51bXNBcnIuaW5kZXhPZihyb3dbY29sXVtrXSkgPT09IC0xKSkge1xyXG5cdFx0XHRcdFx0XHRcdGVudW1zQXJyLnB1c2gocm93W2NvbF1ba10pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICgocm93W2NvbF0gIT09ICcnKSAmJiAoZW51bXNBcnIuaW5kZXhPZihyb3dbY29sXSkgPT09IC0xKSkge1xyXG5cdFx0XHRcdFx0XHRlbnVtc0Fyci5wdXNoKHJvd1tjb2xdKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZW51bXNBcnI7XHJcblx0fSxcclxuXHJcblx0Y29tYmluZURhdGE6IGZ1bmN0aW9uICguLi5kYXRhQ29uZmlncykge1xyXG5cdFx0Ly8gVGFrZXMgaW4gYW55IG51bWJlciBvZiBkYXRhQ29uZmlnIG9iamVjdHMgZnJvbSBfcHJvY2Vzc0RhdGFcclxuXHRcdC8vIENvbWJpbmVzIHRoZSByb3dzIGFuZCByZWxldmFudCBkYXRhQ29uZmlnIG9iamVjdHMgKGUuZy4gYWxpYXNlcywgZW51bXMpXHJcblx0XHQvLyBLZWVwcyBvbmx5IGNvbHVtbnMgc2hhcmVkIGJ5IGFsbCBkYXRhQ29uZmlnIG9iamVjdHNcclxuXHJcblx0XHQvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIGRhdGEgc2hhcmVkIGJldHdlZW4gZGlmZmVyZW50IHNldHMsXHJcblx0XHQvLyBzbyBkdXBsaWNhdGVzIHdpbGwgKm5vdCogYmUgZGV0ZWN0ZWQgb3IgcmVtb3ZlZFxyXG5cclxuXHRcdC8vIFRoZSBvdXRwdXQgaXMgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIGZvciBfcHJvY2Vzc0RhdGFcclxuXHJcblx0XHRsZXQgY29tYmluZWREYXRhQ29uZmlnID0ge1xyXG5cdFx0XHRjb2xzOiB7fSxcclxuXHRcdFx0cm93czogbmV3IEFuYWx5c2VyUm93cyhbXSksXHJcblx0XHRcdGFsaWFzZXM6IHt9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmICghZGF0YUNvbmZpZ3MgfHwgZGF0YUNvbmZpZ3MubGVuZ3RoIDwgMikge1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCdJbnZhbGlkIGlucHV0cyBwYXNzZWQgdG8gY29tYmluZURhdGEnLCBhcmd1bWVudHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENvbWJpbmUgY29scyBmaXJzdCAvL1xyXG5cclxuXHRcdC8vIEJ1aWxkIGJhc2Ugc2V0IGZyb20gZmlyc3QgY29scyBvYmplY3RcclxuXHRcdGZvciAobGV0IGogaW4gZGF0YUNvbmZpZ3NbMF0uY29scykge1xyXG5cdFx0XHRjb21iaW5lZERhdGFDb25maWcuY29sc1tqXSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVtb3ZlIGFueSBjb2xzIG5vdCBzaGFyZWQgYnkgZXZlcnkgb3RoZXIgY29scyBvYmplY3RcclxuXHRcdGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YUNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGRhdGFDb25maWcgPSBkYXRhQ29uZmlnc1tpXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGogaW4gY29tYmluZWREYXRhQ29uZmlnLmNvbHMpIHtcclxuXHRcdFx0XHRpZiAoIShqIGluIGRhdGFDb25maWcuY29scykpIHtcclxuXHRcdFx0XHRcdGRlbGV0ZSBjb21iaW5lZERhdGFDb25maWcuY29sc1tqXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgY29sSW5kZXggPSAwO1xyXG5cdFx0Zm9yIChsZXQgaiBpbiBjb21iaW5lZERhdGFDb25maWcuY29scykge1xyXG5cdFx0XHRjb21iaW5lZERhdGFDb25maWcuY29sc1tqXSA9IGNvbEluZGV4O1xyXG5cdFx0XHRjb2xJbmRleCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIGNvbWJpbmVkIGNvbHMgb2JqZWN0LCBjb21iaW5lIHJvd3MgYW5kIGFsaWFzZXNcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGRhdGFDb25maWcgPSBkYXRhQ29uZmlnc1tpXTtcclxuXHRcdFx0Ly8gQ29tYmluZSByb3dzIC8vXHJcblxyXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGRhdGFDb25maWcucm93cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGxldCByb3cgPSBbXTtcclxuXHRcdFx0XHRmb3IgKGxldCBrIGluIGNvbWJpbmVkRGF0YUNvbmZpZy5jb2xzKSB7XHJcblx0XHRcdFx0XHRyb3dbY29tYmluZWREYXRhQ29uZmlnLmNvbHNba11dID0gZGF0YUNvbmZpZy5yb3dzW2pdW2RhdGFDb25maWcuY29sc1trXV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb21iaW5lZERhdGFDb25maWcucm93cy5wdXNoKHJvdyk7XHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHQvLyBDb21iaW5lIGFsaWFzZXMgLy9cclxuXHJcblx0XHRcdC8vIExvb3AgdGhyb3VnaCBlYWNoIHJvdydzIGFsaWFzZXMgdG8gY29tYmluZVxyXG5cdFx0XHRmb3IgKGxldCBqIGluIGRhdGFDb25maWcuYWxpYXNlcykge1xyXG5cclxuXHRcdFx0XHQvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIGFsaWFzIGZvciB0aGlzIGNvbHVtbiwgbWFrZSBhbiBlbXB0eSBwbGFjZWhvbGRlclxyXG5cdFx0XHRcdGlmICghKGogaW4gY29tYmluZWREYXRhQ29uZmlnLmFsaWFzZXMpKSB7XHJcblx0XHRcdFx0XHRjb21iaW5lZERhdGFDb25maWcuYWxpYXNlc1tqXSA9IFtdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGVhY2ggYWxpYXNTZXQgZm9yIHRoaXMgY29sdW1uXHJcblx0XHRcdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBkYXRhQ29uZmlnLmFsaWFzZXNbal0ubGVuZ3RoOyBrKyspIHtcclxuXHRcdFx0XHRcdGxldCBhbGlhc1NldCA9IGRhdGFDb25maWcuYWxpYXNlc1tqXVtrXTtcclxuXHJcblx0XHRcdFx0XHQvLyBDb21iaW5lIGFsaWFzU2V0cyBiYXNlZCBvZmYgdGhlaXIgZmlyc3QgZWxlbWVudCwgd2hpY2ggaXMgdXNlZCBhcyBhIGxhYmVsXHJcblx0XHRcdFx0XHRsZXQgY29tYmluZWRBbGlhc1NldCA9IFtdO1xyXG5cdFx0XHRcdFx0bGV0IGw7XHJcblx0XHRcdFx0XHRmb3IgKGwgPSAwOyBsIDwgY29tYmluZWREYXRhQ29uZmlnLmFsaWFzZXNbal0ubGVuZ3RoOyBsKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKGNvbWJpbmVkRGF0YUNvbmZpZy5hbGlhc2VzW2pdW2xdWzBdID09PSBhbGlhc1NldFswXSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbWJpbmVkQWxpYXNTZXQgPSBjb21iaW5lZERhdGFDb25maWcuYWxpYXNlc1tqXVtsXTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbWJpbmVkQWxpYXNTZXQgPSBjb21iaW5lZEFsaWFzU2V0LmNvbmNhdChhbGlhc1NldCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcclxuXHRcdFx0XHRcdGNvbWJpbmVkQWxpYXNTZXQgPSBjb21iaW5lZEFsaWFzU2V0LmZpbHRlcihmdW5jdGlvbiAoYWxpYXMsIGluZGV4LCBhcnJheSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gYXJyYXkuaW5kZXhPZihhbGlhcykgPT09IGluZGV4O1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gQXBwZW5kIG9yIHJlcGxhY2UgYWxpYXNTZXQgaW4gY29tYmluZWREYXRhQ29uZmlnXHJcblx0XHRcdFx0XHRpZiAobCA8IGNvbWJpbmVkRGF0YUNvbmZpZy5hbGlhc2VzW2pdLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRjb21iaW5lZERhdGFDb25maWcuYWxpYXNlc1tqXVtsXSA9IGNvbWJpbmVkQWxpYXNTZXQ7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb21iaW5lZERhdGFDb25maWcuYWxpYXNlc1tqXS5wdXNoKGNvbWJpbmVkQWxpYXNTZXQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENyZWF0ZSBuZXcgZmlsdGVycyB1c2luZyBjb21iaW5lZCBhbGlhc2VzXHJcblx0XHRjb21iaW5lZERhdGFDb25maWcuZmlsdGVycyA9IEFuYWx5c2VyLl9nZXRBbGlhc0ZpbHRlcnMoY29tYmluZWREYXRhQ29uZmlnLmFsaWFzZXMpO1xyXG5cdFx0QW5hbHlzZXIuX2NyZWF0ZVJvd0ZpbHRlckZ1bmN0aW9ucyhjb21iaW5lZERhdGFDb25maWcucm93cywgY29tYmluZWREYXRhQ29uZmlnLmZpbHRlcnMpO1xyXG5cclxuXHRcdC8vIENvbWJpbmUgdW5pcXVlQ29sc1xyXG5cdFx0Y29tYmluZWREYXRhQ29uZmlnLnVuaXF1ZUNvbHMgPSBbXTtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YUNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGRhdGFDb25maWcgPSBkYXRhQ29uZmlnc1tpXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGogaW4gZGF0YUNvbmZpZy51bmlxdWVDb2xzKSB7XHJcblx0XHRcdFx0bGV0IG9yaWdpbmFsQ29sID0gZGF0YUNvbmZpZy51bmlxdWVDb2xzW2pdO1xyXG5cdFx0XHRcdGxldCBvcmlnaW5hbENvbE5hbWUgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0Zm9yIChsZXQgayBpbiBkYXRhQ29uZmlnLmNvbHMpIHtcclxuXHRcdFx0XHRcdGlmIChkYXRhQ29uZmlnLmNvbHNbbF0gPT09IG9yaWdpbmFsQ29sKSB7XHJcblx0XHRcdFx0XHRcdG9yaWdpbmFsQ29sTmFtZSA9IGw7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG9yaWdpbmFsQ29sTmFtZSkge1xyXG5cdFx0XHRcdFx0bGV0IG9yaWdpbmFsQ29sSW5kZXggPSBjb21iaW5lZERhdGFDb25maWcuY29sc1tvcmlnaW5hbENvbE5hbWVdO1xyXG5cclxuXHRcdFx0XHRcdGlmIChjb21iaW5lZERhdGFDb25maWcudW5pcXVlQ29scy5pbmRleE9mKG9yaWdpbmFsQ29sSW5kZXgpID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRjb21iaW5lZERhdGFDb25maWcudW5pcXVlQ29scy5wdXNoKGNvbWJpbmVkRGF0YUNvbmZpZy5jb2xzW29yaWdpbmFsQ29sTmFtZV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENvbWJpbmUgdGhlIGVudW1zTWFwcywgdGhlbiBidWlsZCBjb21iaW5lZCBlbnVtc1xyXG5cdFx0Y29tYmluZWREYXRhQ29uZmlnLmVudW1zTWFwID0ge307XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFDb25maWdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBkYXRhQ29uZmlnID0gZGF0YUNvbmZpZ3NbaV07XHJcblxyXG5cdFx0XHRmb3IgKGxldCBqIGluIGRhdGFDb25maWcuZW51bXNNYXApIHtcclxuXHRcdFx0XHRsZXQgb3JpZ2luYWxFbnVtc01hcCA9IGRhdGFDb25maWcuZW51bXNNYXBbal07XHJcblxyXG5cdFx0XHRcdGlmICghb3JpZ2luYWxFbnVtc01hcCkge1xyXG5cdFx0XHRcdFx0Ly8gTWFyayB0aGlzIGVudW1zTWFwIGFzIG51bGwgdG8gZGVub3RlIHRoYXQgaXQgZG9lc24ndFxyXG5cdFx0XHRcdFx0Ly8gZXhpc3QgYWNyb3NzIGFsbCBkYXRhQ29uZmlncyB3ZSBhcmUgY29tYmluaW5nXHJcblx0XHRcdFx0XHRjb21iaW5lZERhdGFDb25maWcuZW51bXNNYXBbal0gPSBudWxsO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoY29tYmluZWREYXRhQ29uZmlnLmVudW1zTWFwW2pdICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGNvbWJpbmVkRGF0YUNvbmZpZy5lbnVtc01hcFtqXSA9IGNvbWJpbmVkRGF0YUNvbmZpZy5lbnVtc01hcFtqXSB8fCBbXTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAobGV0IGsgPSAwOyBrIDwgb3JpZ2luYWxFbnVtc01hcC5sZW5ndGg7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRcdGxldCBvcmlnaW5hbENvbCA9IG9yaWdpbmFsRW51bXNNYXBba107XHJcblx0XHRcdFx0XHRcdFx0bGV0IG9yaWdpbmFsQ29sTmFtZSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBsIGluIGRhdGFDb25maWcuY29scykge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGRhdGFDb25maWcuY29sc1tsXSA9PT0gb3JpZ2luYWxDb2wpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxDb2xOYW1lID0gbDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAob3JpZ2luYWxDb2xOYW1lKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsZXQgb3JpZ2luYWxDb2xJbmRleCA9IGNvbWJpbmVkRGF0YUNvbmZpZy5jb2xzW29yaWdpbmFsQ29sTmFtZV07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNvbWJpbmVkRGF0YUNvbmZpZy5lbnVtc01hcFtqXS5pbmRleE9mKG9yaWdpbmFsQ29sSW5kZXgpID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjb21iaW5lZERhdGFDb25maWcuZW51bXNNYXBbal0ucHVzaChjb21iaW5lZERhdGFDb25maWcuY29sc1tvcmlnaW5hbENvbE5hbWVdKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAobGV0IGogaW4gY29tYmluZWREYXRhQ29uZmlnLmVudW1zTWFwKSB7XHJcblx0XHRcdFx0aWYgKGNvbWJpbmVkRGF0YUNvbmZpZy5lbnVtc01hcFtqXSA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIGNvbWJpbmVkRGF0YUNvbmZpZ1tlbnVtc01hcFtqXV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRjb21iaW5lZERhdGFDb25maWcuZW51bXMgPSBBbmFseXNlci5fYnVpbGRFbnVtcyhjb21iaW5lZERhdGFDb25maWcucm93cywgY29tYmluZWREYXRhQ29uZmlnKTtcclxuXHJcblx0XHRyZXR1cm4gY29tYmluZWREYXRhQ29uZmlnO1xyXG5cdH0sXHJcblxyXG5cdC8vLy8vLy8vLy8vLy8vLy8vXHJcblx0Ly8gQ1NWIFBBUlNJTkcgLy9cclxuXHQvLy8vLy8vLy8vLy8vLy8vL1xyXG5cdF9wYXJzZUNzdjogZnVuY3Rpb24gKGNzdikge1xyXG5cdFx0Ly8gUGFyc2UgYSBDU1YgZmlsZSB0aGVuIHByb2Nlc3MgdGhlIGRhdGFcclxuXHRcdC8vIENvbnZlcnQgc3RyaW5ncyB0byBudW1iZXJzIHdoZXJlIGFwcHJvcHJpYXRlLFxyXG5cdFx0Ly8gdGhlbiBwYXNzIHRoZSBkYXRhIHRvIGEgY2FsbGJhY2sgZnVuY3Rpb25cclxuXHJcblx0XHRsZXQgZGF0YSA9IHBhcnNlKGNzdik7XHJcblx0XHRkYXRhID0gQW5hbHlzZXIuX2V4dHJhY3RDZWxsVmFsdWVzKGRhdGEpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdF9leHRyYWN0Q2VsbFZhbHVlczogZnVuY3Rpb24gKHJhd1Jvd3MpIHtcclxuXHRcdC8vIFVzZSBfZXh0cmFjdFZhbHVlIG9uIGVhY2ggY2VsbFxyXG5cdFx0bGV0IHJvd3MgPSByYXdSb3dzLm1hcCgocm93KSA9PiByb3cubWFwKEFuYWx5c2VyLl9leHRyYWN0VmFsdWUpKTtcclxuXHRcdHJldHVybiByb3dzO1xyXG5cdH0sXHJcblxyXG5cdF9leHRyYWN0VmFsdWU6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHRcdC8vIENvbnZlcnQgc3RyaW5ncyB0byBib29sZWFucyBvciBudW1iZXJzIHdoZXJlIHBvc3NpYmxlXHJcblxyXG5cdFx0aWYgKHN0cmluZyA9PT0gJ3RydWUnKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmIChzdHJpbmcgPT09ICdmYWxzZScpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIEFuYWx5c2VyLl9leHRyYWN0TnVtYmVyKHN0cmluZyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2V4dHJhY3ROdW1iZXI6IGZ1bmN0aW9uIChzdHJpbmcpIHtcclxuXHRcdC8vIENvbnZlcnQgc3RyaW5ncyB0byBudW1iZXJzIHdoZXJlIHBvc3NpYmxlXHJcblxyXG5cdFx0bGV0IHZhbCA9IHN0cmluZy5yZXBsYWNlKC8sfCUkL2csICcnKTtcclxuXHJcblx0XHRpZiAocGFyc2VGbG9hdCh2YWwpID09PSArdmFsKSB7XHJcblx0XHRcdGlmIChzdHJpbmcubWF0Y2goLyUkLykpIHtcclxuXHRcdFx0XHQvLyBJZiB0aGUgdmFsdWUgaXMgYSBwZXJjZW50YWdlLCBkaXZpZGUgYnkgMTAwXHJcblxyXG5cdFx0XHRcdC8vIENvbnZlcnQgdG8gc3RyaW5nIHRvIHNlZSBob3cgbWFueSBwbGFjZXMgYWZ0ZXIgdGhlIHBvaW50LCB0byByb3VuZCBhZnRlciBkaXZpZGluZ1xyXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB5b3UnbGwgZ2V0IG51bWJlcnMgbGlrZSAwLjEwODAwMDAwMDAwMDAwMDAxXHJcblx0XHRcdFx0bGV0IGxlbmd0aCA9ICh2YWwgKyAnJyk7XHJcblx0XHRcdFx0bGVuZ3RoLnJlcGxhY2UoL15bXi5dKy8sICcnKTtcclxuXHRcdFx0XHRsZW5ndGggPSBsZW5ndGgubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHR2YWwgPSB2YWwgLyAxMDA7XHJcblx0XHRcdFx0dmFsID0gdmFsLnRvRml4ZWQobGVuZ3RoKzIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiArdmFsO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHN0cmluZztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLy8vLy8vLy8vLy8vLy9cclxuXHQvLyBGSUxURVJJTkcgLy9cclxuXHQvLy8vLy8vLy8vLy8vLy9cclxuXHRfZ2V0QWxpYXNGaWx0ZXJzOiBmdW5jdGlvbiAoYWxpYXNlcykge1xyXG5cdFx0Y29uc3QgZmlsdGVyUm93cyA9IGZ1bmN0aW9uIChyb3dzLCBvclRvZ2dsZSwgY29sSW5kZXgxLCB2YWx1ZXMxLCBjb2xJbmRleDIsIHZhbHVlczIsIGNvbEluZGV4TiwgdmFsdWVzTikge1xyXG5cdFx0XHQvLyBUYWtlcyBpbiBhIHJvd3Mgb2JqZWN0IChpbXBvcnRlZCBmcm9tIGNzdiksXHJcblx0XHRcdC8vIGEgYm9vbGVhbiBzcGVjaWZ5aW5nIHdoZXRoZXIgaXQncyBhbiBcImFuZFwiIG9yIGFuIFwib3JcIiBmaWx0ZXIsXHJcblx0XHRcdC8vIGFuZCBhbnkgbnVtYmVyIG9mIHBhaXJzIChhdCBsZWFzdCBvbmUpIG9mXHJcblx0XHRcdC8vIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRvIGNvbnNpZGVyLCBhbmQgYW4gYXJyYXkgb2YgdmFsdWVzXHJcblxyXG5cdFx0XHQvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJvd3Mgd2hlcmUgdGhlIGNlbGwgaW4gdGhlIGNvbHVtblxyXG5cdFx0XHQvLyBzcGVjaWZpZWQgY29udGFpbnMgYSB2YWx1ZSBpbiB0aGUgYXJyYXkgb2YgdmFsdWVzIGdpdmVuXHJcblx0XHRcdC8vIGZvciBhbGwgY29sdW1uIGFuZCB2YWx1ZSBwYWlyc1xyXG5cclxuXHRcdFx0bGV0IGFuZCA9ICFvclRvZ2dsZTtcclxuXHRcdFx0bGV0IHN0YXJ0QXQgPSAyO1xyXG5cclxuXHRcdFx0bGV0IGZpbHRlcmVkUm93cyA9IFtdO1xyXG5cclxuXHRcdFx0aWYgKChhcmd1bWVudHMubGVuZ3RoIDwgNCkgfHwgKCgoYXJndW1lbnRzLmxlbmd0aC0yKSAlIDIpICE9PSAwKSkge1xyXG5cdFx0XHRcdC8vIEFzc3VtZSBcImFuZFRvZ2dsZVwiIGhhcyBub3QgYmVlbiBwYXNzZWRcclxuXHRcdFx0XHRhbmQgPSB0cnVlO1xyXG5cdFx0XHRcdHN0YXJ0QXQgPSAxO1xyXG5cdFx0XHRcdGlmICgoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHx8ICgoKGFyZ3VtZW50cy5sZW5ndGgtMSkgJSAyKSAhPT0gMCkpIHtcclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0FuIGludmFsaWQgc2V0IG9mIGFyZ3VtZW50cyB3YXMgcGFzc2VkIHRvIGZpbHRlclJvd3MnKTtcclxuXHRcdFx0XHRcdHJldHVybiBbXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldCBmaWx0ZXJzID0gW107XHJcblx0XHRcdGZvciAobGV0IGkgPSBzdGFydEF0OyBpIDwgYXJndW1lbnRzLmxlbmd0aC0xOyBpICs9IDIpIHtcclxuXHRcdFx0XHRsZXQgZmlsdGVyID0ge1xyXG5cdFx0XHRcdFx0Y29sSW5kZXg6IGFyZ3VtZW50c1tpXSxcclxuXHRcdFx0XHRcdHZhbHVlczogYXJndW1lbnRzW2krMV1cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRpZiAoIShBcnJheS5pc0FycmF5KGZpbHRlci52YWx1ZXMpIHx8IGZpbHRlci52YWx1ZXMgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcclxuXHRcdFx0XHRcdGZpbHRlci52YWx1ZXMgPSBbZmlsdGVyLnZhbHVlc107XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmaWx0ZXJzLnB1c2goZmlsdGVyKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IHJvdyA9IHJvd3NbaV07XHJcblxyXG5cdFx0XHRcdGxldCBpc01hdGNoID0gISFhbmQ7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgZmlsdGVycy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0bGV0IGZpbHRlciA9IGZpbHRlcnNbal07XHJcblxyXG5cdFx0XHRcdFx0aWYgKGFuZCkge1xyXG5cdFx0XHRcdFx0XHRpc01hdGNoID0gaXNNYXRjaCAmJiBBbmFseXNlci5fYXBwbHlGaWx0ZXIocm93LCBmaWx0ZXIuY29sSW5kZXgsIGZpbHRlci52YWx1ZXMsIGFsaWFzZXMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0aXNNYXRjaCA9IGlzTWF0Y2ggfHwgQW5hbHlzZXIuX2FwcGx5RmlsdGVyKHJvdywgZmlsdGVyLmNvbEluZGV4LCBmaWx0ZXIudmFsdWVzLCBhbGlhc2VzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc01hdGNoKSB7XHJcblx0XHRcdFx0XHRmaWx0ZXJlZFJvd3MucHVzaChyb3cpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZmlsdGVyZWRSb3dzID0gbmV3IEFuYWx5c2VyUm93cyhmaWx0ZXJlZFJvd3MpO1xyXG5cdFx0XHRmaWx0ZXJlZFJvd3MuZmlsdGVyID0gcm93cy5maWx0ZXI7XHJcblx0XHRcdGZpbHRlcmVkUm93cy5maWx0ZXJBbmQgPSByb3dzLmZpbHRlckFuZDtcclxuXHRcdFx0ZmlsdGVyZWRSb3dzLmZpbHRlck9yID0gcm93cy5maWx0ZXJPcjtcclxuXHJcblx0XHRcdHJldHVybiBmaWx0ZXJlZFJvd3M7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGZpbHRlclJvd3NBbmQgPSBmdW5jdGlvbiAocm93cywgY29sSW5kZXgxLCB2YWx1ZXMxLCBjb2xJbmRleDIsIHZhbHVlczIsIGNvbEluZGV4TiwgdmFsdWVzTikge1xyXG5cdFx0XHRsZXQgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xyXG5cclxuXHRcdFx0YXJncyA9IGFyZ3Muc2xpY2UoMSk7XHJcblx0XHRcdGFyZ3Muc3BsaWNlKDAsIDAsIGZhbHNlKTtcclxuXHRcdFx0YXJncy5zcGxpY2UoMCwgMCwgcm93cyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmlsdGVyUm93cy5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgZmlsdGVyUm93c09yID0gZnVuY3Rpb24gKHJvd3MsIGNvbEluZGV4MSwgdmFsdWVzMSwgY29sSW5kZXgyLCB2YWx1ZXMyLCBjb2xJbmRleE4sIHZhbHVlc04pIHtcclxuXHRcdFx0bGV0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcclxuXHJcblx0XHRcdGFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xyXG5cdFx0XHRhcmdzLnNwbGljZSgwLCAwLCB0cnVlKTtcclxuXHRcdFx0YXJncy5zcGxpY2UoMCwgMCwgcm93cyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmlsdGVyUm93cy5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0ZmlsdGVyUm93czogZmlsdGVyUm93cyxcclxuXHRcdFx0ZmlsdGVyUm93c0FuZDogZmlsdGVyUm93c0FuZCxcclxuXHRcdFx0ZmlsdGVyUm93c09yOiBmaWx0ZXJSb3dzT3JcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZVJvd0ZpbHRlckZ1bmN0aW9uczogZnVuY3Rpb24gKHJvd3MsIGZpbHRlcnMpIHtcclxuXHRcdHJvd3MuZmlsdGVyID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYXJncyA9IFt0aGlzXS5jb25jYXQoQXJyYXkuZnJvbShhcmd1bWVudHMpKTtcclxuXHJcblx0XHRcdHJldHVybiBmaWx0ZXJzLmZpbHRlclJvd3MuYXBwbHkodGhpcywgYXJncyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHJvd3MuZmlsdGVyT3IgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBhcmdzID0gW3RoaXNdLmNvbmNhdChBcnJheS5mcm9tKGFyZ3VtZW50cykpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZpbHRlcnMuZmlsdGVyUm93c09yLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyb3dzLmZpbHRlckFuZCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGFyZ3MgPSBbdGhpc10uY29uY2F0KEFycmF5LmZyb20oYXJndW1lbnRzKSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmlsdGVycy5maWx0ZXJSb3dzQW5kLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRfYXBwbHlGaWx0ZXI6IGZ1bmN0aW9uIChyb3csIGNvbEluZGV4LCB2YWx1ZXMsIGFsaWFzZXMpIHtcclxuXHRcdC8vIEFsbG93IGZ1bmN0aW9ucyB0byBiZSBwYXNzZWQgYXMgZmlsdGVyIHRlc3RzXHJcblx0XHRpZiAodmFsdWVzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuXHRcdFx0cmV0dXJuIHZhbHVlcyhyb3dbY29sSW5kZXhdKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiBvbmUgb3IgbW9yZSB2YWx1ZXMgaXMgcGFzc2VkLCB0ZXN0IGl0IGFnYWluc3QgYWxpYXNlc1xyXG5cdFx0aWYgKCEodmFsdWVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcblx0XHRcdHZhbHVlcyA9IFt2YWx1ZXNdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBjZWxsID0gcm93W2NvbEluZGV4XTtcclxuXHRcdGxldCBjZWxsVmFsdWVzO1xyXG5cclxuXHRcdGlmIChjZWxsIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0Y2VsbFZhbHVlcyA9IGNlbGw7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjZWxsVmFsdWVzID0gW2NlbGxdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbFZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY2VsbFZhbHVlID0gY2VsbFZhbHVlc1tpXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGsgPSAwOyBrIDwgdmFsdWVzLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0aWYgKEFuYWx5c2VyLl9tYXRjaEFsaWFzKHZhbHVlc1trXSwgY2VsbFZhbHVlLCBhbGlhc2VzKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF9tYXRjaEFsaWFzOiBmdW5jdGlvbiAoY2VsbCwgdmFsdWUsIGFsaWFzU3VwZXJzZXQpIHtcclxuXHRcdC8vIENoZWNrcyBpZiB0aGUgdmFsdWUgb2YgYSBjZWxsIG1hdGNoZXMgdGhlIHZhbHVlIHBhc3NlZCxcclxuXHRcdC8vIG9wdGlvbmFsbHkgdGFraW5nIG9uZSBvciBtb3JlIHNldHMgb2YgYWxpYXNlcyB0byBtYXRjaFxyXG5cclxuXHRcdC8vIFRoZSBhbGlhc1N1cGVyc2V0IGlzIHVzZWQgYmVjYXVzZSB0aGUgZGVmYXVsdCBzZXQgb2YgYWxsXHJcblx0XHQvLyBhbGlhc2VzIHdpbGwgYmUgdXNlZCBpZiBubyBhbGlhc1NldCBpcyBzcGVjaWZpZWRcclxuXHJcblx0XHRpZiAoY2VsbCA9PT0gdmFsdWUpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ291bGQgYmUgYXJyYXkgb3Igb2JqZWN0XHJcblx0XHRmb3IgKGxldCBpIGluIGFsaWFzU3VwZXJzZXQpIHtcclxuXHRcdFx0bGV0IGFsaWFzU2V0ID0gYWxpYXNTdXBlcnNldFtpXTtcclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBhbGlhc1NldC5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGxldCBhbGlhc0xpc3QgPSBhbGlhc1NldFtqXTtcclxuXHJcblx0XHRcdFx0aWYgKFxyXG5cdFx0XHRcdFx0KGFsaWFzTGlzdC5pbmRleE9mKGNlbGwpICE9PSAtMSkgJiZcclxuXHRcdFx0XHRcdChhbGlhc0xpc3QuaW5kZXhPZih2YWx1ZSkgIT09IC0xKVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHQvLyBIRUxQRVIgRlVOQ1RJT05TIC8vXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cdGdldENvbE51bWJlcjogZnVuY3Rpb24gKGNvbE5hbWUpIHtcclxuXHRcdC8vIFRha2VzIGluIGEgc3RyaW5nIGxpa2UgXCJDRVwiIGFuZCBjb252ZXJ0cyBpdCB0byBhIHJvdyBudW1iZXIgbGlrZSA4MlxyXG5cclxuXHRcdGlmICghKHR5cGVvZiBjb2xOYW1lID09PSAnc3RyaW5nJyB8fCBjb2xOYW1lIGluc3RhbmNlb2YgU3RyaW5nKSkge1xyXG5cdFx0XHQvLyBOb3QgYSBzdHJpbmdcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGFscGhhYmV0ID0gWydBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onXTtcclxuXHRcdGxldCByb3dOdW1iZXIgPSAtMTsgLy8gQWRqdXN0IGZvciAwLWJhc2VkIGNvdW50aW5nXHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjb2xOYW1lLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBjaGFyID0gY29sTmFtZS50b1VwcGVyQ2FzZSgpW2ldO1xyXG5cdFx0XHRsZXQgY2hhckluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihjaGFyKTtcclxuXHJcblx0XHRcdGlmIChjaGFySW5kZXggPT09IC0xKSB7XHJcblx0XHRcdFx0Ly8gU3RyaW5nIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJvd051bWJlciArPSAoY2hhckluZGV4ICsgMSkgKiBNYXRoLnBvdyhhbHBoYWJldC5sZW5ndGgsIGNvbE5hbWUubGVuZ3RoIC0gKGkrMSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByb3dOdW1iZXI7XHJcblx0fSxcclxuXHJcblx0Z2V0Q29sTnVtYmVyczogZnVuY3Rpb24gKGNvbHMpIHtcclxuXHRcdC8vIFRha2VzIGluIGEgZmxhdCBvYmplY3QgYW5kIHJ1bnMgZWFjaCBwcm9wZXJ0eSB0aHJvdWdoIGdldENvbE51bWJlclxyXG5cdFx0bGV0IG5ld0NvbHMgPSB7fTtcclxuXHJcblx0XHRmb3IgKGxldCBrZXkgaW4gY29scykge1xyXG5cdFx0XHRsZXQgdmFsID0gY29sc1trZXldO1xyXG5cclxuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZykge1xyXG5cdFx0XHRcdHZhbCA9IEFuYWx5c2VyLmdldENvbE51bWJlcihjb2xzW2tleV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWwpICYmIHZhbCA+PSAwKSB7XHJcblx0XHRcdFx0bmV3Q29sc1trZXldID0gdmFsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld0NvbHM7XHJcblx0fSxcclxuXHJcblx0Ly8vLy8vLy8vLy8vLy8vLy8vL1xyXG5cdC8vIFNVTU1BUlkgVE9PTFMgLy9cclxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vXHJcblx0X2NvbnZlcnRUYWJsZVRvU3RyaW5nOiBmdW5jdGlvbiAodGFibGUsIHVzZUtleXMsIGNlbGxTZXBhcmF0b3JPcHRpb24sIHJvd1NlcGFyYXRvck9wdGlvbikge1xyXG5cdFx0Y29uc3QgY2VsbFNlcGFyYXRvciA9IGNlbGxTZXBhcmF0b3JPcHRpb24gfHwgJ1xcdCc7XHJcblx0XHRjb25zdCByb3dTZXBhcmF0b3IgPSByb3dTZXBhcmF0b3JPcHRpb24gfHwgJ1xcbic7XHJcblxyXG5cdFx0bGV0IHRhYmxlU3RyaW5nID0gJyc7XHJcblxyXG5cdFx0bGV0IGFkZENlbGwgPSAoY2VsbFN0cmluZykgPT4ge1xyXG5cdFx0XHRpZiAodHlwZW9mIGNlbGxTdHJpbmcgIT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0Y2VsbFN0cmluZyA9ICcnICsgY2VsbFN0cmluZztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGNlbGxTdHJpbmcuaW5kZXhPZihjZWxsU2VwYXJhdG9yKSAhPT0gLTEpIHtcclxuXHRcdFx0XHQvLyBJZiB0aGUgY2VsbCBzdHJpbmcgY29udGFpbnMgdGhlIHNlcGFyYXRvciBzZXF1ZW5jZSxcclxuXHRcdFx0XHQvLyB3cmFwIGl0IGluIFwiIGFuZCBlc2NhcGUgYW55IGV4aXN0aW5nIFwiIGFzIFwiXCJcclxuXHRcdFx0XHRjZWxsU3RyaW5nID0gJ1wiJyArIGNlbGxTdHJpbmcucmVwbGFjZSgvXCIvZywgJ1wiXCInKSArICdcIic7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRhYmxlU3RyaW5nICs9IGNlbGxTdHJpbmcgKyBjZWxsU2VwYXJhdG9yO1xyXG5cdFx0fTtcclxuXHRcdGxldCBlbmRMaW5lID0gKCkgPT4ge1xyXG5cdFx0XHQvLyBUcmltIG9mZiBsYXN0IGNlbGwgc2VwYXJhdG9yLCByZXBsYWNlIHdpdGggbmV3bGluZVxyXG5cdFx0XHR0YWJsZVN0cmluZyA9IHRhYmxlU3RyaW5nLnN1YnN0cigwLCB0YWJsZVN0cmluZy5sZW5ndGggLSBjZWxsU2VwYXJhdG9yLmxlbmd0aCkgKyByb3dTZXBhcmF0b3I7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFJlbmRlciBoZWFkZXJzIGFuZCBjcmVhdGUgYXJyYXkgb2YgbGFiZWxzXHJcblx0XHRpZiAodXNlS2V5cykge1xyXG5cdFx0XHR0YWJsZVN0cmluZyArPSBjZWxsU2VwYXJhdG9yO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBmaXJzdFJvd0NvbXBsZXRlID0gZmFsc2U7XHJcblx0XHRmb3IgKGxldCByb3dOYW1lIGluIHRhYmxlKSB7XHJcblx0XHRcdGlmIChmaXJzdFJvd0NvbXBsZXRlID09PSB0cnVlKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0Zmlyc3RSb3dDb21wbGV0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRsZXQgcm93ID0gdGFibGVbcm93TmFtZV07XHJcblx0XHRcdGZvciAobGV0IGNvbE5hbWUgaW4gcm93KSB7XHJcblx0XHRcdFx0YWRkQ2VsbChjb2xOYW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZW5kTGluZSgpO1xyXG5cclxuXHRcdGZvciAobGV0IHJvd05hbWUgaW4gdGFibGUpIHtcclxuXHRcdFx0bGV0IGlzRmlyc3RSb3cgPSBmYWxzZTtcclxuXHRcdFx0bGV0IHJvdyA9IHRhYmxlW3Jvd05hbWVdO1xyXG5cdFx0XHRmb3IgKGxldCBjb2xOYW1lIGluIHJvdykge1xyXG5cdFx0XHRcdGxldCBjZWxsID0gcm93W2NvbE5hbWVdO1xyXG5cdFx0XHRcdGlmICh1c2VLZXlzKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNGaXJzdFJvdyA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdFx0YWRkQ2VsbChyb3dOYW1lKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlzRmlyc3RSb3cgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YWRkQ2VsbChjZWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbmRMaW5lKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRhYmxlU3RyaW5nO1xyXG5cdH0sXHJcblxyXG5cdF9ncm91cENvbFN1bW1hcnlCeUFsaWFzZXM6IGZ1bmN0aW9uIChzdW1tYXJ5LCBhbGlhc0xpc3QpIHtcclxuXHRcdC8vIFRha2VzIGEgc3VtbWFyeSBvYmplY3QgbGlrZSB0aGUgb3V0cHV0IGZyb20gZ2V0Q29sU3VtbWFyeSwgYW5kXHJcblx0XHQvLyBhIGxpc3Qgb2YgYWxpYXNlcyAtIGFuIGFycmF5IG9mIGFycmF5cyBvZiBzdHJpbmdzIHRvIGJlIGdyb3VwZWQgdG9nZXRoZXJcclxuXHJcblx0XHQvLyBPdXRwdXRzIGEgc3VtbWFyeSBvYmplY3Qgd2hlcmUgdmFsdWVzIHdpdGhpbiB0aGUgc2FtZSBzZXQgb2YgYWxpYXNlcyBhcmUgZ3JvdXBlZFxyXG5cclxuXHRcdGxldCBuZXdTdW1tYXJ5ID0ge307XHJcblx0XHRmb3IgKGxldCBpIGluIHN1bW1hcnkpIHtcclxuXHRcdFx0bGV0IGluQWxpYXMgPSBmYWxzZTtcclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBhbGlhc0xpc3QubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRsZXQgYWxpYXNlcyA9IGFsaWFzTGlzdFtqXTtcclxuXHJcblx0XHRcdFx0aWYgKGFsaWFzZXMuaW5kZXhPZihpKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdGluQWxpYXMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0aWYgKGFsaWFzZXNbMF0gaW4gbmV3U3VtbWFyeSkge1xyXG5cdFx0XHRcdFx0XHRuZXdTdW1tYXJ5W2FsaWFzZXNbMF1dICs9IHN1bW1hcnlbaV07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRuZXdTdW1tYXJ5W2FsaWFzZXNbMF1dID0gc3VtbWFyeVtpXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpbkFsaWFzID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdG5ld1N1bW1hcnlbaV0gPSBzdW1tYXJ5W2ldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld1N1bW1hcnk7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGxvYWRGaWxlOiBBbmFseXNlci5sb2FkRmlsZSxcclxuXHRjb21iaW5lRGF0YTogQW5hbHlzZXIuY29tYmluZURhdGEsXHJcblxyXG5cdGdldENvbE51bWJlcjogQW5hbHlzZXIuZ2V0Q29sTnVtYmVyLFxyXG5cdGdldENvbE51bWJlcnM6IEFuYWx5c2VyLmdldENvbE51bWJlcnMsXHJcblx0Z2V0Q29sOiBBbmFseXNlci5nZXRDb2xcclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./analyser.js\n");

/***/ }),

/***/ "./docs/assets/js/src/main.js":
/*!************************************!*\
  !*** ./docs/assets/js/src/main.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _analyser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! /analyser */ \"./analyser.js\");\n\r\n\r\nconst analyse = async function () {\r\n\tconst fileInfoA = {\r\n\t\tpath: '/assets/data/Prison Population - raw.csv',\r\n\t\theaderRows: 1,\r\n\t\tcols: _analyser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getColNumbers({\r\n\t\t\tDATE: 'A',\r\n\t\t\tREMAND_MALE: 'B',\r\n\t\t\tREMAND_FEMALE: 'C',\r\n\t\t\tREMAND_TOTAL: 'D',\r\n\t\t\tSENTENCED_MALE: 'E',\r\n\t\t\tSENTENCED_FEMALE: 'F',\r\n\t\t\tSENTENCED_TOTAL: 'G',\r\n\t\t\tTOTAL_MALE: 'H',\r\n\t\t\tTOTAL_MALE: 'I',\r\n\t\t\tTOTAL_TOTAL: 'J',\r\n\t\t\tETHNICITY_MAORI: 'K',\r\n\t\t\tETHNICITY_EUROPEAN: 'L',\r\n\t\t\tETHNICITY_PACIFIC: 'M',\r\n\t\t\tETHNICITY_ASIAN: 'N',\r\n\t\t\tETHNICITY_OTHER: 'O',\r\n\t\t\tETHNICITY_UNKNOWN: 'P',\r\n\t\t\tETHNICITY_TOTAL: 'A',\r\n\t\t\tPER_100_000_POPULATION: 'R',\r\n\t\t}),\r\n\t};\r\n\r\n\tconst fileInfoB = {\r\n\t\tpath: '/assets/data/Tactical Options 2014 - raw.csv',\r\n\t\theaderRows: 1,\r\n\t\tcols: _analyser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getColNumbers({\r\n\t\t\tTACTICAL_OPTION: 'A',\r\n\t\t\tEUROPEAN: 'B',\r\n\t\t\tMAORI: 'C',\r\n\t\t\tPACIFIC: 'D',\r\n\t\t\tOTHER: 'E',\r\n\t\t}),\r\n\t};\r\n\r\n\tlet dataConfigArr = await _analyser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].loadFile(fileInfoA, fileInfoB);\r\n\r\n\tfor (let dataConfig of dataConfigArr) {\r\n\t\tlet { rows, cols } = dataConfig;\r\n\r\n\t\tconsole.log(rows);\r\n\t\tconsole.log(rows.getCol(0));\r\n\t}\r\n\r\n\tlet { rows, cols } = dataConfigArr[0];\r\n\r\n\tlet newCol = rows.getCol(cols.REMAND_MALE).map((num) => num/10);\r\n\r\n\tlet newColIndex = rows.addCol(newCol);\r\n\tconsole.log(rows.getCol(newColIndex));\r\n\r\n\tlet derivedColIndex = rows.addDerivedCol((row, extraVal1) => {\r\n\t\treturn row[1] + row[2] - extraVal1;\r\n\t}, newCol);\r\n\tconsole.log(rows.getCol(derivedColIndex));\r\n\r\n\tconsole.table(rows.createSubTable(cols));\r\n\tconsole.log(rows.createSubTableString(cols));\r\n\r\n\trows = dataConfigArr[1].rows;\r\n\tcols = dataConfigArr[1].cols;\r\n\r\n\tconsole.log(rows.getColSummary(cols.TACTICAL_OPTION));\r\n\r\n\tlet dataSeries = rows.getColAsDataSeries(cols.TACTICAL_OPTION, Object.keys(rows.getColSummary(cols.TACTICAL_OPTION)));\r\n\tconsole.log(dataSeries);\r\n\r\n\tlet comparisonSummary = rows.getComparisonSummary(cols.TACTICAL_OPTION, cols.MAORI);\r\n\tconsole.log(comparisonSummary);\r\n\r\n\tlet comparisonSummaryString = rows.getComparisonSummaryString(cols.TACTICAL_OPTION, cols.MAORI);\r\n\tconsole.log(comparisonSummaryString);\r\n\r\n\trows.saveComparisonSummaryCsv('test', cols.TACTICAL_OPTION, cols.MAORI);\r\n};\r\n\r\nanalyse();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kb2NzL2Fzc2V0cy9qcy9zcmMvbWFpbi5qcz9kZDVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpREFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDJCQUEyQixpREFBUTs7QUFFbkM7QUFDQSxPQUFPLGFBQWE7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLGFBQWE7O0FBRW5COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL2RvY3MvYXNzZXRzL2pzL3NyYy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFuYWx5c2VyIGZyb20gJy9hbmFseXNlcic7XHJcblxyXG5jb25zdCBhbmFseXNlID0gYXN5bmMgZnVuY3Rpb24gKCkge1xyXG5cdGNvbnN0IGZpbGVJbmZvQSA9IHtcclxuXHRcdHBhdGg6ICcvYXNzZXRzL2RhdGEvUHJpc29uIFBvcHVsYXRpb24gLSByYXcuY3N2JyxcclxuXHRcdGhlYWRlclJvd3M6IDEsXHJcblx0XHRjb2xzOiBhbmFseXNlci5nZXRDb2xOdW1iZXJzKHtcclxuXHRcdFx0REFURTogJ0EnLFxyXG5cdFx0XHRSRU1BTkRfTUFMRTogJ0InLFxyXG5cdFx0XHRSRU1BTkRfRkVNQUxFOiAnQycsXHJcblx0XHRcdFJFTUFORF9UT1RBTDogJ0QnLFxyXG5cdFx0XHRTRU5URU5DRURfTUFMRTogJ0UnLFxyXG5cdFx0XHRTRU5URU5DRURfRkVNQUxFOiAnRicsXHJcblx0XHRcdFNFTlRFTkNFRF9UT1RBTDogJ0cnLFxyXG5cdFx0XHRUT1RBTF9NQUxFOiAnSCcsXHJcblx0XHRcdFRPVEFMX01BTEU6ICdJJyxcclxuXHRcdFx0VE9UQUxfVE9UQUw6ICdKJyxcclxuXHRcdFx0RVRITklDSVRZX01BT1JJOiAnSycsXHJcblx0XHRcdEVUSE5JQ0lUWV9FVVJPUEVBTjogJ0wnLFxyXG5cdFx0XHRFVEhOSUNJVFlfUEFDSUZJQzogJ00nLFxyXG5cdFx0XHRFVEhOSUNJVFlfQVNJQU46ICdOJyxcclxuXHRcdFx0RVRITklDSVRZX09USEVSOiAnTycsXHJcblx0XHRcdEVUSE5JQ0lUWV9VTktOT1dOOiAnUCcsXHJcblx0XHRcdEVUSE5JQ0lUWV9UT1RBTDogJ0EnLFxyXG5cdFx0XHRQRVJfMTAwXzAwMF9QT1BVTEFUSU9OOiAnUicsXHJcblx0XHR9KSxcclxuXHR9O1xyXG5cclxuXHRjb25zdCBmaWxlSW5mb0IgPSB7XHJcblx0XHRwYXRoOiAnL2Fzc2V0cy9kYXRhL1RhY3RpY2FsIE9wdGlvbnMgMjAxNCAtIHJhdy5jc3YnLFxyXG5cdFx0aGVhZGVyUm93czogMSxcclxuXHRcdGNvbHM6IGFuYWx5c2VyLmdldENvbE51bWJlcnMoe1xyXG5cdFx0XHRUQUNUSUNBTF9PUFRJT046ICdBJyxcclxuXHRcdFx0RVVST1BFQU46ICdCJyxcclxuXHRcdFx0TUFPUkk6ICdDJyxcclxuXHRcdFx0UEFDSUZJQzogJ0QnLFxyXG5cdFx0XHRPVEhFUjogJ0UnLFxyXG5cdFx0fSksXHJcblx0fTtcclxuXHJcblx0bGV0IGRhdGFDb25maWdBcnIgPSBhd2FpdCBhbmFseXNlci5sb2FkRmlsZShmaWxlSW5mb0EsIGZpbGVJbmZvQik7XHJcblxyXG5cdGZvciAobGV0IGRhdGFDb25maWcgb2YgZGF0YUNvbmZpZ0Fycikge1xyXG5cdFx0bGV0IHsgcm93cywgY29scyB9ID0gZGF0YUNvbmZpZztcclxuXHJcblx0XHRjb25zb2xlLmxvZyhyb3dzKTtcclxuXHRcdGNvbnNvbGUubG9nKHJvd3MuZ2V0Q29sKDApKTtcclxuXHR9XHJcblxyXG5cdGxldCB7IHJvd3MsIGNvbHMgfSA9IGRhdGFDb25maWdBcnJbMF07XHJcblxyXG5cdGxldCBuZXdDb2wgPSByb3dzLmdldENvbChjb2xzLlJFTUFORF9NQUxFKS5tYXAoKG51bSkgPT4gbnVtLzEwKTtcclxuXHJcblx0bGV0IG5ld0NvbEluZGV4ID0gcm93cy5hZGRDb2wobmV3Q29sKTtcclxuXHRjb25zb2xlLmxvZyhyb3dzLmdldENvbChuZXdDb2xJbmRleCkpO1xyXG5cclxuXHRsZXQgZGVyaXZlZENvbEluZGV4ID0gcm93cy5hZGREZXJpdmVkQ29sKChyb3csIGV4dHJhVmFsMSkgPT4ge1xyXG5cdFx0cmV0dXJuIHJvd1sxXSArIHJvd1syXSAtIGV4dHJhVmFsMTtcclxuXHR9LCBuZXdDb2wpO1xyXG5cdGNvbnNvbGUubG9nKHJvd3MuZ2V0Q29sKGRlcml2ZWRDb2xJbmRleCkpO1xyXG5cclxuXHRjb25zb2xlLnRhYmxlKHJvd3MuY3JlYXRlU3ViVGFibGUoY29scykpO1xyXG5cdGNvbnNvbGUubG9nKHJvd3MuY3JlYXRlU3ViVGFibGVTdHJpbmcoY29scykpO1xyXG5cclxuXHRyb3dzID0gZGF0YUNvbmZpZ0FyclsxXS5yb3dzO1xyXG5cdGNvbHMgPSBkYXRhQ29uZmlnQXJyWzFdLmNvbHM7XHJcblxyXG5cdGNvbnNvbGUubG9nKHJvd3MuZ2V0Q29sU3VtbWFyeShjb2xzLlRBQ1RJQ0FMX09QVElPTikpO1xyXG5cclxuXHRsZXQgZGF0YVNlcmllcyA9IHJvd3MuZ2V0Q29sQXNEYXRhU2VyaWVzKGNvbHMuVEFDVElDQUxfT1BUSU9OLCBPYmplY3Qua2V5cyhyb3dzLmdldENvbFN1bW1hcnkoY29scy5UQUNUSUNBTF9PUFRJT04pKSk7XHJcblx0Y29uc29sZS5sb2coZGF0YVNlcmllcyk7XHJcblxyXG5cdGxldCBjb21wYXJpc29uU3VtbWFyeSA9IHJvd3MuZ2V0Q29tcGFyaXNvblN1bW1hcnkoY29scy5UQUNUSUNBTF9PUFRJT04sIGNvbHMuTUFPUkkpO1xyXG5cdGNvbnNvbGUubG9nKGNvbXBhcmlzb25TdW1tYXJ5KTtcclxuXHJcblx0bGV0IGNvbXBhcmlzb25TdW1tYXJ5U3RyaW5nID0gcm93cy5nZXRDb21wYXJpc29uU3VtbWFyeVN0cmluZyhjb2xzLlRBQ1RJQ0FMX09QVElPTiwgY29scy5NQU9SSSk7XHJcblx0Y29uc29sZS5sb2coY29tcGFyaXNvblN1bW1hcnlTdHJpbmcpO1xyXG5cclxuXHRyb3dzLnNhdmVDb21wYXJpc29uU3VtbWFyeUNzdigndGVzdCcsIGNvbHMuVEFDVElDQUxfT1BUSU9OLCBjb2xzLk1BT1JJKTtcclxufTtcclxuXHJcbmFuYWx5c2UoKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./docs/assets/js/src/main.js\n");

/***/ }),

/***/ "./node_modules/csv/csv.js":
/*!*********************************!*\
  !*** ./node_modules/csv/csv.js ***!
  \*********************************/
/*! exports provided: stringify, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\nconst { stringify, parse } = (() => {\n\tconst csv = {\n\t\tstringify: function (data, options) {\n\t\t\toptions = options || {};\n\t\t\toptions.transpose = options.transpose || false;\n\t\t\toptions.sanitise = options.sanitise || false;\n\n\t\t\t// Enforce square data and apply CSV escaping, then convert to string\n\t\t\tlet rows = data;\n\n\t\t\trows = csv._shape(data, options);\n\t\t\trows = csv._escape(rows, options);\n\n\t\t\trows = csv._join(rows);\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_shape: function (data, options) {\n\t\t\t// Pad missing cells with empty strings and,\n\t\t\t// if necessary, transpose the data\n\n\t\t\tconst transpose = options.transpose;\n\n\t\t\tconst maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\n\n\t\t\t// Flip rows and columns if transposing data\n\t\t\tconst iMax = transpose ? maxLength : data.length;\n\t\t\tconst jMax = transpose ? data.length : maxLength;\n\n\t\t\tlet rows = [];\n\t\t\tfor (let i = 0; i < iMax; i++) {\n\t\t\t\tlet row = [];\n\t\t\t\tfor (let j = 0; j < jMax; j++) {\n\t\t\t\t\tlet iRow = transpose ? j : i;\n\t\t\t\t\tlet iCol = transpose ? i : j;\n\n\t\t\t\t\tlet cellValue = data[iRow][iCol];\n\n\t\t\t\t\tif (iCol >= data[iRow].length) {\n\t\t\t\t\t\tcellValue = '';\n\t\t\t\t\t}\n\n\t\t\t\t\trow.push(cellValue);\n\t\t\t\t}\n\t\t\t\trows.push(row);\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_escape: function (rows, options) {\n\t\t\t// Make sure any cells containing \" or , or a newline are escaped appropriately\n\n\t\t\tconst sanitise = options.sanitise;\n\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\tlet row = rows[i];\n\n\t\t\t\tfor (let j = 0; j < row.length; j++) {\n\t\t\t\t\tif (typeof row[j] === 'undefined') {\n\t\t\t\t\t\t// Replace undefined with ''\n\t\t\t\t\t\trow[j] = '';\n\t\t\t\t\t} else if (typeof row[j] !== 'string') {\n\t\t\t\t\t\t// Convert to string\n\t\t\t\t\t\trow[j] = '' + row[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sanitise) {\n\t\t\t\t\t\t// Prevent spreadsheet software like\n\t\t\t\t\t\t// Excel from trying to execute code\n\t\t\t\t\t\tif (row[j].match(/^[=\\-+@]/)) {\n\t\t\t\t\t\t\trow[j] = '\\t' + row[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (row[j].match(/,|\"|\\n/)) {\n\n\t\t\t\t\t\t// Turn any double quotes into escaped double quotes\n\t\t\t\t\t\trow[j] = row[j].replace(/\"/g, '\"\"');\n\n\t\t\t\t\t\t// Wrap cell in double quotes\n\t\t\t\t\t\trow[j] = '\"' + row[j] + '\"';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_join: function (rows) {\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\trows[i] = rows[i].join(',');\n\t\t\t}\n\t\t\trows = rows.join('\\n');\n\n\t\t\treturn rows;\n\t\t},\n\n\n\t\tparse: function (csvString) {\n\t\t\tlet rows = csv._tokenise(csvString);\n\n\t\t\tcsv._validate(rows);\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_tokenise: function (csvString) {\n\t\t\t// Walk through each character and produce an array of tokens\n\n\t\t\tlet tokens = [];\n\n\t\t\t// Remove carriage returns\n\t\t\tcsvString = csvString.replace(/\\r/g, '');\n\n\t\t\tlet inQuote = false;\n\t\t\tlet wasQuote = false;\n\n\t\t\tlet tokenStart = 0;\n\t\t\tlet row = [];\n\t\t\tfor (let i = 0; i < csvString.length; i++) {\n\t\t\t\tlet char = csvString[i];\n\n\t\t\t\tlet comma = char === ',';\n\t\t\t\tlet quote = char === '\"';\n\t\t\t\tlet newline = char === '\\n';\n\t\t\t\tlet eof = i === csvString.length -1; // eof - End Of File\n\n\t\t\t\tif (inQuote) {\n\t\t\t\t\t// Characters may be delimited\n\t\t\t\t\tif (quote) {\n\t\t\t\t\t\t// Check if the next character is another double quote, i.e. if it is escaped\n\t\t\t\t\t\tlet nextChar = csvString[i+1];\n\n\t\t\t\t\t\tif (nextChar === '\"') {\n\t\t\t\t\t\t\t// This and the next character combined make an escaped double quote,\n\t\t\t\t\t\t\t// so the quote has not ended and we should skip over the next character\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// The quote has ended\n\t\t\t\t\t\t\tinQuote = false;\n\t\t\t\t\t\t\twasQuote = true;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (eof) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Reached end of file before ending quote. At index ${i}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (comma || newline || eof) {\n\t\t\t\t\t\t// These are the characters that denote the end of a token\n\t\t\t\t\t\tlet token = csvString.substring(tokenStart, i+1);\n\n\t\t\t\t\t\tif (comma || newline) {\n\t\t\t\t\t\t\t// Don't keep the separator\n\t\t\t\t\t\t\ttoken = token.substring(0, token.length - 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (wasQuote) {\n\t\t\t\t\t\t\twasQuote = false;\n\n\t\t\t\t\t\t\t// Remove start and end quotes\n\t\t\t\t\t\t\ttoken = token.substring(1, token.length - 1);\n\n\t\t\t\t\t\t\t// Replace escaped quotes\n\t\t\t\t\t\t\ttoken = token.replace(/\"\"/g, '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t\trow.push(token);\n\n\t\t\t\t\t\tif (comma && eof) {\n\t\t\t\t\t\t\t// It's the end of the last token, and the last cell is empty\n\t\t\t\t\t\t\trow.push('');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newline || eof) {\n\t\t\t\t\t\t\ttokens.push(row);\n\t\t\t\t\t\t\tif (newline) {\n\t\t\t\t\t\t\t\trow = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttokenStart = i+1;\n\t\t\t\t} else if (wasQuote) {\n\t\t\t\t\tthrow new Error(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\n\t\t\t\t} else if (quote) {\n\t\t\t\t\tinQuote = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tokens;\n\t\t},\n\n\t\t_validate: function (rows) {\n\t\t\t// Each row of a CSV should have the same length;\n\n\t\t\tif (rows && rows.length > 1) {\n\t\t\t\tlet rowLength = rows[0].length;\n\t\t\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\t\t\tlet row = rows[i];\n\n\t\t\t\t\tif (row.length !== rowLength) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\treturn {\n\t\tstringify: csv.stringify,\n\t\tparse: csv.parse,\n\t};\n})();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3N2L2Nzdi5qcz8xMjM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBLE9BQU8sbUJBQW1CO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixzRkFBc0YsRUFBRTtBQUN4RjtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsd0dBQXdHLEVBQUU7QUFDMUcsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBLHdDQUF3QyxFQUFFLG1EQUFtRCxVQUFVO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUyQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jc3YvY3N2LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBzdHJpbmdpZnksIHBhcnNlIH0gPSAoKCkgPT4ge1xuXHRjb25zdCBjc3YgPSB7XG5cdFx0c3RyaW5naWZ5OiBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHRvcHRpb25zLnRyYW5zcG9zZSA9IG9wdGlvbnMudHJhbnNwb3NlIHx8IGZhbHNlO1xuXHRcdFx0b3B0aW9ucy5zYW5pdGlzZSA9IG9wdGlvbnMuc2FuaXRpc2UgfHwgZmFsc2U7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc3F1YXJlIGRhdGEgYW5kIGFwcGx5IENTViBlc2NhcGluZywgdGhlbiBjb252ZXJ0IHRvIHN0cmluZ1xuXHRcdFx0bGV0IHJvd3MgPSBkYXRhO1xuXG5cdFx0XHRyb3dzID0gY3N2Ll9zaGFwZShkYXRhLCBvcHRpb25zKTtcblx0XHRcdHJvd3MgPSBjc3YuX2VzY2FwZShyb3dzLCBvcHRpb25zKTtcblxuXHRcdFx0cm93cyA9IGNzdi5fam9pbihyb3dzKTtcblxuXHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0fSxcblxuXHRcdF9zaGFwZTogZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcblx0XHRcdC8vIFBhZCBtaXNzaW5nIGNlbGxzIHdpdGggZW1wdHkgc3RyaW5ncyBhbmQsXG5cdFx0XHQvLyBpZiBuZWNlc3NhcnksIHRyYW5zcG9zZSB0aGUgZGF0YVxuXG5cdFx0XHRjb25zdCB0cmFuc3Bvc2UgPSBvcHRpb25zLnRyYW5zcG9zZTtcblxuXHRcdFx0Y29uc3QgbWF4TGVuZ3RoID0gZGF0YS5yZWR1Y2UoKG1heExlbmd0aCwgcm93KSA9PiBNYXRoLm1heChtYXhMZW5ndGgsIHJvdy5sZW5ndGgpLCAwKTtcblxuXHRcdFx0Ly8gRmxpcCByb3dzIGFuZCBjb2x1bW5zIGlmIHRyYW5zcG9zaW5nIGRhdGFcblx0XHRcdGNvbnN0IGlNYXggPSB0cmFuc3Bvc2UgPyBtYXhMZW5ndGggOiBkYXRhLmxlbmd0aDtcblx0XHRcdGNvbnN0IGpNYXggPSB0cmFuc3Bvc2UgPyBkYXRhLmxlbmd0aCA6IG1heExlbmd0aDtcblxuXHRcdFx0bGV0IHJvd3MgPSBbXTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaU1heDsgaSsrKSB7XG5cdFx0XHRcdGxldCByb3cgPSBbXTtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBqTWF4OyBqKyspIHtcblx0XHRcdFx0XHRsZXQgaVJvdyA9IHRyYW5zcG9zZSA/IGogOiBpO1xuXHRcdFx0XHRcdGxldCBpQ29sID0gdHJhbnNwb3NlID8gaSA6IGo7XG5cblx0XHRcdFx0XHRsZXQgY2VsbFZhbHVlID0gZGF0YVtpUm93XVtpQ29sXTtcblxuXHRcdFx0XHRcdGlmIChpQ29sID49IGRhdGFbaVJvd10ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjZWxsVmFsdWUgPSAnJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyb3cucHVzaChjZWxsVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJvd3MucHVzaChyb3cpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcm93cztcblx0XHR9LFxuXG5cdFx0X2VzY2FwZTogZnVuY3Rpb24gKHJvd3MsIG9wdGlvbnMpIHtcblx0XHRcdC8vIE1ha2Ugc3VyZSBhbnkgY2VsbHMgY29udGFpbmluZyBcIiBvciAsIG9yIGEgbmV3bGluZSBhcmUgZXNjYXBlZCBhcHByb3ByaWF0ZWx5XG5cblx0XHRcdGNvbnN0IHNhbml0aXNlID0gb3B0aW9ucy5zYW5pdGlzZTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGxldCByb3cgPSByb3dzW2ldO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiByb3dbal0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHQvLyBSZXBsYWNlIHVuZGVmaW5lZCB3aXRoICcnXG5cdFx0XHRcdFx0XHRyb3dbal0gPSAnJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiByb3dbal0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHQvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXHRcdFx0XHRcdFx0cm93W2pdID0gJycgKyByb3dbal07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHNhbml0aXNlKSB7XG5cdFx0XHRcdFx0XHQvLyBQcmV2ZW50IHNwcmVhZHNoZWV0IHNvZnR3YXJlIGxpa2Vcblx0XHRcdFx0XHRcdC8vIEV4Y2VsIGZyb20gdHJ5aW5nIHRvIGV4ZWN1dGUgY29kZVxuXHRcdFx0XHRcdFx0aWYgKHJvd1tqXS5tYXRjaCgvXls9XFwtK0BdLykpIHtcblx0XHRcdFx0XHRcdFx0cm93W2pdID0gJ1xcdCcgKyByb3dbal07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHJvd1tqXS5tYXRjaCgvLHxcInxcXG4vKSkge1xuXG5cdFx0XHRcdFx0XHQvLyBUdXJuIGFueSBkb3VibGUgcXVvdGVzIGludG8gZXNjYXBlZCBkb3VibGUgcXVvdGVzXG5cdFx0XHRcdFx0XHRyb3dbal0gPSByb3dbal0ucmVwbGFjZSgvXCIvZywgJ1wiXCInKTtcblxuXHRcdFx0XHRcdFx0Ly8gV3JhcCBjZWxsIGluIGRvdWJsZSBxdW90ZXNcblx0XHRcdFx0XHRcdHJvd1tqXSA9ICdcIicgKyByb3dbal0gKyAnXCInO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcm93cztcblx0XHR9LFxuXG5cdFx0X2pvaW46IGZ1bmN0aW9uIChyb3dzKSB7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cm93c1tpXSA9IHJvd3NbaV0uam9pbignLCcpO1xuXHRcdFx0fVxuXHRcdFx0cm93cyA9IHJvd3Muam9pbignXFxuJyk7XG5cblx0XHRcdHJldHVybiByb3dzO1xuXHRcdH0sXG5cblxuXHRcdHBhcnNlOiBmdW5jdGlvbiAoY3N2U3RyaW5nKSB7XG5cdFx0XHRsZXQgcm93cyA9IGNzdi5fdG9rZW5pc2UoY3N2U3RyaW5nKTtcblxuXHRcdFx0Y3N2Ll92YWxpZGF0ZShyb3dzKTtcblxuXHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0fSxcblxuXHRcdF90b2tlbmlzZTogZnVuY3Rpb24gKGNzdlN0cmluZykge1xuXHRcdFx0Ly8gV2FsayB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIGFuZCBwcm9kdWNlIGFuIGFycmF5IG9mIHRva2Vuc1xuXG5cdFx0XHRsZXQgdG9rZW5zID0gW107XG5cblx0XHRcdC8vIFJlbW92ZSBjYXJyaWFnZSByZXR1cm5zXG5cdFx0XHRjc3ZTdHJpbmcgPSBjc3ZTdHJpbmcucmVwbGFjZSgvXFxyL2csICcnKTtcblxuXHRcdFx0bGV0IGluUXVvdGUgPSBmYWxzZTtcblx0XHRcdGxldCB3YXNRdW90ZSA9IGZhbHNlO1xuXG5cdFx0XHRsZXQgdG9rZW5TdGFydCA9IDA7XG5cdFx0XHRsZXQgcm93ID0gW107XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNzdlN0cmluZy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRsZXQgY2hhciA9IGNzdlN0cmluZ1tpXTtcblxuXHRcdFx0XHRsZXQgY29tbWEgPSBjaGFyID09PSAnLCc7XG5cdFx0XHRcdGxldCBxdW90ZSA9IGNoYXIgPT09ICdcIic7XG5cdFx0XHRcdGxldCBuZXdsaW5lID0gY2hhciA9PT0gJ1xcbic7XG5cdFx0XHRcdGxldCBlb2YgPSBpID09PSBjc3ZTdHJpbmcubGVuZ3RoIC0xOyAvLyBlb2YgLSBFbmQgT2YgRmlsZVxuXG5cdFx0XHRcdGlmIChpblF1b3RlKSB7XG5cdFx0XHRcdFx0Ly8gQ2hhcmFjdGVycyBtYXkgYmUgZGVsaW1pdGVkXG5cdFx0XHRcdFx0aWYgKHF1b3RlKSB7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYW5vdGhlciBkb3VibGUgcXVvdGUsIGkuZS4gaWYgaXQgaXMgZXNjYXBlZFxuXHRcdFx0XHRcdFx0bGV0IG5leHRDaGFyID0gY3N2U3RyaW5nW2krMV07XG5cblx0XHRcdFx0XHRcdGlmIChuZXh0Q2hhciA9PT0gJ1wiJykge1xuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGFuZCB0aGUgbmV4dCBjaGFyYWN0ZXIgY29tYmluZWQgbWFrZSBhbiBlc2NhcGVkIGRvdWJsZSBxdW90ZSxcblx0XHRcdFx0XHRcdFx0Ly8gc28gdGhlIHF1b3RlIGhhcyBub3QgZW5kZWQgYW5kIHdlIHNob3VsZCBza2lwIG92ZXIgdGhlIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBUaGUgcXVvdGUgaGFzIGVuZGVkXG5cdFx0XHRcdFx0XHRcdGluUXVvdGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0d2FzUXVvdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZW9mKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENTViBwYXJzZTogUmVhY2hlZCBlbmQgb2YgZmlsZSBiZWZvcmUgZW5kaW5nIHF1b3RlLiBBdCBpbmRleCAke2l9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNvbW1hIHx8IG5ld2xpbmUgfHwgZW9mKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGVzZSBhcmUgdGhlIGNoYXJhY3RlcnMgdGhhdCBkZW5vdGUgdGhlIGVuZCBvZiBhIHRva2VuXG5cdFx0XHRcdFx0XHRsZXQgdG9rZW4gPSBjc3ZTdHJpbmcuc3Vic3RyaW5nKHRva2VuU3RhcnQsIGkrMSk7XG5cblx0XHRcdFx0XHRcdGlmIChjb21tYSB8fCBuZXdsaW5lKSB7XG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIHNlcGFyYXRvclxuXHRcdFx0XHRcdFx0XHR0b2tlbiA9IHRva2VuLnN1YnN0cmluZygwLCB0b2tlbi5sZW5ndGggLSAxKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHdhc1F1b3RlKSB7XG5cdFx0XHRcdFx0XHRcdHdhc1F1b3RlID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIHN0YXJ0IGFuZCBlbmQgcXVvdGVzXG5cdFx0XHRcdFx0XHRcdHRva2VuID0gdG9rZW4uc3Vic3RyaW5nKDEsIHRva2VuLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlcGxhY2UgZXNjYXBlZCBxdW90ZXNcblx0XHRcdFx0XHRcdFx0dG9rZW4gPSB0b2tlbi5yZXBsYWNlKC9cIlwiL2csICdcIicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cm93LnB1c2godG9rZW4pO1xuXG5cdFx0XHRcdFx0XHRpZiAoY29tbWEgJiYgZW9mKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEl0J3MgdGhlIGVuZCBvZiB0aGUgbGFzdCB0b2tlbiwgYW5kIHRoZSBsYXN0IGNlbGwgaXMgZW1wdHlcblx0XHRcdFx0XHRcdFx0cm93LnB1c2goJycpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobmV3bGluZSB8fCBlb2YpIHtcblx0XHRcdFx0XHRcdFx0dG9rZW5zLnB1c2gocm93KTtcblx0XHRcdFx0XHRcdFx0aWYgKG5ld2xpbmUpIHtcblx0XHRcdFx0XHRcdFx0XHRyb3cgPSBbXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0b2tlblN0YXJ0ID0gaSsxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHdhc1F1b3RlKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDU1YgcGFyc2U6IEEgdmFsdWUgbXVzdCBiZSBjb21wbGV0ZSBpbW1lZGlhdGVseSBhZnRlciBjbG9zaW5nIGEgcXVvdGUuIEF0IGluZGV4ICR7aX1gKTtcblx0XHRcdFx0fSBlbHNlIGlmIChxdW90ZSkge1xuXHRcdFx0XHRcdGluUXVvdGUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0b2tlbnM7XG5cdFx0fSxcblxuXHRcdF92YWxpZGF0ZTogZnVuY3Rpb24gKHJvd3MpIHtcblx0XHRcdC8vIEVhY2ggcm93IG9mIGEgQ1NWIHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aDtcblxuXHRcdFx0aWYgKHJvd3MgJiYgcm93cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdGxldCByb3dMZW5ndGggPSByb3dzWzBdLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGV0IHJvdyA9IHJvd3NbaV07XG5cblx0XHRcdFx0XHRpZiAocm93Lmxlbmd0aCAhPT0gcm93TGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENTViBwYXJzZTogUm93ICR7aX0gZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIGZpcnN0IHJvdyAoJHtyb3dMZW5ndGh9KWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdHN0cmluZ2lmeTogY3N2LnN0cmluZ2lmeSxcblx0XHRwYXJzZTogY3N2LnBhcnNlLFxuXHR9O1xufSkoKTtcblxuZXhwb3J0IHsgc3RyaW5naWZ5LCBwYXJzZSB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/csv/csv.js\n");

/***/ }),

/***/ "./node_modules/fileio/fileio.js":
/*!***************************************!*\
  !*** ./node_modules/fileio/fileio.js ***!
  \***************************************/
/*! exports provided: save, load, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"save\", function() { return save; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return load; });\n/* harmony import */ var csv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csv */ \"./node_modules/csv/csv.js\");\n\n\nlet $link;\n\nconst fileIO = {\n\tload: (options) => {\n\t\toptions = options || {};\n\t\toptions.readMethod = options.readMethod || 'text';\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst fileLoaded = (e) => {\n\t\t\t\tlet reader = e.target;\n\n\t\t\t\tif (reader.readyState === 2) {\n\t\t\t\t\t// DONE\n\t\t\t\t\tresolve(reader.result);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst readFile = (file) => {\n\t\t\t\tlet reader = new FileReader();\n\n\t\t\t\treader.addEventListener('load', fileLoaded);\n\t\t\t\treader.addEventListener('error', () => {\n\t\t\t\t\treader.abort();\n\t\t\t\t\treject(new DOMException('Error parsing file'));\n\t\t\t\t});\n\n\t\t\t\tswitch (options.readMethod) {\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\t\treader.readAsArrayBuffer(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'binaryString':\n\t\t\t\t\t\treader.readAsBinaryString(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dataUrl':\n\t\t\t\t\t\treader.readAsDataURL(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'text':\n\t\t\t\t\t\treader.readAsText(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RangeError(`FileIO: Unrecognised readMethod ${options.readMethod}`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst loadSelectedFile = (file) => {\n\t\t\t\tif (options.readMethod === 'file') {\n\t\t\t\t\tresolve(file);\n\t\t\t\t} else {\n\t\t\t\t\treadFile(file);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst loadSelectedFileEvent = (e) => {\n\t\t\t\tlet $fileInput = e.target;\n\t\t\t\tlet file = $fileInput.files[0];\n\n\t\t\t\tif (file) {\n\t\t\t\t\tloadSelectedFile(file);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst $fileInput = document.createElement('input');\n\t\t\t$fileInput.type = 'file';\n\t\t\t$fileInput.addEventListener('change', loadSelectedFileEvent);\n\n\t\t\t$fileInput.click();\n\t\t});\n\t},\n\n\tsave: (data, options) => {\n\t\toptions = options || {};\n\n\t\tif (data instanceof File) {\n\t\t\tfileIO._saveFile(data, options);\n\t\t} else if (data instanceof Blob) {\n\t\t\tfileIO._saveBlob(data, options);\n\t\t} else {\n\t\t\tfileIO._saveData(data, options);\n\t\t}\n\t},\n\n\t_saveBlob: (blob, options) => {\n\t\tif (!(blob instanceof Blob)) {\n\t\t\tthrow new TypeError('FileIO: save blob requires a Blob');\n\t\t}\n\n\t\toptions.filename = options.filename || 'file';\n\n\t\tif (navigator.msSaveBlob) {\n\t\t\tnavigator.msSaveBlob(blob, filename);\n\t\t} else {\n\t\t\tlet url = URL.createObjectURL(blob);\n\t\t\tfileIO._downloadDataUrl(url, options.filename);\n\t\t}\n\t},\n\n\t_saveFile: (file, options) => {\n\t\tif (!(file instanceof File)) {\n\t\t\tthrow new TypeError('FileIO: save file requires a File');\n\t\t}\n\n\t\toptions.filename = options.filename || file.name || 'file';\n\n\t\tif (navigator.msSaveBlob) {\n\t\t\tnavigator.msSaveBlob(file, options.filename);\n\t\t} else {\n\t\t\tlet reader = new FileReader();\n\n\t\t\treader.readAsDataURL(file);\n\t\t\treader.addEventListener('load', function () {\n\t\t\t\tfileIO._downloadDataUrl(this.result, options.filename);\n\t\t\t});\n\t\t}\n\t},\n\n\t_saveData: function (data, options) {\n\t\toptions.filename = options.filename || 'file';\n\t\toptions.type = options.type || 'text/plain'\n\n\t\t// CSV only\n\t\toptions.transpose = options.transpose || false;\n\t\toptions.sanitise = options.sanitise || false;\n\n\t\t// Type shorthands\n\t\tswitch (options.type) {\n\t\t\tcase 'json':\n\t\t\t\toptions.type = 'application/json';\n\t\t\t\tbreak;\n\t\t\tcase 'csv':\n\t\t\t\toptions.type = 'text/csv';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (options.type === 'application/json') {\n\t\t\ttry {\n\t\t\t\tdata = JSON.stringify(data);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error('FileIO: Failed to save JSON');\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\n\t\t\toptions.filename = fileIO._extendFilename(options.filename, 'json');\n\t\t} else if (options.type === 'text/csv') {\n\t\t\tif (!(typeof data === 'string' || data instanceof String)) {\n\t\t\t\tdata = csv__WEBPACK_IMPORTED_MODULE_0__[\"stringify\"](data, options);\n\t\t\t}\n\t\t\toptions.filename = fileIO._extendFilename(options.filename, 'csv');\n\t\t}\n\n\t\t// Construct a Blob and download it\n\t\tlet blob = new Blob(\n\t\t\t[data],\n\t\t\t{ type: options.type }\n\t\t);\n\n\t\tfileIO._saveBlob(blob, options);\n\t},\n\n\t_downloadDataUrl: function (dataUrl, filename) {\n\t\t$link = $link || document.createElement('a');\n\t\t$link.href = dataUrl;\n\t\t$link.download = filename;\n\t\t$link.click();\n\n\t\tURL.revokeObjectURL(dataUrl);\n\t},\n\n\t_downloadDataUrl: function (dataUrl, filename) {\n\t\t$link = $link || document.createElement('a');\n\t\t$link.href = dataUrl;\n\t\t$link.download = filename;\n\t\t$link.click();\n\n\t\tURL.revokeObjectURL(dataUrl);\n\t},\n\n\t_extendFilename: function (filename, extension) {\n\t\tlet testPattern = new RegExp('\\\\.' + extension + '$');\n\n\t\tif (!testPattern.test(filename)) {\n\t\t\tfilename += '.' + extension;\n\t\t}\n\n\t\treturn filename;\n\t},\n};\n\nconst save = fileIO.save;\nconst load = fileIO.load;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (fileIO);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlsZWlvL2ZpbGVpby5qcz80OGIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsNkNBQWE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRU87QUFDQTs7QUFFUSxxRUFBTSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGVpby9maWxlaW8uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjc3YgZnJvbSAnY3N2JztcblxubGV0ICRsaW5rO1xuXG5jb25zdCBmaWxlSU8gPSB7XG5cdGxvYWQ6IChvcHRpb25zKSA9PiB7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0b3B0aW9ucy5yZWFkTWV0aG9kID0gb3B0aW9ucy5yZWFkTWV0aG9kIHx8ICd0ZXh0JztcblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRjb25zdCBmaWxlTG9hZGVkID0gKGUpID0+IHtcblx0XHRcdFx0bGV0IHJlYWRlciA9IGUudGFyZ2V0O1xuXG5cdFx0XHRcdGlmIChyZWFkZXIucmVhZHlTdGF0ZSA9PT0gMikge1xuXHRcdFx0XHRcdC8vIERPTkVcblx0XHRcdFx0XHRyZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCByZWFkRmlsZSA9IChmaWxlKSA9PiB7XG5cdFx0XHRcdGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG5cdFx0XHRcdHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZmlsZUxvYWRlZCk7XG5cdFx0XHRcdHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcblx0XHRcdFx0XHRyZWFkZXIuYWJvcnQoKTtcblx0XHRcdFx0XHRyZWplY3QobmV3IERPTUV4Y2VwdGlvbignRXJyb3IgcGFyc2luZyBmaWxlJykpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRzd2l0Y2ggKG9wdGlvbnMucmVhZE1ldGhvZCkge1xuXHRcdFx0XHRcdGNhc2UgJ2FycmF5QnVmZmVyJzpcblx0XHRcdFx0XHRcdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2JpbmFyeVN0cmluZyc6XG5cdFx0XHRcdFx0XHRyZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nKGZpbGUpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZGF0YVVybCc6XG5cdFx0XHRcdFx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RleHQnOlxuXHRcdFx0XHRcdFx0cmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoYEZpbGVJTzogVW5yZWNvZ25pc2VkIHJlYWRNZXRob2QgJHtvcHRpb25zLnJlYWRNZXRob2R9YCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgbG9hZFNlbGVjdGVkRmlsZSA9IChmaWxlKSA9PiB7XG5cdFx0XHRcdGlmIChvcHRpb25zLnJlYWRNZXRob2QgPT09ICdmaWxlJykge1xuXHRcdFx0XHRcdHJlc29sdmUoZmlsZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVhZEZpbGUoZmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGxvYWRTZWxlY3RlZEZpbGVFdmVudCA9IChlKSA9PiB7XG5cdFx0XHRcdGxldCAkZmlsZUlucHV0ID0gZS50YXJnZXQ7XG5cdFx0XHRcdGxldCBmaWxlID0gJGZpbGVJbnB1dC5maWxlc1swXTtcblxuXHRcdFx0XHRpZiAoZmlsZSkge1xuXHRcdFx0XHRcdGxvYWRTZWxlY3RlZEZpbGUoZmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdGNvbnN0ICRmaWxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHRcdFx0JGZpbGVJbnB1dC50eXBlID0gJ2ZpbGUnO1xuXHRcdFx0JGZpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBsb2FkU2VsZWN0ZWRGaWxlRXZlbnQpO1xuXG5cdFx0XHQkZmlsZUlucHV0LmNsaWNrKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0c2F2ZTogKGRhdGEsIG9wdGlvbnMpID0+IHtcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdGlmIChkYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuXHRcdFx0ZmlsZUlPLl9zYXZlRmlsZShkYXRhLCBvcHRpb25zKTtcblx0XHR9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRmaWxlSU8uX3NhdmVCbG9iKGRhdGEsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmaWxlSU8uX3NhdmVEYXRhKGRhdGEsIG9wdGlvbnMpO1xuXHRcdH1cblx0fSxcblxuXHRfc2F2ZUJsb2I6IChibG9iLCBvcHRpb25zKSA9PiB7XG5cdFx0aWYgKCEoYmxvYiBpbnN0YW5jZW9mIEJsb2IpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdGaWxlSU86IHNhdmUgYmxvYiByZXF1aXJlcyBhIEJsb2InKTtcblx0XHR9XG5cblx0XHRvcHRpb25zLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZSB8fCAnZmlsZSc7XG5cblx0XHRpZiAobmF2aWdhdG9yLm1zU2F2ZUJsb2IpIHtcblx0XHRcdG5hdmlnYXRvci5tc1NhdmVCbG9iKGJsb2IsIGZpbGVuYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cdFx0XHRmaWxlSU8uX2Rvd25sb2FkRGF0YVVybCh1cmwsIG9wdGlvbnMuZmlsZW5hbWUpO1xuXHRcdH1cblx0fSxcblxuXHRfc2F2ZUZpbGU6IChmaWxlLCBvcHRpb25zKSA9PiB7XG5cdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdGaWxlSU86IHNhdmUgZmlsZSByZXF1aXJlcyBhIEZpbGUnKTtcblx0XHR9XG5cblx0XHRvcHRpb25zLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZSB8fCBmaWxlLm5hbWUgfHwgJ2ZpbGUnO1xuXG5cdFx0aWYgKG5hdmlnYXRvci5tc1NhdmVCbG9iKSB7XG5cdFx0XHRuYXZpZ2F0b3IubXNTYXZlQmxvYihmaWxlLCBvcHRpb25zLmZpbGVuYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cblx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXHRcdFx0cmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZpbGVJTy5fZG93bmxvYWREYXRhVXJsKHRoaXMucmVzdWx0LCBvcHRpb25zLmZpbGVuYW1lKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfc2F2ZURhdGE6IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucy5maWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWUgfHwgJ2ZpbGUnO1xuXHRcdG9wdGlvbnMudHlwZSA9IG9wdGlvbnMudHlwZSB8fCAndGV4dC9wbGFpbidcblxuXHRcdC8vIENTViBvbmx5XG5cdFx0b3B0aW9ucy50cmFuc3Bvc2UgPSBvcHRpb25zLnRyYW5zcG9zZSB8fCBmYWxzZTtcblx0XHRvcHRpb25zLnNhbml0aXNlID0gb3B0aW9ucy5zYW5pdGlzZSB8fCBmYWxzZTtcblxuXHRcdC8vIFR5cGUgc2hvcnRoYW5kc1xuXHRcdHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG5cdFx0XHRjYXNlICdqc29uJzpcblx0XHRcdFx0b3B0aW9ucy50eXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2Nzdic6XG5cdFx0XHRcdG9wdGlvbnMudHlwZSA9ICd0ZXh0L2Nzdic7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdGaWxlSU86IEZhaWxlZCB0byBzYXZlIEpTT04nKTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlKTtcblx0XHRcdH1cblxuXHRcdFx0b3B0aW9ucy5maWxlbmFtZSA9IGZpbGVJTy5fZXh0ZW5kRmlsZW5hbWUob3B0aW9ucy5maWxlbmFtZSwgJ2pzb24nKTtcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3RleHQvY3N2Jykge1xuXHRcdFx0aWYgKCEodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGRhdGEgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG5cdFx0XHRcdGRhdGEgPSBjc3Yuc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucy5maWxlbmFtZSA9IGZpbGVJTy5fZXh0ZW5kRmlsZW5hbWUob3B0aW9ucy5maWxlbmFtZSwgJ2NzdicpO1xuXHRcdH1cblxuXHRcdC8vIENvbnN0cnVjdCBhIEJsb2IgYW5kIGRvd25sb2FkIGl0XG5cdFx0bGV0IGJsb2IgPSBuZXcgQmxvYihcblx0XHRcdFtkYXRhXSxcblx0XHRcdHsgdHlwZTogb3B0aW9ucy50eXBlIH1cblx0XHQpO1xuXG5cdFx0ZmlsZUlPLl9zYXZlQmxvYihibG9iLCBvcHRpb25zKTtcblx0fSxcblxuXHRfZG93bmxvYWREYXRhVXJsOiBmdW5jdGlvbiAoZGF0YVVybCwgZmlsZW5hbWUpIHtcblx0XHQkbGluayA9ICRsaW5rIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0XHQkbGluay5ocmVmID0gZGF0YVVybDtcblx0XHQkbGluay5kb3dubG9hZCA9IGZpbGVuYW1lO1xuXHRcdCRsaW5rLmNsaWNrKCk7XG5cblx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKGRhdGFVcmwpO1xuXHR9LFxuXG5cdF9kb3dubG9hZERhdGFVcmw6IGZ1bmN0aW9uIChkYXRhVXJsLCBmaWxlbmFtZSkge1xuXHRcdCRsaW5rID0gJGxpbmsgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdCRsaW5rLmhyZWYgPSBkYXRhVXJsO1xuXHRcdCRsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG5cdFx0JGxpbmsuY2xpY2soKTtcblxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwoZGF0YVVybCk7XG5cdH0sXG5cblx0X2V4dGVuZEZpbGVuYW1lOiBmdW5jdGlvbiAoZmlsZW5hbWUsIGV4dGVuc2lvbikge1xuXHRcdGxldCB0ZXN0UGF0dGVybiA9IG5ldyBSZWdFeHAoJ1xcXFwuJyArIGV4dGVuc2lvbiArICckJyk7XG5cblx0XHRpZiAoIXRlc3RQYXR0ZXJuLnRlc3QoZmlsZW5hbWUpKSB7XG5cdFx0XHRmaWxlbmFtZSArPSAnLicgKyBleHRlbnNpb247XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpbGVuYW1lO1xuXHR9LFxufTtcblxuZXhwb3J0IGNvbnN0IHNhdmUgPSBmaWxlSU8uc2F2ZTtcbmV4cG9ydCBjb25zdCBsb2FkID0gZmlsZUlPLmxvYWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGZpbGVJTztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fileio/fileio.js\n");

/***/ })

/******/ });