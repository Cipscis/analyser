/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./docs/assets/js/src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./analyser.js":
/*!*********************!*\
  !*** ./analyser.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var csv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csv */ \"./node_modules/csv/csv.js\");\n/* harmony import */ var fileio__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fileio */ \"./node_modules/fileio/fileio.js\");\n\r\n\r\n\r\nclass AnalyserRows extends Array {\r\n\tconstructor(sourceArray) {\r\n\t\t// Don't use spread operator as it will cause a\r\n\t\t// stack overflow error with very large arrays\r\n\t\t// super(...sourceArray);\r\n\t\tsuper(sourceArray.length);\r\n\t\tfor (let i = 0; i < sourceArray.length; i++) {\r\n\t\t\tthis[i] = sourceArray[i];\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//////////////////////\r\n\t// HELPER FUNCTIONS //\r\n\t//////////////////////\r\n\tgetCol(colNum) {\r\n\t\tlet col = this.map((row) => row[colNum]);\r\n\t\treturn col;\r\n\t}\r\n\r\n\r\n\t//////////////////////////////\r\n\t// TRANSFORMING INFORMATION //\r\n\t//////////////////////////////\r\n\taddCol(col) {\r\n\t\t// Edits the passed rows array to add an extra column\r\n\t\t// to it, then returns the index of that new column\r\n\r\n\t\tif (this.length !== col.length) {\r\n\t\t\tthrow new Error(`Cannot add col of length ${col.length} to rows of length ${this.length}`);\r\n\t\t}\r\n\r\n\t\tlet colIndex = this[0].length;\r\n\r\n\t\tfor (let [i, row] of this.entries()) {\r\n\t\t\trow.push(col[i]);\r\n\t\t}\r\n\r\n\t\treturn colIndex;\r\n\t}\r\n\r\n\tgetDerivedCol(processFn, ...cols) {\r\n\t\t// Creates an array analogous to a column as returns\r\n\t\t// by the getCol function, where its output is the\r\n\t\t// result of applying the processFn function to the row\r\n\t\t// any number of values from optional column arguments\r\n\r\n\t\tlet derivedCol = this.map((row, i) => {\r\n\t\t\tlet derivedValues = [row];\r\n\r\n\t\t\tfor (let col of cols) {\r\n\t\t\t\tderivedValues.push(col[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn processFn.apply(this, derivedValues);\r\n\t\t});\r\n\r\n\t\treturn derivedCol;\r\n\t}\r\n\r\n\taddDerivedCol(callback, ...cols) {\r\n\t\t// Works like getDerivedCol, but instead of returning\r\n\t\t// the derived column directly it uses addCol to add\r\n\t\t// it to rows and returns the new column index.\r\n\r\n\t\tlet derivedCol = this.getDerivedCol.apply(this, arguments);\r\n\r\n\t\treturn this.addCol(derivedCol);\r\n\t}\r\n\r\n\r\n\t///////////////////\r\n\t// SUMMARY TOOLS //\r\n\t///////////////////\r\n\tcreateSubTable(cols, arraySeparator) {\r\n\t\t// Takes in a set of rows and a cols object formatted like this:\r\n\t\t// {\r\n\t\t// \tETHNICITY: 3,\r\n\t\t// \tAGE: 6\r\n\t\t// }\r\n\r\n\t\t// Outputs an array of objects,\r\n\t\t// each of which has the same indices as cols and represents a row\r\n\t\t// The output can be used with console.table\r\n\r\n\t\tarraySeparator = arraySeparator || ', ';\r\n\r\n\t\tlet table = this.map((row) => {\r\n\t\t\tlet newRow = {};\r\n\r\n\t\t\tfor (let colName in cols) {\r\n\t\t\t\tlet col = cols[colName];\r\n\t\t\t\tlet cell = row[col]\r\n\t\t\t\t// Join arrays so they display in console.table\r\n\t\t\t\tif (cell instanceof Array) {\r\n\t\t\t\t\tnewRow[colName] = cell.join(arraySeparator);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tnewRow[colName] = cell;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn newRow;\r\n\t\t});\r\n\r\n\t\treturn table;\r\n\t}\r\n\r\n\tcreateSubTableString(cols) {\r\n\t\tlet table = this.createSubTable(cols, ',');\r\n\t\tlet tableString = Analyser._convertTableToString(table);\r\n\r\n\t\treturn tableString;\r\n\t}\r\n\r\n\tgetColSummary(cols, aliasList) {\r\n\t\t// Takes in a set of rows and one or more column numbers, and optionally\r\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\r\n\r\n\t\t// Outputs an object summarising the number of times each value\r\n\t\t// appeared in the given column of the given rows\r\n\r\n\r\n\t\t// Allow the passing of a single number or an array of column indices\r\n\t\tif (!(cols instanceof Array)) {\r\n\t\t\tcols = [cols];\r\n\t\t}\r\n\r\n\t\tlet summary = {};\r\n\t\tfor (let row of this) {\r\n\t\t\tfor (let col of cols) {\r\n\t\t\t\tlet cellValue = row[col];\r\n\r\n\t\t\t\tif (typeof cellValue !== 'undefined' && cellValue !== '') {\r\n\r\n\t\t\t\t\tlet values;\r\n\t\t\t\t\tif (cellValue instanceof Array) {\r\n\t\t\t\t\t\tvalues = cellValue;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalues = [cellValue];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (let value of values) {\r\n\t\t\t\t\t\tif (value in summary) {\r\n\t\t\t\t\t\t\tsummary[value]++;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tsummary[value] = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (typeof aliasList !== 'undefined') {\r\n\t\t\tsummary = Analyser._groupColSummaryByAliases(summary, aliasList);\r\n\t\t}\r\n\r\n\t\treturn summary;\r\n\t}\r\n\r\n\tgetColAsDataSeries(col, labels) {\r\n\t\t// Takes in a set of rows and a column number,\r\n\t\t// and an array of labels. Outputs an array where\r\n\t\t// each element is the count of the values matching\r\n\t\t// the element of labels at the same index\r\n\r\n\t\tlet colSummary = this.getColSummary(col);\r\n\r\n\t\tlet dataSeries = [];\r\n\r\n\t\tfor (let i = 0; i < labels.length; i++) {\r\n\t\t\tdataSeries[i] = 0;\r\n\t\t}\r\n\r\n\t\tfor (let i in colSummary) {\r\n\t\t\tlet value = colSummary[i];\r\n\t\t\tlet index = labels.indexOf(i);\r\n\t\t\tif (index === -1) {\r\n\t\t\t\t// Couldn't find index, try forcing it to be a number\r\n\t\t\t\tindex = labels.indexOf(parseInt(i, 10));\r\n\t\t\t}\r\n\r\n\t\t\tif (index !== -1) {\r\n\t\t\t\tdataSeries[index] = value;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn dataSeries;\r\n\t}\r\n\r\n\tgetComparisonSummary(headerCol, headerAliases, varCol, varAliases) {\r\n\t\t// Takes in a set of rows and two column numbers\r\n\t\t// Creates an object that can be used with console.table\r\n\t\t// with the values of headerCol used in the header, and\r\n\t\t// the values of varCol used for each row, with the cells\r\n\t\t// denoting the number of times these values coincided\r\n\t\t// using filterRows with the passed sets of aliases\r\n\r\n\t\t// Also optionally takes a set of aliases for one or both columns\r\n\r\n\t\tif (arguments.length === 2) {\r\n\t\t\t// No aliases specified\r\n\t\t\tvarCol = headerAliases;\r\n\t\t\theaderAliases = undefined;\r\n\t\t} else if (arguments.length === 3) {\r\n\t\t\t// One alias specified\r\n\t\t\tif (!(headerAliases instanceof Array)) {\r\n\t\t\t\t// headerAliases was not passed\r\n\t\t\t\tvarAliases = varCol;\r\n\t\t\t\tvarCol = headerAliases;\r\n\t\t\t\theaderAliases = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconsole.log(this);\r\n\t\tconsole.trace();\r\n\t\tlet headerSummary = this.getColSummary(headerCol, headerAliases);\r\n\t\tlet varSummary = this.getColSummary(varCol, varAliases);\r\n\r\n\t\tlet aliases = {};\r\n\t\tif (headerAliases) {\r\n\t\t\taliases.HEADERS = headerAliases;\r\n\t\t}\r\n\t\tif (varAliases) {\r\n\t\t\taliases.VARS = varAliases;\r\n\t\t}\r\n\t\tlet filters = Analyser._getAliasFilters(aliases);\r\n\r\n\t\tlet comparisonSummary = {};\r\n\t\tfor (let i in varSummary) {\r\n\t\t\tcomparisonSummary[i] = {};\r\n\t\t\tfor (let j in headerSummary) {\r\n\t\t\t\tcomparisonSummary[i][j] = filters.filterRows(this,\r\n\t\t\t\t\tvarCol, Analyser._extractValue(i),\r\n\t\t\t\t\theaderCol, Analyser._extractValue(j)\r\n\t\t\t\t).length;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn comparisonSummary;\r\n\t}\r\n\r\n\tgetComparisonSummaryString(headerCol, headerAliases, varCol, varAliases) {\r\n\t\t// Calls getComparisonSummary with all arguments passed,\r\n\t\t// then returns a string of the data that can be copy/pasted\r\n\t\t// into a spreadsheet\r\n\r\n\t\tlet comparisonSummary = this.getComparisonSummary.apply(this, arguments);\r\n\t\tlet comparisonSummaryString = Analyser._convertTableToString(comparisonSummary, true);\r\n\r\n\t\treturn comparisonSummaryString;\r\n\t}\r\n\r\n\tsaveComparisonSummaryCsv(filename, headerCol, headerAliases, varCol, varAliases) {\r\n\t\t// Calls getComparisonSummary with all arguments passed,\r\n\t\t// then returns a string of the data that can be copy/pasted\r\n\t\t// into a spreadsheet\r\n\t\tlet args = Array.prototype.slice.call(arguments, 1);\r\n\r\n\t\tlet comparisonSummary = this.getComparisonSummary.apply(this, args);\r\n\t\tlet comparisonSummaryCsv = Analyser._convertTableToString(comparisonSummary, true, ',', '\\n');\r\n\r\n\t\tlet options = {\r\n\t\t\tfilename,\r\n\t\t\ttype: 'text/csv',\r\n\t\t};\r\n\r\n\t\tfileio__WEBPACK_IMPORTED_MODULE_1__[\"default\"].save(comparisonSummaryCsv, options);\r\n\t}\r\n}\r\n\r\nconst Analyser = {\r\n\t/////////////////////\r\n\t// FILE PROCESSING //\r\n\t/////////////////////\r\n\t_loadFile: async function (fileConfig) {\r\n\t\tlet response = await fetch(fileConfig.path);\r\n\r\n\t\tif (response.ok) {\r\n\t\t\tlet data = await response.text();\r\n\r\n\t\t\tlet rows = Analyser._parseCsv(data);\r\n\t\t\tlet dataConfig = Analyser._processData(rows, fileConfig);\r\n\t\t\treturn dataConfig;\r\n\t\t} else {\r\n\t\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\r\n\t\t}\r\n\t},\r\n\r\n\tloadFile: function (...fileConfigArr) {\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\t// Load each file, then resolve the wrapping promise once all are loaded\r\n\t\t\tlet promises = fileConfigArr.map((fileConfig) => Analyser._loadFile(fileConfig))\r\n\t\t\tPromise.all(promises).then(resolve);\r\n\t\t});\r\n\t},\r\n\r\n\t_processData: function (rows, fileConfig) {\r\n\t\t// Takes in fileConfig with the following properties:\r\n\t\t// The number of header rows to remove from rows\r\n\t\t// A fileConfig object for column names\r\n\t\t// An optional set of aliases\r\n\t\t// An optional set of columns whose values should be treated as arrays\r\n\t\t// An optional set of columns with default values\r\n\t\t// An optional map of columns that should be combined when collecting enums\r\n\r\n\t\t// The output contains the following properties:\r\n\t\t// The header rows that were removed\r\n\t\t// The fileConfig object for column names\r\n\t\t// A set of filters respecting the given aliases\r\n\t\t// Enums collected according to the specified column names and optional enumsMap\r\n\r\n\t\t// Example data:\r\n\t\t// headerRows = 2;\r\n\t\t// footerRows = 1;\r\n\r\n\t\t// cols = Analyser.getColNumbers({\r\n\t\t// \tETHNICITY: 'K',\r\n\t\t// \tTACTICS: 'M'\r\n\t\t// });\r\n\r\n\t\t// arrayCols = {};\r\n\t\t// arrayCols[cols.TACTICS] = ' ';\r\n\r\n\t\t// defaultCols = {};\r\n\t\t// defaultCols[cols.VALUE] = 0;\r\n\r\n\t\t// defaultColValues = {};\r\n\t\t// defaultColValues[cols.VALUE] = '-';\r\n\r\n\t\t// aliases = {\r\n\t\t// \tETHNICITY: [\r\n\t\t// \t\t[\r\n\t\t// \t\t\t'Pacific', //Not represented in data, but used as a label\r\n\t\t// \t\t\t'Pacific Island',\r\n\t\t// \t\t\t'Pacific Islander'\r\n\t\t// \t\t]\r\n\t\t// \t]\r\n\t\t// };\r\n\r\n\t\t// enumsMap = {\r\n\t\t// \tTASER_METHOD: [cols.TASER_METHOD_1, cols.TASER_METHOD_2, cols.TASER_METHOD_3]\r\n\t\t// };\r\n\r\n\t\tfileConfig.headerRows = fileConfig.headerRows || 0;\r\n\t\tfileConfig.footerRows = fileConfig.footerRows || 0;\r\n\t\tfileConfig.cols = fileConfig.cols || {};\r\n\t\tfileConfig.aliases = fileConfig.aliases || {};\r\n\t\tfileConfig.arrayCols = fileConfig.arrayCols || {};\r\n\t\tfileConfig.enumsMap = fileConfig.enumsMap || {};\r\n\t\tfileConfig.uniqueCols = fileConfig.uniqueCols || [];\r\n\r\n\t\tlet dataConfig = {};\r\n\t\tdataConfig.cols = fileConfig.cols;\r\n\t\tdataConfig.aliases = fileConfig.aliases;\r\n\t\tdataConfig.filters = Analyser._getAliasFilters(fileConfig.aliases);\r\n\t\tdataConfig.enumsMap = fileConfig.enumsMap; // Keep this for combining data\r\n\r\n\t\tif (fileConfig.headerRows !== 0) {\r\n\t\t\t// Remove header rows\r\n\t\t\trows.splice(0, fileConfig.headerRows);\r\n\t\t}\r\n\r\n\t\tif (fileConfig.footerRows !== 0) {\r\n\t\t\t// Remove footer rows\r\n\t\t\trows.splice(-fileConfig.footerRows);\r\n\t\t}\r\n\r\n\t\t// Convert cells that are lists into arrays\r\n\t\tdataConfig.rows = new AnalyserRows(rows);\r\n\t\tfor (let i = 0; i < dataConfig.rows.length; i++) {\r\n\t\t\tlet row = dataConfig.rows[i];\r\n\r\n\t\t\tfor (let j in fileConfig.arrayCols) {\r\n\t\t\t\trow[j] = (row[j] + '').trim().split(fileConfig.arrayCols[j] || ' ');\r\n\t\t\t}\r\n\r\n\t\t\t// Remove default values from specified columns\r\n\t\t\tfor (let j in fileConfig.defaultColValues) {\r\n\t\t\t\tif (j in fileConfig.arrayCols) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif ((row[j] + '') === (fileConfig.defaultColValues[j] + '')) {\r\n\t\t\t\t\trow[j] = '';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Add default values to empty cells in default cols\r\n\t\t\tfor (let j in fileConfig.defaultCols) {\r\n\t\t\t\tif (j in fileConfig.arrayCols) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif ((row[j] + '').trim() === '') {\r\n\t\t\t\t\trow[j] = fileConfig.defaultCols[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Set filters on rows object\r\n\t\tAnalyser._createRowFilterFunctions(dataConfig.rows, dataConfig.filters);\r\n\r\n\t\t// Build enums\r\n\t\tdataConfig.enums = Analyser._buildEnums(rows, fileConfig);\r\n\r\n\t\treturn dataConfig;\r\n\t},\r\n\r\n\t_buildEnums: function (rows, config) {\r\n\t\tlet enums = {};\r\n\r\n\t\tfor (let col in config.cols) {\r\n\r\n\t\t\t// Don't collect enums for columns specified in uniqueCols or enumsMap\r\n\t\t\tlet collect = true;\r\n\t\t\tif (config.uniqueCols.includes(config.cols[col])) {\r\n\t\t\t\tcollect = false;\r\n\t\t\t}\r\n\t\t\tfor (let enumCol in config.enumsMap) {\r\n\t\t\t\tif (config.enumsMap[enumCol].includes(config.cols[col])) {\r\n\t\t\t\t\tcollect = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (collect) {\r\n\t\t\t\tenums[col] = [];\r\n\t\t\t\tAnalyser._collectEnums(rows, enums[col], config.cols[col]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let enumCol in config.enumsMap) {\r\n\t\t\tenums[enumCol] = [];\r\n\t\t\tAnalyser._collectEnums.apply(this, [rows, enums[enumCol]].concat(config.enumsMap[enumCol]));\r\n\t\t}\r\n\r\n\t\treturn enums;\r\n\t},\r\n\r\n\t_collectEnums: function (rows, enumsArr, ...cols) {\r\n\t\t// Go through all cells in a given set of columns\r\n\t\t// and add all unique entries found to enumsArr\r\n\r\n\t\tenumsArr = enumsArr || [];\r\n\r\n\t\tfor (let i = 0; i < rows.length; i++) {\r\n\t\t\tlet row = rows[i];\r\n\t\t\tfor (let j = 0; j < cols.length; j++) {\r\n\t\t\t\tlet col = cols[j];\r\n\r\n\t\t\t\tif (row[col] instanceof Array) {\r\n\t\t\t\t\tfor (let k = 0; k < row[col].length; k++) {\r\n\t\t\t\t\t\tif ((row[col][k] !== '') && (enumsArr.indexOf(row[col][k]) === -1)) {\r\n\t\t\t\t\t\t\tenumsArr.push(row[col][k]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ((row[col] !== '') && (enumsArr.indexOf(row[col]) === -1)) {\r\n\t\t\t\t\t\tenumsArr.push(row[col]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn enumsArr;\r\n\t},\r\n\r\n\tcombineData: function (...dataConfigs) {\r\n\t\t// Takes in any number of dataConfig objects from _processData\r\n\t\t// Combines the rows and relevant dataConfig objects (e.g. aliases, enums)\r\n\t\t// Keeps only columns shared by all dataConfig objects\r\n\r\n\t\t// Assumes there is no data shared between different sets,\r\n\t\t// so duplicates will *not* be detected or removed\r\n\r\n\t\t// The output is in the same format as for _processData\r\n\r\n\t\tlet combinedDataConfig = {\r\n\t\t\tcols: {},\r\n\t\t\trows: new AnalyserRows([]),\r\n\t\t\taliases: {}\r\n\t\t};\r\n\r\n\t\tif (!dataConfigs || dataConfigs.length < 2) {\r\n\t\t\tconsole.error('Invalid inputs passed to combineData', arguments);\r\n\t\t}\r\n\r\n\t\t// Combine cols first //\r\n\r\n\t\t// Build base set from first cols object\r\n\t\tfor (let j in dataConfigs[0].cols) {\r\n\t\t\tcombinedDataConfig.cols[j] = true;\r\n\t\t}\r\n\r\n\t\t// Remove any cols not shared by every other cols object\r\n\t\tfor (let i = 1; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\r\n\t\t\tfor (let j in combinedDataConfig.cols) {\r\n\t\t\t\tif (!(j in dataConfig.cols)) {\r\n\t\t\t\t\tdelete combinedDataConfig.cols[j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet colIndex = 0;\r\n\t\tfor (let j in combinedDataConfig.cols) {\r\n\t\t\tcombinedDataConfig.cols[j] = colIndex;\r\n\t\t\tcolIndex++;\r\n\t\t}\r\n\r\n\t\t// Now that we have the combined cols object, combine rows and aliases\r\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\t\t\t// Combine rows //\r\n\r\n\t\t\tfor (let j = 0; j < dataConfig.rows.length; j++) {\r\n\t\t\t\tlet row = [];\r\n\t\t\t\tfor (let k in combinedDataConfig.cols) {\r\n\t\t\t\t\trow[combinedDataConfig.cols[k]] = dataConfig.rows[j][dataConfig.cols[k]];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcombinedDataConfig.rows.push(row);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// Combine aliases //\r\n\r\n\t\t\t// Loop through each row's aliases to combine\r\n\t\t\tfor (let j in dataConfig.aliases) {\r\n\r\n\t\t\t\t// If we don't have an alias for this column, make an empty placeholder\r\n\t\t\t\tif (!(j in combinedDataConfig.aliases)) {\r\n\t\t\t\t\tcombinedDataConfig.aliases[j] = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Loop through each aliasSet for this column\r\n\t\t\t\tfor (let k = 0; k < dataConfig.aliases[j].length; k++) {\r\n\t\t\t\t\tlet aliasSet = dataConfig.aliases[j][k];\r\n\r\n\t\t\t\t\t// Combine aliasSets based off their first element, which is used as a label\r\n\t\t\t\t\tlet combinedAliasSet = [];\r\n\t\t\t\t\tlet l;\r\n\t\t\t\t\tfor (l = 0; l < combinedDataConfig.aliases[j].length; l++) {\r\n\t\t\t\t\t\tif (combinedDataConfig.aliases[j][l][0] === aliasSet[0]) {\r\n\t\t\t\t\t\t\tcombinedAliasSet = combinedDataConfig.aliases[j][l];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcombinedAliasSet = combinedAliasSet.concat(aliasSet);\r\n\r\n\t\t\t\t\t// Remove duplicates\r\n\t\t\t\t\tcombinedAliasSet = combinedAliasSet.filter(function (alias, index, array) {\r\n\t\t\t\t\t\treturn array.indexOf(alias) === index;\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// Append or replace aliasSet in combinedDataConfig\r\n\t\t\t\t\tif (l < combinedDataConfig.aliases[j].length) {\r\n\t\t\t\t\t\tcombinedDataConfig.aliases[j][l] = combinedAliasSet;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcombinedDataConfig.aliases[j].push(combinedAliasSet);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Create new filters using combined aliases\r\n\t\tcombinedDataConfig.filters = Analyser._getAliasFilters(combinedDataConfig.aliases);\r\n\t\tAnalyser._createRowFilterFunctions(combinedDataConfig.rows, combinedDataConfig.filters);\r\n\r\n\t\t// Combine uniqueCols\r\n\t\tcombinedDataConfig.uniqueCols = [];\r\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\r\n\t\t\tfor (let j in dataConfig.uniqueCols) {\r\n\t\t\t\tlet originalCol = dataConfig.uniqueCols[j];\r\n\t\t\t\tlet originalColName = undefined;\r\n\t\t\t\tfor (let k in dataConfig.cols) {\r\n\t\t\t\t\tif (dataConfig.cols[l] === originalCol) {\r\n\t\t\t\t\t\toriginalColName = l;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (originalColName) {\r\n\t\t\t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\r\n\r\n\t\t\t\t\tif (combinedDataConfig.uniqueCols.indexOf(originalColIndex) === -1) {\r\n\t\t\t\t\t\tcombinedDataConfig.uniqueCols.push(combinedDataConfig.cols[originalColName]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Combine the enumsMaps, then build combined enums\r\n\t\tcombinedDataConfig.enumsMap = {};\r\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\r\n\t\t\tlet dataConfig = dataConfigs[i];\r\n\r\n\t\t\tfor (let j in dataConfig.enumsMap) {\r\n\t\t\t\tlet originalEnumsMap = dataConfig.enumsMap[j];\r\n\r\n\t\t\t\tif (!originalEnumsMap) {\r\n\t\t\t\t\t// Mark this enumsMap as null to denote that it doesn't\r\n\t\t\t\t\t// exist across all dataConfigs we are combining\r\n\t\t\t\t\tcombinedDataConfig.enumsMap[j] = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (combinedDataConfig.enumsMap[j] !== null) {\r\n\t\t\t\t\t\tcombinedDataConfig.enumsMap[j] = combinedDataConfig.enumsMap[j] || [];\r\n\r\n\t\t\t\t\t\tfor (let k = 0; k < originalEnumsMap.length; k++) {\r\n\t\t\t\t\t\t\tlet originalCol = originalEnumsMap[k];\r\n\t\t\t\t\t\t\tlet originalColName = undefined;\r\n\t\t\t\t\t\t\tfor (let l in dataConfig.cols) {\r\n\t\t\t\t\t\t\t\tif (dataConfig.cols[l] === originalCol) {\r\n\t\t\t\t\t\t\t\t\toriginalColName = l;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (originalColName) {\r\n\t\t\t\t\t\t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\r\n\r\n\t\t\t\t\t\t\t\tif (combinedDataConfig.enumsMap[j].indexOf(originalColIndex) === -1) {\r\n\t\t\t\t\t\t\t\t\tcombinedDataConfig.enumsMap[j].push(combinedDataConfig.cols[originalColName]);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (let j in combinedDataConfig.enumsMap) {\r\n\t\t\t\tif (combinedDataConfig.enumsMap[j] === null) {\r\n\t\t\t\t\tdelete combinedDataConfig[enumsMap[j]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcombinedDataConfig.enums = Analyser._buildEnums(combinedDataConfig.rows, combinedDataConfig);\r\n\r\n\t\treturn combinedDataConfig;\r\n\t},\r\n\r\n\t/////////////////\r\n\t// CSV PARSING //\r\n\t/////////////////\r\n\t_parseCsv: function (csv) {\r\n\t\t// Parse a CSV file then process the data\r\n\t\t// Convert strings to numbers where appropriate,\r\n\t\t// then pass the data to a callback function\r\n\r\n\t\tlet data = Object(csv__WEBPACK_IMPORTED_MODULE_0__[\"parse\"])(csv);\r\n\t\tdata = Analyser._extractCellValues(data);\r\n\r\n\t\treturn data;\r\n\t},\r\n\r\n\t_extractCellValues: function (rawRows) {\r\n\t\t// Use _extractValue on each cell\r\n\t\tlet rows = rawRows.map((row) => row.map(Analyser._extractValue));\r\n\t\treturn rows;\r\n\t},\r\n\r\n\t_extractValue: function (string) {\r\n\t\t// Convert strings to booleans or numbers where possible\r\n\r\n\t\tif (string === 'true') {\r\n\t\t\treturn true;\r\n\t\t} else if (string === 'false') {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn Analyser._extractNumber(string);\r\n\t\t}\r\n\t},\r\n\r\n\t_extractNumber: function (string) {\r\n\t\t// Convert strings to numbers where possible\r\n\r\n\t\tlet val = string.replace(/,|%$/g, '');\r\n\r\n\t\tif (parseFloat(val) === +val) {\r\n\t\t\tif (string.match(/%$/)) {\r\n\t\t\t\t// If the value is a percentage, divide by 100\r\n\r\n\t\t\t\t// Convert to string to see how many places after the point, to round after dividing\r\n\t\t\t\t// Otherwise you'll get numbers like 0.10800000000000001\r\n\t\t\t\tlet length = (val + '');\r\n\t\t\t\tlength.replace(/^[^.]+/, '');\r\n\t\t\t\tlength = length.length;\r\n\r\n\t\t\t\tval = val / 100;\r\n\t\t\t\tval = val.toFixed(length+2);\r\n\t\t\t}\r\n\t\t\treturn +val;\r\n\t\t} else {\r\n\t\t\treturn string;\r\n\t\t}\r\n\t},\r\n\r\n\t///////////////\r\n\t// FILTERING //\r\n\t///////////////\r\n\t_getAliasFilters: function (aliases) {\r\n\t\tconst filterRows = function (rows, orToggle, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\r\n\t\t\t// Takes in a rows object (imported from csv),\r\n\t\t\t// a boolean specifying whether it's an \"and\" or an \"or\" filter,\r\n\t\t\t// and any number of pairs (at least one) of\r\n\t\t\t// the index of the column to consider, and an array of values\r\n\r\n\t\t\t// Returns an array of rows where the cell in the column\r\n\t\t\t// specified contains a value in the array of values given\r\n\t\t\t// for all column and value pairs\r\n\r\n\t\t\tlet and = !orToggle;\r\n\t\t\tlet startAt = 2;\r\n\r\n\t\t\tlet filteredRows = [];\r\n\r\n\t\t\tif ((arguments.length < 4) || (((arguments.length-2) % 2) !== 0)) {\r\n\t\t\t\t// Assume \"andToggle\" has not been passed\r\n\t\t\t\tand = true;\r\n\t\t\t\tstartAt = 1;\r\n\t\t\t\tif ((arguments.length < 3) || (((arguments.length-1) % 2) !== 0)) {\r\n\t\t\t\t\tconsole.error('An invalid set of arguments was passed to filterRows');\r\n\t\t\t\t\treturn [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet filters = [];\r\n\t\t\tfor (let i = startAt; i < arguments.length-1; i += 2) {\r\n\t\t\t\tlet filter = {\r\n\t\t\t\t\tcolIndex: arguments[i],\r\n\t\t\t\t\tvalues: arguments[i+1]\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif (!(Array.isArray(filter.values) || filter.values instanceof Function)) {\r\n\t\t\t\t\tfilter.values = [filter.values];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfilters.push(filter);\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 0; i < rows.length; i++) {\r\n\t\t\t\tlet row = rows[i];\r\n\r\n\t\t\t\tlet isMatch = !!and;\r\n\r\n\t\t\t\tfor (let j = 0; j < filters.length; j++) {\r\n\t\t\t\t\tlet filter = filters[j];\r\n\r\n\t\t\t\t\tif (and) {\r\n\t\t\t\t\t\tisMatch = isMatch && Analyser._applyFilter(row, filter.colIndex, filter.values, aliases);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tisMatch = isMatch || Analyser._applyFilter(row, filter.colIndex, filter.values, aliases);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isMatch) {\r\n\t\t\t\t\tfilteredRows.push(row);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfilteredRows = new AnalyserRows(filteredRows);\r\n\t\t\tfilteredRows.filter = rows.filter;\r\n\t\t\tfilteredRows.filterAnd = rows.filterAnd;\r\n\t\t\tfilteredRows.filterOr = rows.filterOr;\r\n\r\n\t\t\treturn filteredRows;\r\n\t\t};\r\n\r\n\t\tconst filterRowsAnd = function (rows, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\r\n\t\t\tlet args = Array.prototype.slice.apply(arguments);\r\n\r\n\t\t\targs = args.slice(1);\r\n\t\t\targs.splice(0, 0, false);\r\n\t\t\targs.splice(0, 0, rows);\r\n\r\n\t\t\treturn filterRows.apply(this, args);\r\n\t\t};\r\n\r\n\t\tconst filterRowsOr = function (rows, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\r\n\t\t\tlet args = Array.prototype.slice.apply(arguments);\r\n\r\n\t\t\targs = args.slice(1);\r\n\t\t\targs.splice(0, 0, true);\r\n\t\t\targs.splice(0, 0, rows);\r\n\r\n\t\t\treturn filterRows.apply(this, args);\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tfilterRows: filterRows,\r\n\t\t\tfilterRowsAnd: filterRowsAnd,\r\n\t\t\tfilterRowsOr: filterRowsOr\r\n\t\t};\r\n\t},\r\n\r\n\t_createRowFilterFunctions: function (rows, filters) {\r\n\t\trows.filter = function () {\r\n\t\t\tvar args = [this].concat(Array.from(arguments));\r\n\r\n\t\t\treturn filters.filterRows.apply(this, args);\r\n\t\t};\r\n\r\n\t\trows.filterOr = function () {\r\n\t\t\tvar args = [this].concat(Array.from(arguments));\r\n\r\n\t\t\treturn filters.filterRowsOr.apply(this, args);\r\n\t\t};\r\n\r\n\t\trows.filterAnd = function () {\r\n\t\t\tvar args = [this].concat(Array.from(arguments));\r\n\r\n\t\t\treturn filters.filterRowsAnd.apply(this, args);\r\n\t\t};\r\n\t},\r\n\r\n\t_applyFilter: function (row, colIndex, values, aliases) {\r\n\t\t// Allow functions to be passed as filter tests\r\n\t\tif (values instanceof Function) {\r\n\t\t\treturn values(row[colIndex]);\r\n\t\t}\r\n\r\n\t\t// If one or more values is passed, test it against aliases\r\n\t\tif (!(values instanceof Array)) {\r\n\t\t\tvalues = [values];\r\n\t\t}\r\n\r\n\t\tlet cell = row[colIndex];\r\n\t\tlet cellValues;\r\n\r\n\t\tif (cell instanceof Array) {\r\n\t\t\tcellValues = cell;\r\n\t\t} else {\r\n\t\t\tcellValues = [cell];\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < cellValues.length; i++) {\r\n\t\t\tlet cellValue = cellValues[i];\r\n\r\n\t\t\tfor (let k = 0; k < values.length; k++) {\r\n\t\t\t\tif (Analyser._matchAlias(values[k], cellValue, aliases)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_matchAlias: function (cell, value, aliasSuperset) {\r\n\t\t// Checks if the value of a cell matches the value passed,\r\n\t\t// optionally taking one or more sets of aliases to match\r\n\r\n\t\t// The aliasSuperset is used because the default set of all\r\n\t\t// aliases will be used if no aliasSet is specified\r\n\r\n\t\tif (cell === value) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Could be array or object\r\n\t\tfor (let i in aliasSuperset) {\r\n\t\t\tlet aliasSet = aliasSuperset[i];\r\n\t\t\tfor (let j = 0; j < aliasSet.length; j++) {\r\n\t\t\t\tlet aliasList = aliasSet[j];\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\t(aliasList.indexOf(cell) !== -1) &&\r\n\t\t\t\t\t(aliasList.indexOf(value) !== -1)\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\t//////////////////////\r\n\t// HELPER FUNCTIONS //\r\n\t//////////////////////\r\n\tgetColNumber: function (colName) {\r\n\t\t// Takes in a string like \"CE\" and converts it to a row number like 82\r\n\r\n\t\tif (!(typeof colName === 'string' || colName instanceof String)) {\r\n\t\t\t// Not a string\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tlet alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\r\n\t\tlet rowNumber = -1; // Adjust for 0-based counting\r\n\r\n\t\tfor (let i = 0; i < colName.length; i++) {\r\n\t\t\tlet char = colName.toUpperCase()[i];\r\n\t\t\tlet charIndex = alphabet.indexOf(char);\r\n\r\n\t\t\tif (charIndex === -1) {\r\n\t\t\t\t// String contains invalid character\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\r\n\t\t}\r\n\r\n\t\treturn rowNumber;\r\n\t},\r\n\r\n\tgetColNumbers: function (cols) {\r\n\t\t// Takes in a flat object and runs each property through getColNumber\r\n\t\tlet newCols = {};\r\n\r\n\t\tfor (let key in cols) {\r\n\t\t\tlet val = cols[key];\r\n\r\n\t\t\tif (typeof val === 'string' || val instanceof String) {\r\n\t\t\t\tval = Analyser.getColNumber(cols[key]);\r\n\t\t\t}\r\n\r\n\t\t\tif (Number.isInteger(val) && val >= 0) {\r\n\t\t\t\tnewCols[key] = val;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newCols;\r\n\t},\r\n\r\n\t///////////////////\r\n\t// SUMMARY TOOLS //\r\n\t///////////////////\r\n\t_convertTableToString: function (table, useKeys, cellSeparatorOption, rowSeparatorOption) {\r\n\t\tconst cellSeparator = cellSeparatorOption || '\\t';\r\n\t\tconst rowSeparator = rowSeparatorOption || '\\n';\r\n\r\n\t\tlet tableString = '';\r\n\r\n\t\tlet addCell = (cellString) => {\r\n\t\t\tif (typeof cellString !== 'string') {\r\n\t\t\t\tcellString = '' + cellString;\r\n\t\t\t}\r\n\r\n\t\t\tif (cellString.indexOf(cellSeparator) !== -1) {\r\n\t\t\t\t// If the cell string contains the separator sequence,\r\n\t\t\t\t// wrap it in \" and escape any existing \" as \"\"\r\n\t\t\t\tcellString = '\"' + cellString.replace(/\"/g, '\"\"') + '\"';\r\n\t\t\t}\r\n\r\n\t\t\ttableString += cellString + cellSeparator;\r\n\t\t};\r\n\t\tlet endLine = () => {\r\n\t\t\t// Trim off last cell separator, replace with newline\r\n\t\t\ttableString = tableString.substr(0, tableString.length - cellSeparator.length) + rowSeparator;\r\n\t\t};\r\n\r\n\t\t// Render headers and create array of labels\r\n\t\tif (useKeys) {\r\n\t\t\ttableString += cellSeparator;\r\n\t\t}\r\n\r\n\t\tlet firstRowComplete = false;\r\n\t\tfor (let rowName in table) {\r\n\t\t\tif (firstRowComplete === true) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tfirstRowComplete = true;\r\n\r\n\t\t\tlet row = table[rowName];\r\n\t\t\tfor (let colName in row) {\r\n\t\t\t\taddCell(colName);\r\n\t\t\t}\r\n\t\t}\r\n\t\tendLine();\r\n\r\n\t\tfor (let rowName in table) {\r\n\t\t\tlet isFirstRow = false;\r\n\t\t\tlet row = table[rowName];\r\n\t\t\tfor (let colName in row) {\r\n\t\t\t\tlet cell = row[colName];\r\n\t\t\t\tif (useKeys) {\r\n\t\t\t\t\tif (isFirstRow === false) {\r\n\t\t\t\t\t\taddCell(rowName);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tisFirstRow = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\taddCell(cell);\r\n\t\t\t}\r\n\t\t\tendLine();\r\n\t\t}\r\n\r\n\t\treturn tableString;\r\n\t},\r\n\r\n\t_groupColSummaryByAliases: function (summary, aliasList) {\r\n\t\t// Takes a summary object like the output from getColSummary, and\r\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\r\n\r\n\t\t// Outputs a summary object where values within the same set of aliases are grouped\r\n\r\n\t\tlet newSummary = {};\r\n\t\tfor (let i in summary) {\r\n\t\t\tlet inAlias = false;\r\n\t\t\tfor (let j = 0; j < aliasList.length; j++) {\r\n\t\t\t\tlet aliases = aliasList[j];\r\n\r\n\t\t\t\tif (aliases.indexOf(i) !== -1) {\r\n\t\t\t\t\tinAlias = true;\r\n\t\t\t\t\tif (aliases[0] in newSummary) {\r\n\t\t\t\t\t\tnewSummary[aliases[0]] += summary[i];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnewSummary[aliases[0]] = summary[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (inAlias === false) {\r\n\t\t\t\tnewSummary[i] = summary[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newSummary;\r\n\t}\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\r\n\tloadFile: Analyser.loadFile,\r\n\tcombineData: Analyser.combineData,\r\n\r\n\tgetColNumber: Analyser.getColNumber,\r\n\tgetColNumbers: Analyser.getColNumbers,\r\n\tgetCol: Analyser.getCol\r\n});\r\n\n\n//# sourceURL=webpack:///./analyser.js?");

/***/ }),

/***/ "./docs/assets/js/src/main.js":
/*!************************************!*\
  !*** ./docs/assets/js/src/main.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _analyser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! /analyser */ \"./analyser.js\");\n\r\n\r\nconst analyse = async function () {\r\n\tconst fileInfoA = {\r\n\t\tpath: '/assets/data/Prison Population - raw.csv',\r\n\t\theaderRows: 1,\r\n\t\tcols: _analyser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getColNumbers({\r\n\t\t\tDATE: 'A',\r\n\t\t\tREMAND_MALE: 'B',\r\n\t\t\tREMAND_FEMALE: 'C',\r\n\t\t\tREMAND_TOTAL: 'D',\r\n\t\t\tSENTENCED_MALE: 'E',\r\n\t\t\tSENTENCED_FEMALE: 'F',\r\n\t\t\tSENTENCED_TOTAL: 'G',\r\n\t\t\tTOTAL_MALE: 'H',\r\n\t\t\tTOTAL_MALE: 'I',\r\n\t\t\tTOTAL_TOTAL: 'J',\r\n\t\t\tETHNICITY_MAORI: 'K',\r\n\t\t\tETHNICITY_EUROPEAN: 'L',\r\n\t\t\tETHNICITY_PACIFIC: 'M',\r\n\t\t\tETHNICITY_ASIAN: 'N',\r\n\t\t\tETHNICITY_OTHER: 'O',\r\n\t\t\tETHNICITY_UNKNOWN: 'P',\r\n\t\t\tETHNICITY_TOTAL: 'A',\r\n\t\t\tPER_100_000_POPULATION: 'R',\r\n\t\t}),\r\n\t};\r\n\r\n\tconst fileInfoB = {\r\n\t\tpath: '/assets/data/Tactical Options 2014 - raw.csv',\r\n\t\theaderRows: 1,\r\n\t\tcols: _analyser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getColNumbers({\r\n\t\t\tTACTICAL_OPTION: 'A',\r\n\t\t\tEUROPEAN: 'B',\r\n\t\t\tMAORI: 'C',\r\n\t\t\tPACIFIC: 'D',\r\n\t\t\tOTHER: 'E',\r\n\t\t}),\r\n\t};\r\n\r\n\tlet dataConfigArr = await _analyser__WEBPACK_IMPORTED_MODULE_0__[\"default\"].loadFile(fileInfoA, fileInfoB);\r\n\r\n\tfor (let dataConfig of dataConfigArr) {\r\n\t\tlet { rows, cols } = dataConfig;\r\n\r\n\t\tconsole.log(rows);\r\n\t\tconsole.log(rows.getCol(0));\r\n\t}\r\n\r\n\tlet { rows, cols } = dataConfigArr[0];\r\n\r\n\tlet newCol = rows.getCol(cols.REMAND_MALE).map((num) => num/10);\r\n\r\n\tlet newColIndex = rows.addCol(newCol);\r\n\tconsole.log(rows.getCol(newColIndex));\r\n\r\n\tlet derivedColIndex = rows.addDerivedCol((row, extraVal1) => {\r\n\t\treturn row[1] + row[2] - extraVal1;\r\n\t}, newCol);\r\n\tconsole.log(rows.getCol(derivedColIndex));\r\n\r\n\tconsole.table(rows.createSubTable(cols));\r\n\tconsole.log(rows.createSubTableString(cols));\r\n\r\n\trows = dataConfigArr[1].rows;\r\n\tcols = dataConfigArr[1].cols;\r\n\r\n\tconsole.log(rows.getColSummary(cols.TACTICAL_OPTION));\r\n\r\n\tlet dataSeries = rows.getColAsDataSeries(cols.TACTICAL_OPTION, Object.keys(rows.getColSummary(cols.TACTICAL_OPTION)));\r\n\tconsole.log(dataSeries);\r\n\r\n\tlet comparisonSummary = rows.getComparisonSummary(cols.TACTICAL_OPTION, cols.MAORI);\r\n\tconsole.log(comparisonSummary);\r\n\r\n\tlet comparisonSummaryString = rows.getComparisonSummaryString(cols.TACTICAL_OPTION, cols.MAORI);\r\n\tconsole.log(comparisonSummaryString);\r\n\r\n\trows.saveComparisonSummaryCsv('test', cols.TACTICAL_OPTION, cols.MAORI);\r\n};\r\n\r\nanalyse();\r\n\n\n//# sourceURL=webpack:///./docs/assets/js/src/main.js?");

/***/ }),

/***/ "./node_modules/csv/csv.js":
/*!*********************************!*\
  !*** ./node_modules/csv/csv.js ***!
  \*********************************/
/*! exports provided: stringify, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\nconst { stringify, parse } = (() => {\n\tconst csv = {\n\t\tstringify: function (data, options) {\n\t\t\toptions = options || {};\n\t\t\toptions.transpose = options.transpose || false;\n\t\t\toptions.sanitise = options.sanitise || false;\n\n\t\t\t// Enforce square data and apply CSV escaping, then convert to string\n\t\t\tlet rows = data;\n\n\t\t\trows = csv._shape(data, options);\n\t\t\trows = csv._escape(rows, options);\n\n\t\t\trows = csv._join(rows);\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_shape: function (data, options) {\n\t\t\t// Pad missing cells with empty strings and,\n\t\t\t// if necessary, transpose the data\n\n\t\t\tconst transpose = options.transpose;\n\n\t\t\tconst maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\n\n\t\t\t// Flip rows and columns if transposing data\n\t\t\tconst iMax = transpose ? maxLength : data.length;\n\t\t\tconst jMax = transpose ? data.length : maxLength;\n\n\t\t\tlet rows = [];\n\t\t\tfor (let i = 0; i < iMax; i++) {\n\t\t\t\tlet row = [];\n\t\t\t\tfor (let j = 0; j < jMax; j++) {\n\t\t\t\t\tlet iRow = transpose ? j : i;\n\t\t\t\t\tlet iCol = transpose ? i : j;\n\n\t\t\t\t\tlet cellValue = data[iRow][iCol];\n\n\t\t\t\t\tif (iCol >= data[iRow].length) {\n\t\t\t\t\t\tcellValue = '';\n\t\t\t\t\t}\n\n\t\t\t\t\trow.push(cellValue);\n\t\t\t\t}\n\t\t\t\trows.push(row);\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_escape: function (rows, options) {\n\t\t\t// Make sure any cells containing \" or , or a newline are escaped appropriately\n\n\t\t\tconst sanitise = options.sanitise;\n\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\tlet row = rows[i];\n\n\t\t\t\tfor (let j = 0; j < row.length; j++) {\n\t\t\t\t\tif (typeof row[j] === 'undefined') {\n\t\t\t\t\t\t// Replace undefined with ''\n\t\t\t\t\t\trow[j] = '';\n\t\t\t\t\t} else if (typeof row[j] !== 'string') {\n\t\t\t\t\t\t// Convert to string\n\t\t\t\t\t\trow[j] = '' + row[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sanitise) {\n\t\t\t\t\t\t// Prevent spreadsheet software like\n\t\t\t\t\t\t// Excel from trying to execute code\n\t\t\t\t\t\tif (row[j].match(/^[=\\-+@]/)) {\n\t\t\t\t\t\t\trow[j] = '\\t' + row[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (row[j].match(/,|\"|\\n/)) {\n\n\t\t\t\t\t\t// Turn any double quotes into escaped double quotes\n\t\t\t\t\t\trow[j] = row[j].replace(/\"/g, '\"\"');\n\n\t\t\t\t\t\t// Wrap cell in double quotes\n\t\t\t\t\t\trow[j] = '\"' + row[j] + '\"';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_join: function (rows) {\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\trows[i] = rows[i].join(',');\n\t\t\t}\n\t\t\trows = rows.join('\\n');\n\n\t\t\treturn rows;\n\t\t},\n\n\n\t\tparse: function (csvString) {\n\t\t\tlet rows = csv._tokenise(csvString);\n\n\t\t\tcsv._validate(rows);\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_tokenise: function (csvString) {\n\t\t\t// Walk through each character and produce an array of tokens\n\n\t\t\tlet tokens = [];\n\n\t\t\t// Remove carriage returns\n\t\t\tcsvString = csvString.replace(/\\r/g, '');\n\n\t\t\tlet inQuote = false;\n\t\t\tlet wasQuote = false;\n\n\t\t\tlet tokenStart = 0;\n\t\t\tlet row = [];\n\t\t\tfor (let i = 0; i < csvString.length; i++) {\n\t\t\t\tlet char = csvString[i];\n\n\t\t\t\tlet comma = char === ',';\n\t\t\t\tlet quote = char === '\"';\n\t\t\t\tlet newline = char === '\\n';\n\t\t\t\tlet eof = i === csvString.length -1; // eof - End Of File\n\n\t\t\t\tif (inQuote) {\n\t\t\t\t\t// Characters may be delimited\n\t\t\t\t\tif (quote) {\n\t\t\t\t\t\t// Check if the next character is another double quote, i.e. if it is escaped\n\t\t\t\t\t\tlet nextChar = csvString[i+1];\n\n\t\t\t\t\t\tif (nextChar === '\"') {\n\t\t\t\t\t\t\t// This and the next character combined make an escaped double quote,\n\t\t\t\t\t\t\t// so the quote has not ended and we should skip over the next character\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// The quote has ended\n\t\t\t\t\t\t\tinQuote = false;\n\t\t\t\t\t\t\twasQuote = true;\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (eof) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Reached end of file before ending quote. At index ${i}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (comma || newline || eof) {\n\t\t\t\t\t\t// These are the characters that denote the end of a token\n\t\t\t\t\t\tlet token = csvString.substring(tokenStart, i+1);\n\n\t\t\t\t\t\tif (comma || newline) {\n\t\t\t\t\t\t\t// Don't keep the separator\n\t\t\t\t\t\t\ttoken = token.substring(0, token.length - 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (wasQuote) {\n\t\t\t\t\t\t\twasQuote = false;\n\n\t\t\t\t\t\t\t// Remove start and end quotes\n\t\t\t\t\t\t\ttoken = token.substring(1, token.length - 1);\n\n\t\t\t\t\t\t\t// Replace escaped quotes\n\t\t\t\t\t\t\ttoken = token.replace(/\"\"/g, '\"');\n\t\t\t\t\t\t}\n\t\t\t\t\t\trow.push(token);\n\n\t\t\t\t\t\tif (comma && eof) {\n\t\t\t\t\t\t\t// It's the end of the last token, and the last cell is empty\n\t\t\t\t\t\t\trow.push('');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (newline || eof) {\n\t\t\t\t\t\t\ttokens.push(row);\n\t\t\t\t\t\t\tif (newline) {\n\t\t\t\t\t\t\t\trow = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttokenStart = i+1;\n\t\t\t\t} else if (wasQuote) {\n\t\t\t\t\tthrow new Error(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\n\t\t\t\t} else if (quote) {\n\t\t\t\t\tinQuote = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tokens;\n\t\t},\n\n\t\t_validate: function (rows) {\n\t\t\t// Each row of a CSV should have the same length;\n\n\t\t\tif (rows && rows.length > 1) {\n\t\t\t\tlet rowLength = rows[0].length;\n\t\t\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\t\t\tlet row = rows[i];\n\n\t\t\t\t\tif (row.length !== rowLength) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\treturn {\n\t\tstringify: csv.stringify,\n\t\tparse: csv.parse,\n\t};\n})();\n\n\n\n\n//# sourceURL=webpack:///./node_modules/csv/csv.js?");

/***/ }),

/***/ "./node_modules/fileio/fileio.js":
/*!***************************************!*\
  !*** ./node_modules/fileio/fileio.js ***!
  \***************************************/
/*! exports provided: save, load, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"save\", function() { return save; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return load; });\n/* harmony import */ var csv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csv */ \"./node_modules/csv/csv.js\");\n\n\nlet $link;\n\nconst fileIO = {\n\tload: (options) => {\n\t\toptions = options || {};\n\t\toptions.readMethod = options.readMethod || 'text';\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst fileLoaded = (e) => {\n\t\t\t\tlet reader = e.target;\n\n\t\t\t\tif (reader.readyState === 2) {\n\t\t\t\t\t// DONE\n\t\t\t\t\tresolve(reader.result);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst readFile = (file) => {\n\t\t\t\tlet reader = new FileReader();\n\n\t\t\t\treader.addEventListener('load', fileLoaded);\n\t\t\t\treader.addEventListener('error', () => {\n\t\t\t\t\treader.abort();\n\t\t\t\t\treject(new DOMException('Error parsing file'));\n\t\t\t\t});\n\n\t\t\t\tswitch (options.readMethod) {\n\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\t\treader.readAsArrayBuffer(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'binaryString':\n\t\t\t\t\t\treader.readAsBinaryString(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dataUrl':\n\t\t\t\t\t\treader.readAsDataURL(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'text':\n\t\t\t\t\t\treader.readAsText(file);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new RangeError(`FileIO: Unrecognised readMethod ${options.readMethod}`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst loadSelectedFile = (file) => {\n\t\t\t\tif (options.readMethod === 'file') {\n\t\t\t\t\tresolve(file);\n\t\t\t\t} else {\n\t\t\t\t\treadFile(file);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst loadSelectedFileEvent = (e) => {\n\t\t\t\tlet $fileInput = e.target;\n\t\t\t\tlet file = $fileInput.files[0];\n\n\t\t\t\tif (file) {\n\t\t\t\t\tloadSelectedFile(file);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst $fileInput = document.createElement('input');\n\t\t\t$fileInput.type = 'file';\n\t\t\t$fileInput.addEventListener('change', loadSelectedFileEvent);\n\n\t\t\t$fileInput.click();\n\t\t});\n\t},\n\n\tsave: (data, options) => {\n\t\toptions = options || {};\n\n\t\tif (data instanceof File) {\n\t\t\tfileIO._saveFile(data, options);\n\t\t} else if (data instanceof Blob) {\n\t\t\tfileIO._saveBlob(data, options);\n\t\t} else {\n\t\t\tfileIO._saveData(data, options);\n\t\t}\n\t},\n\n\t_saveBlob: (blob, options) => {\n\t\tif (!(blob instanceof Blob)) {\n\t\t\tthrow new TypeError('FileIO: save blob requires a Blob');\n\t\t}\n\n\t\toptions.filename = options.filename || 'file';\n\n\t\tif (navigator.msSaveBlob) {\n\t\t\tnavigator.msSaveBlob(blob, filename);\n\t\t} else {\n\t\t\tlet url = URL.createObjectURL(blob);\n\t\t\tfileIO._downloadDataUrl(url, options.filename);\n\t\t}\n\t},\n\n\t_saveFile: (file, options) => {\n\t\tif (!(file instanceof File)) {\n\t\t\tthrow new TypeError('FileIO: save file requires a File');\n\t\t}\n\n\t\toptions.filename = options.filename || file.name || 'file';\n\n\t\tif (navigator.msSaveBlob) {\n\t\t\tnavigator.msSaveBlob(file, options.filename);\n\t\t} else {\n\t\t\tlet reader = new FileReader();\n\n\t\t\treader.readAsDataURL(file);\n\t\t\treader.addEventListener('load', function () {\n\t\t\t\tfileIO._downloadDataUrl(this.result, options.filename);\n\t\t\t});\n\t\t}\n\t},\n\n\t_saveData: function (data, options) {\n\t\toptions.filename = options.filename || 'file';\n\t\toptions.type = options.type || 'text/plain'\n\n\t\t// CSV only\n\t\toptions.transpose = options.transpose || false;\n\t\toptions.sanitise = options.sanitise || false;\n\n\t\t// Type shorthands\n\t\tswitch (options.type) {\n\t\t\tcase 'json':\n\t\t\t\toptions.type = 'application/json';\n\t\t\t\tbreak;\n\t\t\tcase 'csv':\n\t\t\t\toptions.type = 'text/csv';\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (options.type === 'application/json') {\n\t\t\ttry {\n\t\t\t\tdata = JSON.stringify(data);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error('FileIO: Failed to save JSON');\n\t\t\t\tconsole.error(e);\n\t\t\t}\n\n\t\t\toptions.filename = fileIO._extendFilename(options.filename, 'json');\n\t\t} else if (options.type === 'text/csv') {\n\t\t\tif (!(typeof data === 'string' || data instanceof String)) {\n\t\t\t\tdata = csv__WEBPACK_IMPORTED_MODULE_0__[\"stringify\"](data, options);\n\t\t\t}\n\t\t\toptions.filename = fileIO._extendFilename(options.filename, 'csv');\n\t\t}\n\n\t\t// Construct a Blob and download it\n\t\tlet blob = new Blob(\n\t\t\t[data],\n\t\t\t{ type: options.type }\n\t\t);\n\n\t\tfileIO._saveBlob(blob, options);\n\t},\n\n\t_downloadDataUrl: function (dataUrl, filename) {\n\t\t$link = $link || document.createElement('a');\n\t\t$link.href = dataUrl;\n\t\t$link.download = filename;\n\t\t$link.click();\n\n\t\tURL.revokeObjectURL(dataUrl);\n\t},\n\n\t_downloadDataUrl: function (dataUrl, filename) {\n\t\t$link = $link || document.createElement('a');\n\t\t$link.href = dataUrl;\n\t\t$link.download = filename;\n\t\t$link.click();\n\n\t\tURL.revokeObjectURL(dataUrl);\n\t},\n\n\t_extendFilename: function (filename, extension) {\n\t\tlet testPattern = new RegExp('\\\\.' + extension + '$');\n\n\t\tif (!testPattern.test(filename)) {\n\t\t\tfilename += '.' + extension;\n\t\t}\n\n\t\treturn filename;\n\t},\n};\n\nconst save = fileIO.save;\nconst load = fileIO.load;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (fileIO);\n\n\n//# sourceURL=webpack:///./node_modules/fileio/fileio.js?");

/***/ })

/******/ });