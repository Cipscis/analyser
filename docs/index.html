<!DOCTYPE html>
<html>
<head>
	<title>Analyser</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />

	<link rel="stylesheet" href="/analyser/assets/css/main.css" />
	<script type="module" src="/analyser/assets/js/dist/docs-script.bundle.js"></script>
</head>
<body>
	<main class="layout">
		<section>
			<div class="content">
				<h1>Analyser</h1>

				<p>Analyser is a package for analysing and charting data in TypeScript, made available under the <a href="https://firstdonoharm.dev/" target="_blank">Hippocratic Licence</a>.</p>
			</div>
		</section>
		<section>
			<div class="content">
				<h2>About this page</h2>

				<p>This project is a rebuild of another data analysis library I created a few years ago called <a href="https://cipscis.github.io/charter/docs/" target="_blank">Charter</a>. Charter started as an attempt to create accessible graphs using HTML5 and CSS, and as I worked more on the code to generate those graphs it became more of a data analysis tool.</p>

				<p>Analyser is my attempt to rebuild this library in TypeScript, starting from the ground up with a clearer focus, after the lessons I've learned from using Charter to analyse complex data sets.</p>

				<p>This documentation is not yet complete, once I've finished each section I still need to reorganise the flow of the documentation and add some navigation aids.</p>
			</div>
		</section>

		<section>
			<div class="content">
				<h2 id="installation">Installation <a class="anchor" href="#installation"></a></h2>

				<p>You can install Analyser as an npm package:</p>

				<code>npm install @cipscis/analyser --save</code>

				<p>The main Analyser code can be imported with:</p>

				<code>import * as analyser from '@cipscis/analyser';</code>

				<p>Some parts of Analyser can also be accessed via submodules.</p>

				<p><a href="#usage-transformers">Transformer functions</a>:</p>

				<code>import { transformers } from '@cipscis/analyser';</code><br />
				<code>import * as transformers from '@cipscis/analyser/transformers';</code>

				<p><a href="#statistics">Statistical helper functions</a>:</p>

				<code>import { statistics } from '@cipscis/analyser';</code><br />
				<code>import * as statistics from '@cipscis/analyser/statistics';</code>
			</div>
		</section>

		<section>
			<div class="content">
				<h2 id="example-data">Example data <a class="anchor" href="#example-data"></a></h2>

				<p>This documentation uses example data:</p>
			</div>

			<script type="text/plain" class="js-codebook__block" data-codebook-html="html-example-data" data-codebook-set="example-data">
				const csvString = await (await fetch('/analyser/assets/data/city example.csv')).text();
				const data = csv.parse(csvString);

				const table = `<table>
					${data.map((row, i) => `<tr>
						${row.map((cell) => `<${i ? 'td' : 'th'}>
							${cell}
						</${i ? 'td' : 'th'}>`).join('')}
					</tr>`).join('')}
				</table>`;

				html(table);
			</script>

			<div class="content content--autoscroll" id="html-example-data">
				<p>A table showing the example data will load here.</p>
			</div>

			<div class="content">
				<p>The code examples in this documentation are editable, and run using <code><a href="cipscis.github.io/codebook" target="_blank">@cipscis/codebook</a></code>. Editable code is marked with a ‚úèÔ∏è, and its output is marked with a üìù.</p>

				<p>To ensure the examples' <code>log</code> and <code>html</code> helper functions work correctly, make sure you use <code>await</code> so all asynchronous code finishes before reaching the end of the example.</p>
			</div>

			<div class="docs-example js-docs__example js-codebook__set" data-codebook-set="example-output">
				<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-codebook-example" data-codebook-html="html-codebook-example" contenteditable spellcheck="false">
					log('You can log output');
					html('<p>Some examples can <b>print custom HTML</b></p>');
				</script>

				<div class="docs-example__controls">
					<button class="docs-example__control js-docs__run">Run code</button>
				</div>

				<div class="docs-example__html" id="html-codebook-example"></div>

				<samp class="docs-example__log js-docs__log" id="log-codebook-example"></samp>
			</div>
		</section>

		<section>
			<div class="content">
				<h2 id="usage">Usage <a class="anchor" href="#usage"></a></h2>

				<p>The first step to analysing data with Analyser is loading it. The <code><a href="#methods-loadFile">loadFile</a></code> method can be used to load data from a CSV file, using <a href="https://cipscis.github.io/csv" target="_blank">@cipscis/csv</a> internally for parsing and <a href="#usage-transformers">transformers</a> to determine types and do any necessary cleaning or recoding.</p>

				<p><code>loadFile</code> returns a <code><a href="#interfaces-DataConfig">DataConfig</a></code> object, which can be used to analyse the data using <a href="#usage-filtering">filtering</a> functions to filter the rows of data and <a href="#usage-grouping">grouping</a> functions to create summaries.</p>

				<p>Those summaries can then be used to <a href="#usage-graphs">create graphs</a>.</p>
			</div>

			<section>
				<div class="content">
					<h2 id="usage-transformers">Transformers <a class="anchor" href="#usage-transformers"></a></h2>

					<p>Analyser provides a number of <a href="#interfaces-TransformerFn">transformer functions</a> for converting strings in CSV cells into common types. These can be imported from <code>'@cipscis/analyser/tranformers'</code>.</p>

					<p>There are also some utility functions provided here for creating custom some simple transformers.</p>

					<p>Each of these functions can be accessed either via <code>analyser.transformers</code> or by importing them from the <code>@cipscis/analyser/transformers</code> submodule:</p>

					<code>import { transformers } from '@cipscis/analyser';</code><br />
					<code>import * as transformers from '@cipscis/analyser/transformers';</code>
				</div>

				<section class="js-codebook__set" data-codebook-set="usage-transformers-boolean">
					<div class="content">
						<h3 id="usage-transformers-boolean">boolean <a class="anchor" href="#usage-transformers-boolean"></a></h3>

						<p>If a value is <code>'true'</code> or <code>'false'</code>, ignoring case and any leading or trailing whitespace, then it is converted to the relevant boolean value.</p>

						<p>If a cell has a value that doesn't match either of those strings, it will be converted to <code>null</code> and a warning will be written to the console specifying where the value exists within the data.</p>

						<div class="docs-example js-docs__example">
							<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-transformers-boolean" contenteditable spellcheck="false">
								const fileConfig = analyser.fileConfig({
									path: '/analyser/assets/data/city example.csv',
									cols: {
										CAPITAL: 'D',
									},
									headerRows: 1,
									footerRows: 1,
									transform: {
										CAPITAL: analyser.transformers.boolean,
									}
								});

								const { rows, cols } = await analyser.loadFile(fileConfig);
								log(rows.getCol(cols.CAPITAL));
							</script>

							<div class="docs-example__controls">
								<button class="docs-example__control js-docs__run">Run code</button>
							</div>

							<samp class="docs-example__log js-docs__log" id="log-usage-transformers-boolean"></samp>
						</div>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-transformers-number">
					<div class="content">
						<h3 id="usage-transformers-number">number <a class="anchor" href="#usage-transformers-number"></a></h3>

						<p>If a cell's value looks like a number, it will be converted to a number. Analyser expects string representations of numbers to use the <code>'.'</code> character for a decimal point, and optionally the <code>','</code> character for separators within the number.</p>

						<p>If a string looks like a number and also ends with a <code>'%'</code> character, it will be divided by <code>100</code> to convert it into a percentage.</p>

						<p>If a cell has a value that doesn't look like a number, it will be converted to <code>null</code> and a warning will be written to the console specifying where the value exists within the data.</p>

						<div class="docs-example js-docs__example">
							<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-transformers-number" contenteditable spellcheck="false">
								const fileConfig = analyser.fileConfig({
									path: '/analyser/assets/data/city example.csv',
									cols: {
										POPULATION: 'C',
									},
									headerRows: 1,
									footerRows: 1,
									transform: {
										POPULATION: analyser.transformers.number,
									}
								});

								const { rows, cols } = await analyser.loadFile(fileConfig);
								log(rows.getCol(cols.POPULATION));

								log(
									'Transforming a percentage:',
									analyser.transformers.number('0.2%')
								);
							</script>

							<div class="docs-example__controls">
								<button class="docs-example__control js-docs__run">Run code</button>
							</div>

							<samp class="docs-example__log js-docs__log" id="log-usage-transformers-number"></samp>
						</div>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-transformers-value">
					<div class="content">
						<h3 id="usage-transformers-value">value <a class="anchor" href="#usage-transformers-value"></a></h3>

						<p><code>value</code> combines the <a href="#usage-transformers-boolean">boolean</a> and <a href="#usage-transformers-number">number</a> transformers.</p>

						<p>If a cell looks like it contains a boolean, it will be converted to a boolean. Otherwise, if it looks like it contains a number, it will be converted to a number.</p>

						<p>If a cell has a value but it doesn't look like a boolean or a number, it will be converted to <code>null</code> and a warning will be written to the console specifying where the value exists within the data.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-transformers-value" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									POPULATION: 'C',
									CAPITAL: 'D',
								},
								headerRows: 1,
								transform: {
									POPULATION: analyser.transformers.value,
									CAPITAL: analyser.transformers.value,
								}
							});

							const { rows, cols } = await analyser.loadFile(fileConfig);
							log(rows.getCol(cols.POPULATION));
							log(rows.getCol(cols.CAPITAL));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-usage-transformers-value"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-transformers-array">
					<div class="content">
						<h3 id="usage-transformers-array">array <a class="anchor" href="#usage-transformers-array"></a></h3>

						<code>array(separator: string | RegExp, limit?: number): <a href="#interfaces-transformerFn">TransformerFn</a>&lt;string[]&gt;</code>

						<p>The <code>array</code> function provided by Analyser can be used to create a <a href="#interfaces-TransformerFn">transformer function</a> that converts a string into an array of strings.</p>

						<p>The arguments taken by the <code>array</code> helper function are the same as those used by <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank">String.prototype.split</a></code>.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-transformers-array" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									PUBLIC_TRANSPORT: 'E',
								},
								headerRows: 1,
								transform: {
									PUBLIC_TRANSPORT: analyser.transformers.array(','),
								}
							});

							const { rows, cols } = await analyser.loadFile(fileConfig);
							log(rows.getCol(cols.PUBLIC_TRANSPORT));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-usage-transformers-array"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-transformers-booleanCustom">
					<div class="content">
						<h3 id="usage-transformers-booleanCustom">booleanCustom <a class="anchor" href="#usage-transformers-booleanCustom"></a></h3>

						<code>booleanCustom(truthy: string | RegExp = 'true', falsey: string | RegExp = 'false'): <a href="#interfaces-TransformerFn">TransformerFn</a>&lt;boolean&gt;</code>

						<p>The <code>booleanCustom</code> helper function can be used to create a custom <a href="#interfaces-TransformerFn">transformer function</a> for converting a string into boolean values.</p>

						<p>If a cell matches the string or regular expression in the <code>truthy</code> argument, it will be converted to <code>true</code>. Otherwise, if it matches the string or regular expression in the <code>falsey</code> argument, it will be converted to <code>false</code>.</p>

						<p>If strings are specified, the matching is case insensitive. Leading or trailing whitespace is also ignored. If case or leading or trailing whitespace should be treated as a warning, you can use a case insensitive regular expression such as <code>/^true$/</code> instead.</p>

						<p>If a cell has a value that matches neither argument, it will be converted to <code>null</code> and a warning will be written to the console specifying where the value exists within the data.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-transformers-booleanCustom" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									CAPITAL: 'D',
								},
								headerRows: 1,
								transform: {
									CAPITAL: analyser.transformers.booleanCustom('true', /^'No'$|^false$/),
								}
							});

							const { rows, cols } = await analyser.loadFile(fileConfig);
							log(rows.getCol(cols.CAPITAL));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-usage-transformers-booleanCustom"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-transformers--enumValue">
					<div class="content">
						<h3 id="usage-transformers-enumValue">enumValue <a class="anchor" href="#usage-transformers-enumValue"></a></h3>

						<code>enumValue(enums: Record&lt;string, string&gt;, recodeMap?: Record&lt;string, string&gt;): <a href="#interfaces-TransformerFn">TransformerFn</a>&lt;string&gt;</code>

						<p>The <code>enumValue</code> helper function can be used to create a custom <a href="#interfaces-TransformerFn">transformer function</a> that ensures that the value of every cell in a column exists within a <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank">TypeScript enum</a>.</p>

						<p>If a cell has a value that already exists within the passed <code>enum</code>, then it will not be transformed.</p>

						<p>However, if a cell has a value that is not within the <code>enum</code>, it will be converted to <code>null</code> and a warning will be written to the console specifying where the value exists within the data.</p>

						<p><code>enumValue</code> has an optional second parameter that can be used to convert strings that don't exist within the <code>enum</code> into strings that are members. These transformations are applied before the value's membership is checked.</p>

						<div class="docs-example js-docs__example">
							<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-transformers-enumValue" contenteditable spellcheck="false">
								// When working in TypeScript, this would be a string enum
								const countries = {
									Aotearoa: 'Aotearoa',
									Australia: 'Australia',
									Germany: 'Germany',
								};

								const countriesMap = {
									'New Zealand': 'Aotearoa',
								};

								const fileConfig = analyser.fileConfig({
									path: '/analyser/assets/data/city example.csv',
									cols: {
										COUNTRY: 'B',
									},
									headerRows: 1,
									footerRows: 1,
									transform: {
										COUNTRY: analyser.transformers.enumValue(countries, countriesMap),
									}
								});

								const { rows, cols } = await analyser.loadFile(fileConfig);
								log(rows.getCol(cols.COUNTRY));
							</script>

							<div class="docs-example__controls">
								<button class="docs-example__control js-docs__run">Run code</button>
							</div>

							<samp class="docs-example__log js-docs__log" id="log-usage-transformers-enumValue"></samp>
						</div>
					</div>
				</section>
			</section>

			<section class="js-codebook__set" data-codebook-set="usage-filtering">
				<div class="content">
					<h2 id="usage-filtering">Filtering <a class="anchor" href="#usage-filtering"></a></h2>

					<p>The <code><a href="#interfaces-DataConfig">DataConfig</a></code> object exposes a function called <code><a href="#interfaces-DataConfig-by">by</a></code>, which is used for filtering the <code><a href="#interfaces-AnalyserRows">AnalyserRows</code></a> exposed in the <code>DataConfig</code>'s <code><a href="#interfaces-DataConfig-rows">rows</a></code> property.</p>

					<p>This function effectively has any <code><a href="#interfaces-FileConfig-aliases">aliases</a></code> baked in. It also provides a simplified way of filtering rows of data based on the values of specific columns, which allows for chaining to create more complex filters.</p>

					<code>(colIndex: number, values: unknown): Function</code><br />
					<code>(colIndex: number, values: unknown[]): Function</code><br />
					<code>(colIndex: number, values: (value: unknown) => boolean): Function</code>

					<p>There are three different ways to call <code>by</code>. Each involves first specifying a column index, typically taken from the <code><a href="#interfaces-DataConfig-cols">cols</a></code> or <code><a href="#interfaces-DataConfig-addedCols">addedCols</a></code> objects, then specifying some way of filtering based on the value of that column.</p>

					<p>The simplest form simply specifies a single value to match. If a cell's value matches the specified value, or if the cell's value is an array containing the specified value, it will pass the filter. This matching process respects any specified <code><a href="#interfaces-FileConfig-aliases">aliases</a></code>.</p>

					<p>The next form allows multiple values to be specified via an array. If a cell's value matches any of these values, or if the cell's value is an array containing any of them, it will pass the filter. Like the single value option, this matching process respects any specified <code><a href="#interfaces-FileConfig-aliases">aliases</a></code>.</p>

					<p>The most complex form allows a function to be passed, which takes the value of the cell as its only argument and resolves to a boolean. If this function returns <code>true</code> for a particular row, it will pass the filter. This method of filtering will not automatically respect <code><a href="#interfaces-FileConfig-aliases">aliases</a></code>.</p>

					<p>The function returned by <code>by</code> can be passed to <code>Array.prototype.filter</code>, but it also has two methods that can allow for chaining to create more complex filter functions. These methods both have the same signature as <code>by</code>, and are called <code>andBy</code> and <code>orBy</code>.</p>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-filtering" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									NAME: 'A',
									COUNTRY: 'B',
									POP: 'C',
									CAPITAL: 'D',
									PUBLIC_TRANSPORT: 'E',
									MAYOR_2012: 'F',
									MAYOR_2018: 'G',
								},

								headerRows: 1,
								footerRows: 1,

								aliases: [
									['Aotearoa', 'New Zealand'],
								],
								transform: {
									POP: analyser.transformers.number,
									CAPITAL: analyser.transformers.booleanCustom('true', '\'No\''),
									PUBLIC_TRANSPORT: analyser.transformers.array(','),
									MAYOR_2018: analyser.transformers.array(','),
									MAYOR_2012: analyser.transformers.array(','),
								},
							});

							const { rows, cols, by } = await analyser.loadFile(fileConfig);

							const germanCities = rows.filter(
								by(cols.COUNTRY, 'Germany')
							);
							log('German cities:', germanCities.getCol(cols.NAME));

							const largeCitiesWithTrainOrFerry = rows.filter(
								by(cols.POP, (population) => population > 1000)
								.andBy(cols.PUBLIC_TRANSPORT, ['Train', 'Ferry'])
							);
							log('Large cities with train or ferry services:', largeCitiesWithTrainOrFerry.getCol(cols.NAME));

							const largeOrCapitalCities = rows.filter(
								by(cols.CAPITAL, true)
								.orBy(cols.POP, (population) => population > 1000)
							);
							log('Large or capital cities:', largeOrCapitalCities.getCol(cols.NAME));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-usage-filtering"></samp>
					</div>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="usage-grouping">
				<div class="content">
					<h2 id="usage-grouping">Grouping <a class="anchor" href="#usage-grouping"></a></h2>

					<p>The <code><a href="#interfaces-DataConfig">DataConfig</a></code> object exposes a function called <code><a href="#interfaces-DataConfig-group">group</a></code>, which is used for grouping the <code><a href="#interfaces-AnalyserRows">AnalyserRows</a></code> exposed in the <code>DataConfig</code>'s <code><a href="#interfaces-DataConfig-rows">rows</a></code> property.</p>

					<p>These groups can then be used to produce summaries of the data, which in turn can be used to create <a href="#usage-graphs">graphs</a>.</p>

					<p>The <code>group</code> function effectively has any <a href="#interfaces-FileConfig-aliases">aliases</a> baked in, with any values in a set of aliases treated as though they were the first value in the set. That first value does not need to appear in the data, but it will always be used in any <code><a href="#interfaces-AnalyserGroup">AnalyserGroup</a></code> created by <code>group</code>.</p>

					<p><code>group</code> has three overrides:</p>

					<code>(rows: <a href="#interrfaces-AnalyserRows">AnalyserRows</a>, colNum: number): <a href="#interfaces-AnalyserGroup">AnalyserGroup</a></code><br />
					<code>(rows: <a href="#interrfaces-AnalyserRows">AnalyserRows</a>, colNum: number, numGroups: number, right: boolean = true): <a href="#interfaces-AnalyserGroup">AnalyserGroup</a></code><br />
					<code>(rows: <a href="#interrfaces-AnalyserRows">AnalyserRows</a>, colNum: number, splitPoints: number[], right: boolean = true): <a href="#interfaces-AnalyserGroup">AnalyserGroup</a></code>

					<p>When grouping by discrete data, the first override should always be used. The other two overrides provide different methods for dividing continuous data into groups.</p>

					<p>If the <code>numGroups</code> argument is provided with a number, <code>group</code> will split the continuous data into that many groups of the same range. For example, if the data ranges from <code>0</code> to <code>100</code> and the <code>numGroups</code> argument is <code>5</code>, the first group would contain data from <code>0</code> to <code>20</code>.</p>

					<p>Otherwise, the <code>splitPoints</code> argument can be provided with an array of numbers, which will be used as the points where the groups will be split.</p>

					<p>For both of the continuous data overloads, there is an optional <code>right</code> argument that determines which end of a group is open. If <code>right</code> is <code>true</code> (its default value), then values equal to the upper limit of a group will be included. Otherwise, values equal to a group's lower limit will be included instead.</p>

					<p>However, the first and last group will always include values at their outer boundaries, since they will be determined based on the minimum and maximum values in the data set.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-grouping" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								NAME: 'A',
								COUNTRY: 'B',
								POP: 'C',
							},

							headerRows: 1,
							footerRows: 1,

							aliases: [
								['Aotearoa', 'New Zealand'],
							],
							transform: {
								POP: analyser.transformers.number,
							},
						});

						const { rows, cols, group } = await analyser.loadFile(fileConfig);

						const groupByCountry = group(rows, cols.COUNTRY);
						log('Grouped by country:');
						groupByCountry.forEach((groupRows, name) => log(name, groupRows.length));

						const groupByPopulation = group(rows, cols.POP, 5);
						log('Grouped by population:');
						groupByPopulation.forEach((groupRows, name) => log(name, groupRows.length));

						const groupByPopulationCustom = group(rows, cols.POP, [50, 200, 1000]);
						log('Grouped by population (custom split points):');
						groupByPopulationCustom.forEach((groupRows, name) => log(name, groupRows.length));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-usage-grouping"></samp>
				</div>
			</section>

			<section>
				<div class="content">
					<h2 id="usage-graphs">Graphs <a class="anchor" href="#usage-graphs"></a></h2>

					<p>Once data has been processed and analysed, Analyser is able to produce some forms of graphs from numerical summaries of data created through <code><a href="#interfaces-AnalyserGroup-summarise">AnalyserGroup.summarise()</a></code>.</p>

					<p>These graphs are created using HTML and some SVG, and rely on Analyser's CSS to make them appear correctly. They are designed to be reasonably accessible to screen reader users. The base CSS for them is written in Sass, and can be found in <code>~/docs/assets/scss/_chart.scss</code>.</p>

					<p>The methods Analyser uses to create graphs rely on some common interfaces for configuring their labels and axes.
				</div>

				<section>
					<div class="content">
						<h3 id="usage-graphs-ChartOptions">ChartOptions</h3>

						<code class="code--block js-codebook__inert">
							<a href="#usage-graphs-ChartOptions-title">title</a>?: string,
							<a href="#usage-graphs-ChartOptions-legend">legend</a>?: boolean,

							<a href="#usage-graphs-ChartOptions-colours">colours</a>?: Record&lt;string, string&gt;,

							<a href="#usage-graphs-ChartOptions-x">x</a>?: <a href="#usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative</a> | <a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a>,
							<a href="#usage-graphs-ChartOptions-y">y</a>?: <a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a>,

							<a href="#usage-graphs-ChartOptions-stacked">stacked</a>?: boolean,
						</code>

						<p>All charts share a common <code>ChartOptions</code> interface, with only minor differences between chart types.</p>
					</div>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-title"><code>title</code> <a class="anchor" href="#usage-graphs-ChartOptions-title"></a></h4>
						</div>

						<p>The title to display above the graph.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-legend"><code>legend</code> <a class="anchor" href="#usage-graphs-ChartOptions-legend"></a></h4>
						</div>

						<p>Whether or not a legend should be displayed. The position of the legend can be controlled via CSS.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-colours"><code>colours</code> <a class="anchor" href="#usage-graphs-ChartOptions-colours"></a></h4>
						</div>

						<p>An object representing what colours each group of data included on the graph should be. The property names of this object should line up with the names of the summaries that have been created.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-x"><code>x</code> <a class="anchor" href="#usage-graphs-ChartOptions-x"></a></h4>
						</div>

						<p>The configuration options for a graph's x axis might be quantitative or qualitative, depending on the type of chart. This option uses either the <code><a href="#usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative</a></code> or <code><a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a></code> interface depending on what is required by the graph.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-y"><code>y</code> <a class="anchor" href="#usage-graphs-ChartOptions-y"></a></h4>
						</div>

						<p>A graph's y axis is always configured using the <code><a href="usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a></code> interface.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-stacked"><code>stacked</code> <a class="anchor" href="#usage-graphs-ChartOptions-stacked"></a></h4>

							<p>Analyser's <a href="#usage-graphs-bar">bar graphs</a> support the <code>stacked</code> property to generate a stacked bar chart.</p>
						</div>
					</section>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative <a class="anchor" href="#usage-graphs-AxisOptionsQualitative"></a></h3>

					<code class="code--block js-codebook__inert">
						{
							<a href="#usage-graphs-AxisOptionsQualitative-title">title</a>?: string,

							<a href="#usage-graphs-AxisOptionsQualitative-numberFormat">numberFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> | ((value: number) => string),
							<a href="#usage-graphs-AxisOptionsQualitative-dateFormat">dateFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> | ((value: Date) => string),

							<a href="#usage-graphs-AxisOptionsQualitative-labels">labels</a>?: string[],
						}
					</code>
				</div>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-title"><code>title</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-title"></a></h4>

						<p>The axis title.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-numberFormat"><code>numberFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-numberFormat"></a></h4>

						<p>If any of the axis's values are numbers, the <code>numberFormat</code> property will determine how those numbers are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> object or by passing a custom function that takes in a number and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-dateFormat"><code>dateFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-dateFormat"></a></h4>

						<p>If any of the axis's values are dates, the <code>dateFormat</code> property will determine how those dates are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> or by passing a custom function that takes in a <code>Date</code> and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-labels"><code>labels</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-labels"></a></h4>

						<p>The labels to display on the axis. If absent, these labels will be gathered automatically from the <a href="#interfaces-AnalyserGroup-summarise">summary</a> used to create the graph.</p>

						<p>This property can be used to customise the order of the data, and to exclude certain items from appearing on the graph. If a label that doesn't exist in the data is added, empty data will be generated to be used for it.</p>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative"></a></h3>

					<code class="code--block js-codebook__inert">
						{
							<a href="#usage-graphs-AxisOptionsQuantitative-title">title</a>?: string,

							<a href="#usage-graphs-AxisOptionsQuantitative-numberFormat">numberFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> | ((value: number) => string),
							<a href="#usage-graphs-AxisOptionsQuantitative-dateFormat">dateFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> | ((value: Date) => string),

							<a href="#usage-graphs-AxisOptionsQuantitative-values">values</a>?: number | number[] | Date[],
							<a href="#usage-graphs-AxisOptionsQuantitative-gridlines">gridlines</a>?: number | number[] | Date[],

							<a href="#usage-graphs-AxisOptionsQuantitative-max">max</a>?: number | 'auto',
							<a href="#usage-graphs-AxisOptionsQuantitative-min">min</a>?: number | 'auto',
						}
					</code>
				</div>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-title"><code>title</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-title"></a></h4>

						<p>The axis title.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-numberFormat"><code>numberFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-numberFormat"></a></h4>

						<p>If any of the axis's values are numbers, the <code>numberFormat</code> property will determine how those numbers are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> object or by passing a custom function that takes in a number and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-dateFormat"><code>dateFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-dateFormat"></a></h4>

						<p>If any of the axis's values are dates, the <code>dateFormat</code> property will determine how those dates are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> or by passing a custom function that takes in a <code>Date</code> and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-values"><code>values</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-values"></a></h4>

						<p>This property can be used to specify the values that appear on a quantitative axis.</p>

						<p>If it is a <code>number</code>, Analyser will generate that many equally spaced values between the minimum and maximum values.</p>

						<p>If it is a <code>number[]</code>, Analyser will display each of the numbers in the array on the axis and no other values.</p>

						<p>Note that, when using the <code>number</code> form, the minimum value <em>does not count</em> against the number of values. This is for ease of use when working with data with a baseline at <code>0</code>, so a number of values that is a divisor of the maximum value (or, for data without a <code>0</code> minimum, a divisor of the range of the data) that will cause integer values to be generated.</p>

						<p>This allows for easier generation of values in many circumstances, for example specifying <code>values</code> of <code>5</code> for an axis that goes from <code>0</code> to <code>5000</code> will result in a value at each interval of <code>1000</code>.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-gridlines"><code>gridlines</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-gridlines"></a></h4>

						<p>The <code>gridlines</code> property works the same as the <code><a href="#usage-graphs-AxisOptionsQualitative-values">values</a></code> property, except instead of generating values to display on the axis it generates gridlines to extend from the axis.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-max"><code>max</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-max"></a></h4>

						<p>Setting <code>max</code> to a <code>number</code> will override the maximum value of the axis.</p>

						<p>Alternately, setting <code>max</code> to the string <code>'auto'</code> will allow Analyser to try to intelligently determine the maximum value. It does this by rounding the maximum value in the data up to the nearest multiple of the largest power of 10 beneath it. So, for example, <code>13</code> would round up to <code>20</code> whereas <code>723</code> would round up to <code>800</code>.</p>

						<p>If both <code>max</code> and <code><a href="#usage-graphs-AxisOptionsQualitative-min">min</a></code> are absent, the maximum and minimum values in the data will be used. However, if either one of them is set then the other will default to <code>'auto'</code> behaviour.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-min"><code>min</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-min"></a></h4>

						<p>Like the <code><a href="#usage-graphs-AxisOptionsQualitative-max">max</a></code> property, <code>min</code> can be used to override the minimum value of an axis. If set to <code>'auto'</code> Analyser will determine a sensible minimum value in the same way as with <code>max</code>, except it will instead start with the minimum value in the data and round down.</p>
					</div>
				</section>
			</section>

			<section class="js-codebook__set" data-codebook-set="usage-graphs-bar">
				<div class="content">
					<h3 id="usage-graphs-bar">bar <a class="anchor" href="#usage-graphs-bar"></a></h3>

					<code><span class="todo">bar(summary: AnalyserSummary, options?: BarChartOptions)</span></code>

					<p>Bar charts have a qualitative x axis, so use the <code><a href="#usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative</a></code> interface for configuring their x axis.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-graphs-bar" data-codebook-html="html-usage-graphs-bar" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								COUNTRY: 'B',
								POPULATION: 'C',
							},
							headerRows: 1,
							footerRows: 1,
							transform: {
								POPULATION: analyser.transformers.number,
							},
							aliases: [
								['Aotearoa', 'New Zealand'],
							],
						});

						const { rows, cols, group } = await analyser.loadFile(fileConfig);

						const countryGroup = group(rows, cols.COUNTRY);

						const meanPopulationSummary = countryGroup.summarise({
							mean: (rows) => analyser.statistics.mean(rows.getCol(cols.POPULATION)),
						});
						log('Mean city population by country:', meanPopulationSummary);

						const barChartHtml = analyser.bar(meanPopulationSummary, {
							title: 'Mean city population',
							legend: true,

							colours: {
								'mean': '#ff0000',
							},

							x: {
								title: 'Country',

								labels: ['Australia', 'Germany', 'Aotearoa'],
							},
							y: {
								title: 'Population',

								numberFormat: new Intl.NumberFormat('en-nz', { useGrouping: 'always', roundingIncrement: 1 }),

								values: 5,
								min: 0,
							},

							stacked: true,
						});

						html(barChartHtml);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<div class="docs-example__html" id="html-usage-graphs-bar"></div>

					<samp class="docs-example__log js-docs__log" id="log-usage-graphs-bar"></samp>
				</div>
			</section>

			<section>
				<div class="content">
					<h3 id="usage-graphs-line">line <a class="anchor" href="#usage-graphs-line"></a></h3>

					<code><span class="todo">line(summary: AnalyserSummary, options?: LineChartOptions)</span></code>

					<p>Line charts have a quantitative x axis, so use the <code><a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a></code> interface for configuring their x axis.</p>
				</div>

				<div class="docs-example js-docs__example todo">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-graphs-line" data-codebook-html="html-usage-graphs-line" contenteditable spellcheck="false"></script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<div class="docs-example__html" id="html-usage-graphs-line"></div>

					<samp class="docs-example__log js-docs__log" id="log-usage-graphs-line"></samp>
				</div>
			</section>
		</section>

		<section>
			<div class="content">
				<h2 id="interfaces">Interfaces <a class="anchor" href="#interfaces"></a></h2>
			</div>

			<section class="js-codebook__set" data-codebook-set="FileConfig">
				<div class="content">
					<h3 id="interfaces-FileConfig">FileConfig <a class="anchor" href="#interfaces-FileConfig"></a></h3>

					<code class="code--block js-codebook__inert">
					{
						<a href="#interfaces-FileConfig-path">path</a>: string,
						<a href="#interfaces-FileConfig-cols">cols</a>: Record&lt;string, string | number&gt;,

						<a href="#interfaces-FileConfig-headerRows">headerRows</a>?: number,
						<a href="#interfaces-FileConfig-footerRows">footerRows</a>?: number,
						<a href="#interfaces-FileConfig-ignoreRows">ignoreRows</a>?: (row: string[], cols: Record&lt;string, number&gt;) => boolean,

						<a href="#interfaces-FileConfig-aliases">aliases</a>?: string[][],
						<a href="#interfaces-FileConfig-transform">transform</a>?: Record&lt;string, <a href="#interfaces-TransformerFn">TransformerFn</a>&gt;,
					}
					</code>

					<p>A <code>FileConfig</code> object tells Analyser everything it needs to know to process a file, including where it is and what sort of contents to expect.</p>

					<p>A <code>FileConfig</code> object can be created directly, but because of how TypeScript's generic type inference is limited to functions it is recommended to use the <code><a href="#methods-fileConfig">fileConfig</a></code> method provided when working with TypeScript in order to improve both type checking when creating the object and autocompletion prompts for column names after the file has been read.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-FileConfig" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								NAME: 'A',
								COUNTRY: 'B',
								POP: 'C',
								CAPITAL: 'D',
								PUBLIC_TRANSPORT: 'E',
								MAYOR_2012: 'F',
								MAYOR_2018: 'G',
							},

							headerRows: 1,
							footerRows: 1,

							aliases: [
								['Aotearoa', 'New Zealand'],
							],
							transform: {
								POP: analyser.transformers.number,
								CAPITAL: analyser.transformers.booleanCustom('true', '\'No\''),
								PUBLIC_TRANSPORT: analyser.transformers.array(','),
								MAYOR_2018: analyser.transformers.array(','),
								MAYOR_2012: analyser.transformers.array(','),
							},
						});

						const { rows } = await analyser.loadFile(fileConfig);

						log('First row:', rows[0]);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-FileConfig"></samp>
				</div>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-path"><code>path</code> <a class="anchor" href="#interfaces-FileConfig-path"></a></h4>

						<p>This string is used to <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch" target="_blank">fetch</a> the CSV file to be processed.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-cols"><code>cols</code> <a class="anchor" href="#interfaces-FileConfig-cols"></a></h4>

						<p>The <code>cols</code> object specifies the names of each column to be processed. Not every column present in the file needs to be specified, but you should specify each column that you wish to access.</p>

						<p>If the value assigned to a column here is a string, it will be passed through <code><a href="#methods-getColNumber">getColNumber</a></code> to convert it into a number.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-headerRows"><code>headerRows</code> <a class="anchor" href="#interfaces-FileConfig-headerRows"></a></h4>

						<p>An optional integer to specify how many rows at the start of the CSV file should be ignored, such as header rows.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-footerRows"><code>footerRows</code> <a class="anchor" href="#interfaces-FileConfig-footerRows"></a></h4>

						<p>An optional integer to specify how many rows at the end of the CSV file should be ignored, such as total rows.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-ignoreRows"><code>ignoreRows</code> <a class="anchor" href="#interfaces-FileConfig-ignoreRows"></a></h4>

						<p>An optional function that should return <code>true</code> when it's passed any row that should be ignored. These rows are removed before any of the <a href="#interfaces-FileConfig-transformers">transformers</a> are applied, so all elements of the row at this point will be strings. An <code>ignoreRows</code> function will also have access to the transformed <code>cols</code> object, so it can be used to index the <code>row</code> argument.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-aliases"><code>aliases</code> <a class="anchor" href="#interfaces-FileConfig-aliases"></a></h4>

						<p>When <a href="#usage-filtering">filtering</a> and <a href="#usage-grouping">grouping</a> data, it can be useful to treat different values as if they were the same, particularly if the source data is inconsistent.</p>

						<p>Each element in the <code>aliases</code> array is an array of strings, where each string is treated as being equal to each other string in the array when filtering the data.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-transform"><code>transform</code> <a class="anchor" href="#interfaces-FileConfig-transform"></a></h4>

						<p>The <code>transform</code> object instructs Analyser on what type of data each row contains.</p>

						<p>It can have a property for each property in the <code>cols</code> object, and the value of each of these properties must match the <code><a href="#interfaces-TransformerFn">TransformerFn</a></code> interface.</p>

						<p>Any column without a transformer function will be treated as an array of strings.</p>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-DataConfig">DataConfig <a class="anchor" href="#interfaces-DataConfig"></a></h3>

					<code class="code--block js-codebook__inert">
						{
							rows: <a href="#interfaces-AnalyserRows">AnalyserRows</a>,

							cols: Record&lt;string, number&gt;,
							addedCols: Record&lt;string, number&gt;,

							by: <a href="#usage-filtering">Filterer</a>,
							group: <a href="usage-grouping">Grouper</a>,

							aliases?: string[][],
						}
					</code>

					<p>A <code>DataConfig</code> object is returned by <code><a href="#methods-loadFile">loadFile</a></code> when its <code>Promise</code> resolves. It exposes several properties that can be used to read and analyse the processed data.</p>

					<section>
						<div class="content">
							<h4 id="interfaces-DataConfig-rows"><code>rows</code> <a class="anchor" href="#interfaces-DataConfig-rows"></a></h4>

							<p>The <code>rows</code> object is an <code><a href="#interfaces-AnalyserRows">AnalyserRows</a></code>, which contains all the data processed by <code><a href="#methods-loadFile">loadFile</a></code>.</p>
						</div>
					</section>

					<section>
						<div class="content">
							<h4 id="interfaces-DataConfig-cols"><code>cols</code> <a class="anchor" href="#interfaces-DataConfig-cols"></a></h4>

							<p>The <code>cols</code> object maps the column names specified in your <code><a href="#interfaces-FileConfig">FileConfig</a></code> configuration, and maps them onto numbers used to index elements of the <code>rows</code> object.</p>
						</div>
					</section>

					<section>
						<div class="content">
							<h4 id="interfaces-DataConfig-addedCols"><code>addedCols</code> <a class="anchor" href="#interfaces-DataConfig-addedCols"></a></h4>

							<p>The <code>addedCols</code> object is available as a helper when working with TypeScript. It is intended to store the indexes of new columns created via <code><a href="#interfaces-AnalyserRows-addCol">addCol</a></code>.</p>

							<p>This is possible with the <code>cols</code> object in JavaScript, but in TypeScript it has a more specific type to allow configured column names to be autocompleted, so the more generic <code>addedCols</code> object is available to allow storage of new columns without losing that autocompletion of <code>cols</code>.</p>
						</div>
					</section>

					<section>
						<div class="content">
							<h4 id="interfaces-DataConfig-by"><code>by</code> <a class="anchor" href="#interfaces-DataConfig-by"></a></h4>

							<p>The <code>by</code> function is used for <a href="#usage-filtering">filtering</a>, with any specified aliases baked in.</p>
						</div>
					</section>

					<section>
						<div class="content">
							<h4 id="interfaces-DataConfig-group"><code>group</code> <a class="anchor" href="#interfaces-DataConfig-group"></a></h4>

							<p>The <code>group</code> function is used for <a href="#usage-grouping">grouping</a>, with any specified aliases based in.</p>
						</div>
					</section>

					<section>
						<div class="content">
							<h4 id="interfaces-DataConfig-aliases"><code>aliases</code> <a class="anchor" href="#interfaces-DataConfig-aliases"></a></h4>

							<p>If the <code><a href="#interfaces-FileConfig">FileConfig</a></code> had its <code><a href="#interfaces-FileConfig-aliases">aliases</a></code> property specified, a copy is also made available here.</p>
						</div>
					</section>
				</div>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-AnalyserRows">AnalyserRows <a class="anchor" href="#interfaces-AnalyserRows"></a></h3>

					<p>The <code>AnalyserRows</code> class extends the native <code>Array</code> class by adding two additional methods. Aside from these methods, it can be treated the same as any regular <code>Array</code>, for example by calling methods such as <code>Array.prototype.filter</code>.</p>

					<p>An <code>AnalyserRows</code> object is exposed on the <code><a href="#interfaces-DataConfig">DataConfig</a></code> object returned by <code><a href="#methods-loadFile">loadFile</a></code>, and is typically used alongside the <code><a href="#interfaces-DataConfig-cols">cols</a></code> object exposed alongside it.</p>
				</div>

				<section class="js-codebook__set" data-codebook-set="interfaces-AnalyserRows-getCol">
					<div class="content">
						<h4 id="interfaces-AnalyserRows-getCol">getCol <a class="anchor" href="#interfaces-AnalyserRows-getCol"></a></h4>

						<code>getCol(colNum: number): unknown[]</code>

						<p>The <code>getCol</code> function returns one of an <code>AnalyserRows</code>'s columns as an array. Its return value is typed as <code>unknown[]</code>, so when working with TypeScript you will need to apply typeguards or use type assertions based on the <a href="#usage-transformers">transformers</a> you used when processing the data.</p>

						<p>Typically, its <code>colNum</code> argument will be retrieved from either the <code><a href="#interfaces-DataConfig-cols">cols</a></code> or the <code><a href="#interfaces-DataConfig-addedCols">addedCols</a></code> properties of the <code><a href="#interfaces-DataConfig">DataConfig</a></code> where the <code>AnalyserRows</code> originated.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-interfaces-AnalyserRows-getCol" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									NAME: 'A',
									POPULATION: 'C',
								},
								headerRows: 1,
								footerRows: 1,
								transform: {
									POPULATION: analyser.transformers.number,
								}
							});

							const { rows, cols } = await analyser.loadFile(fileConfig);
							log(rows.getCol(cols.NAME));
							log(rows.getCol(cols.POPULATION));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-interfaces-AnalyserRows-getCol"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="interfaces-AnalyserRows-addCol">
					<div class="content">
						<h4 id="interfaces-AnalyserRows-addCol">addCol <a class="anchor" href="#interfaces-AnalyserRows-addCol"></a></h4>

						<code>addCol&lt;T&gt;(creator: (row: unknown[], index: number) => T): number</code><br />
						<code>addCol&lt;T&gt;(newRow: T[]): number</code><br />

						<p>The <code>addCol</code> method is used to add a new row to an <code>AnalyserRows</code> object.</p>

						<p>To ensure the <code>AnalyserRows</code> continues to contain rows all of the same length, it is recommended that this method only be called on an original <code>AnalyserRows</code> object, not on one that has been created by <a href="#usage-filtering">filtering</a>.</p>

						<p>There are two methods of calling <code>addCol</code>. The primary method relies on a <code>creator</code> function, which works similarly to a function passed to <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">Array.prototype.map</a></code>. This <code>creator</code> function takes a single row (as an array of cells) and that row's index, and creates the value that row should have in the new column.</p>

						<p>The second method of calling <code>addCol</code> simply passes a newly constructed column in entirely, as an array. This array must be of the same length as the <code>AnalyserRows</code> being added to.</p>

						<p>Regardless which was called, <code>addCol</code> returns the index of the new column. This can be stored in the <code><a href="#interfaces-DataConfig-cols">cols</a></code> object or, when working with TypeScript, in the <code><a href="#interfaces-DataConfig-addedCols">addedCols</a></code>.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-interfaces-AnalyserRows-addCol" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									POP_THOUSANDS: 'C',
									PUBLIC_TRANSPORT: 'E',
								},
								headerRows: 1,
								footerRows: 1,
								transform: {
									POP_THOUSANDS: analyser.transformers.number,
									PUBLIC_TRANSPORT: analyser.transformers.array(','),
								}
							});

							const { rows, cols, addedCols } = await analyser.loadFile(fileConfig);

							addedCols.POP = rows.addCol((row) => row[cols.POP_THOUSANDS] * 1000);
							log(rows.getCol(addedCols.POP));

							const hasTrainCol = rows.map((row) => row[cols.PUBLIC_TRANSPORT].includes('Train'));
							addedCols.HAS_TRAIN = rows.addCol(hasTrainCol);
							log(rows.getCol(addedCols.HAS_TRAIN));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-interfaces-AnalyserRows-addCol"></samp>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-AnalyserGroup">AnalyserGroup <a class="anchor" href="#interfaces-AnalyserGroup"></a></h3>

					<p>The <code>AnalyserGroup</code> class extends the native <code>Map</code> class to add an additional method. It is primarily intended to be interacted with only through this method.</p>
				</div>

				<section class="js-codebook__set" data-codebook-set="interfaces-AnalyserGroup-summarise">
					<div class="content">
						<h4 id="interfaces-AnalyserGroup-summarise">summarise <a class="anchor" href="#interfaces-AnalyserGroup-summarise"></a></h4>

						<code>summarise(summarisers?: Record&lt;string, (rows: AnalyserRows, groupName: unknown) => unknown&gt;): unknown[][]</code>

						<p>The <code>summarise</code> method converts an <code>AnalyserGroup</code> into a specially formatted 2D array made for easy viewing. The first row is a header row, giving the name of each summary, and the first column gives the name of each group from the <code>AnalyserGroup</code> used to create it. The other cells each contain a particular summary of that group.</p>

						<p>By default, if not passed a <code>summarisers</code> argument, the default "Count" summary will be used, which calculates the number of rows in each group.</p>

						<p>More complex summaries can be passed to the <code>summarise</code> function as an object where each property is a function that takes an <code>AnalyserRows</code> and the name of its group and produces some result.</p>

						<p>Summaries that all produce numeric results can then be used to <a href="#usage-graphs">create graphs</a>.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-interfaces-AnalyserGroup-summarise" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									COUNTRY: 'B',
									POPULATION: 'C',
								},
								headerRows: 1,
								footerRows: 1,
								transform: {
									POPULATION: analyser.transformers.number,
								},
								aliases: [
									['Aotearoa', 'New Zealand'],
								],
							});

							const { rows, cols, group } = await analyser.loadFile(fileConfig);

							const countryGroup = group(rows, cols.COUNTRY);

							const countSummary = countryGroup.summarise();
							log('Count of cities by country:', countSummary);

							const meanPopulationSummary = countryGroup.summarise({
								mean: (rows, groupName) => analyser.statistics.mean(rows.getCol(cols.POPULATION)),
							});
							log('Mean city population by country:', meanPopulationSummary);
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-interfaces-AnalyserGroup-summarise"></samp>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-TransformerFn">TransformerFn <a class="anchor" href="#interfaces-TransformerFn"></a></h3>

					<code>TransformerFn&lt;T&gt; (value: string, locationIdentifier?: string): T extends unknown[] ? T : (T | null)</code>

					<p>Transformer functions are used to convert strings in a CSV file into typed data that can be further analysed.</p>

					<p>For most types, you can use one of the <a href="#usage-transformers">transformers</a> provided by Analyser.</p>

					<p>For more complex data, though, you may need to create a custom transformer function. These functions always take a string argument and return either:</p>

					<ul>
						<li>An array, which may be empty</li>
						<li>A non-array value, or null if the data did not match the anticipated format</li>
					</ul>

					<p>In some circumstances, Analyser will also pass a <code>locationIdentifier</code> string that can be used when logging an error in order to identify where in the data that error occurred.</p>
				</div>
			</section>
		</section>

		<section>
			<div class="content">
				<h2 id="methods">Methods <a class="anchor" href="#methods"></a></h2>
			</div>

			<section class="js-codebook__set" data-codebook-set="methods-fileConfig">
				<div class="content">
					<h3 id="methods-fileConfig">fileConfig <a class="anchor" href="#methods-fileConfig"></a></h3>

					<code>fileConfig(fileConfig: <a href="#interfaces-FileConfig">FileConfig</a>): <a href="#interfaces-FileConfig">FileConfig</a></code>

					<p>This function doesn't do anything itself, it just returns the object passed to it. However, when working with TypeScript using a function in this way is necessary in order for the TypeScript compiler to correctly infer the generic string type based on the specified column names for the data.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-fileConfig" contenteditable spellcheck="false">
						// Passing this object through analyser.fileConfig ensures
						// TypeScript would infer its type as FileConfig<'CITY'|'COUNTRY'>
						// This allows column names to be autocompleted after
						// the file is loaded, unlike using FileConfig<string>

						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								CITY: 'A',
								COUNTRY: 'B',
							},
						});

						log(fileConfig);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-fileConfig"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="methods-loadFile">
				<div class="content">
					<h3 id="methods-loadFile">loadFile <a class="anchor" href="#methods-loadFile"></a></h3>

					<code>loadFile(fileConfig: <a href="#interfaces-FileConfig">FileConfig</a>): Promise&lt;<a href="#interfaces-DataConfig">DataConfig</a>&gt;</code>

					<p>The <code>loadFile</code> method loads a single CSV file configured with a <a href="#interfaces-FileConfig">FileConfig</a> object.</p>

					<p>If the file is loaded and processed successfully, the <code>Promise</code> returned by <code>loadFile</code> will resolve to a <a href="#interfaces-DataConfig">DataConfig</a> object.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-loadFile" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								CITY: 'A',
								COUNTRY: 'B',
							},
						});

						const dataConfig = await analyser.loadFile(fileConfig);

						log(Object.keys(dataConfig));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-loadFile"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="methods-getColNumber">
				<div class="content">
					<h3 id="methods-getColNumber">getColNumber <a class="anchor" href="#methods-getColNumber"></a></h3>

					<code>getColNumber(colName: number | string): number | null</code>

					<p><code>getColNumber</code> converts strings of the format used as column headings by spreadsheet software like Microsoft Excel into 0-indexed numbers.</p>

					<p>For example, <code>'A'</code> would be converted to <code>0</code>, whereas <code>'ZE'</code> would be converted to <code>680</code>. This is case insensitive.</p>

					<p>If a positive integer is passed into <code>getColNumber</code>, it will be returned unchanged.</p>

					<p>Any other number, or any string containing an invalid character, will instead be converted to <code>null</code>.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-getColNumber" contenteditable spellcheck="false">
						log(`'A': ${analyser.getColNumber('A')}`);
						log(`'ZE': ${analyser.getColNumber('ZE')}`);
						log(`0: ${analyser.getColNumber(0)}`);
						log(`12: ${analyser.getColNumber(12)}`);
						log(`-1: ${analyser.getColNumber(-1)}`);
						log(`1.5: ${analyser.getColNumber(1.5)}`);
						log(`'invalid string': ${analyser.getColNumber('invalid string')}`);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-getColNumber"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="methods-getColNumbers">
				<div class="content">
					<h3 id="methods-getColNumbers">getColNumbers <a class="anchor" href="#methods-getColNumbers"></a></h3>

					<code>getColNumbers(colsConfig: Record&lt;string, number | string&gt;): Record&lt;string, number&gt;</code>

					<p><code>getColNumbers</code> takes in a map of column names like the one that can be provided as part of a <code><a href="#interfaces-FileConfig">FileConfig</a></code> object, and transforms each property according to the same rules as <code><a href="#methods-getColNumber">getColNumber</a></code>.</p>

					<p>If any of those transformations results in <code>null</code>, the property will be removed from the result.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-getColNumbers" contenteditable spellcheck="false">
						log(analyser.getColNumbers({
							'A': 'A',
							'ZE': 'ZE',
							0: 0,
							12: 12,
							'-1': -1,
							'1.5': 1.5,
							'invalid string': 'invalid string',
						}));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-getColNumbers"></samp>
				</div>
			</section>
		</section>

		<section>
			<div class="content">
				<h2 id="statistics">Statistical helper functions <a class="anchor" href="#statistics"></a></h2>

				<p>Analyser provides some statistical helper functions. These functions can be accessed either via <code>analyser.statistics</code> or by importing them from the <code>@cipscis/analyser/statistics</code> submodule:</p>

				<code>import { statistics } from '@cipscis/analyser';</code><br />
				<code>import * as statistics from '@cipscis/analyser/statistics';</code>
			</div>

			<section class="js-codebook__set" data-codebook-set="statistics-sum">
				<div class="content">
					<h3 id="statistics-sum">sum <a class="anchor" href="#statistics-sum"></a></h3>

					<code>sum(...arr: number[] | [number[]]): number</code>

					<p>The <code>sum</code> method sums an array of numbers, either taking them all as a single array argument or as many number arguments.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-statistics-sum" contenteditable spellcheck="false">
						log(analyser.statistics.sum(1, 2, 3, 4, 5));
						log(analyser.statistics.sum([1, 2, 3, 4, 5]));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-statistics-sum"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="statistics-mean"">
				<div class="content">
					<h3 id="statistics-mean">mean <a class="anchor" href="#statistics-mean"></a></h3>

					<code>mean(...arr: number[] | [number[]]): number</code>

					<p>The <code>mean</code> method returns the mean of an array of numbers, either taking them all as a single array argument or as many number arguments.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-statistics-mean" contenteditable spellcheck="false">
						log(analyser.statistics.mean(1, 2, 3, 4, 5));
						log(analyser.statistics.mean([1, 2, 3, 4, 5]));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-statistics-mean"></samp>
				</div>
			</section>
		</section>
	</main>
</body>

</html>
