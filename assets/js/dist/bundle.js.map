{"version":3,"sources":["webpack://analyser/./node_modules/csv/csv.js","webpack://analyser/./analyser.js","webpack://analyser/./docs/assets/js/src/main.js"],"names":["stringify","parse","csv","data","options","transpose","sanitise","rows","_shape","_escape","_join","maxLength","reduce","row","Math","max","length","iMax","jMax","i","j","iRow","iCol","cellValue","push","match","replace","join","csvString","_tokenise","_validate","mapper","map","tokens","inQuote","wasQuote","tokenStart","char","comma","quote","newline","eof","Error","token","substring","rowLength","AnalyserRows","Array","sourceArray","super","this","colNum","col","colIndex","entries","processFn","cols","derivedValues","apply","callback","derivedCol","getDerivedCol","arguments","addCol","arraySeparator","newRow","colName","cell","table","createSubTable","Analyser","_convertTableToString","aliasList","summary","values","value","_groupColSummaryByAliases","labels","colSummary","getColSummary","dataSeries","index","indexOf","parseInt","headerCol","headerAliases","varCol","varAliases","undefined","headerSummary","varSummary","aliases","HEADERS","VARS","by","_getAliasFilters","comparisonSummary","filter","_extractValue","andBy","getComparisonSummary","loadFile","async","fileConfigArr","promises","fileConfig","_loadFile","Promise","all","response","fetch","path","ok","text","_processData","status","headerRows","footerRows","arrayCols","enumsMap","uniqueCols","dataConfig","splice","trim","split","defaultColValues","defaultCols","enums","_buildEnums","config","collect","includes","enumCol","_collectEnums","concat","enumsArr","combineData","dataConfigs","string","_extractNumber","val","parseFloat","toFixed","filterFn","_applyFilter","orBy","_extendFilter","newFilterFn","Function","cellValues","_matchAlias","aliasSuperset","aliasSet","getColNumber","Number","isInteger","String","alphabet","rowNumber","upperColName","toUpperCase","charIndex","pow","getColNumbers","newCols","key","useKeys","cellSeparatorOption","rowSeparatorOption","cellSeparator","rowSeparator","tableString","addCell","cellString","endLine","substr","firstRowComplete","rowName","isFirstRow","newSummary","inAlias","fileInfoA","NAME","COUNTRY","POPULATION","CAPITAL","PUBLIC_TRANSPORT","MAYOR_2012","MAYOR_2018","fileInfoB","fileInfoC","YEAR","cityData","cityData2","cityData3","console","log","pop","analyse"],"mappings":"mBAAA,MAAM,UAAEA,EAAS,MAAEC,GAAU,MAC5B,MAAMC,EAAM,CACXF,UAAW,SAAUG,EAAMC,IAC1BA,EAAUA,GAAW,IACbC,UAAYD,EAAQC,YAAa,EACzCD,EAAQE,SAAWF,EAAQE,WAAY,EAGvC,IAAIC,EAAOJ,EAOX,OALAI,EAAOL,EAAIM,OAAOL,EAAMC,GACxBG,EAAOL,EAAIO,QAAQF,EAAMH,GAEzBG,EAAOL,EAAIQ,MAAMH,GAEVA,GAGRC,OAAQ,SAAUL,EAAMC,GAIvB,MAAMC,EAAYD,EAAQC,UAEpBM,EAAYR,EAAKS,QAAO,CAACD,EAAWE,IAAQC,KAAKC,IAAIJ,EAAWE,EAAIG,SAAS,GAG7EC,EAAOZ,EAAYM,EAAYR,EAAKa,OACpCE,EAAOb,EAAYF,EAAKa,OAASL,EAEvC,IAAIJ,EAAO,GACX,IAAK,IAAIY,EAAI,EAAGA,EAAIF,EAAME,IAAK,CAC9B,IAAIN,EAAM,GACV,IAAK,IAAIO,EAAI,EAAGA,EAAIF,EAAME,IAAK,CAC9B,IAAIC,EAAOhB,EAAYe,EAAID,EACvBG,EAAOjB,EAAYc,EAAIC,EAEvBG,EAAYpB,EAAKkB,GAAMC,GAEvBA,GAAQnB,EAAKkB,GAAML,SACtBO,EAAY,IAGbV,EAAIW,KAAKD,GAEVhB,EAAKiB,KAAKX,GAGX,OAAON,GAGRE,QAAS,SAAUF,EAAMH,GAGxB,MAAME,EAAWF,EAAQE,SAEzB,IAAK,IAAIa,EAAI,EAAGA,EAAIZ,EAAKS,OAAQG,IAAK,CACrC,IAAIN,EAAMN,EAAKY,GAEf,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAIG,OAAQI,SACT,IAAXP,EAAIO,GAEdP,EAAIO,GAAK,GACmB,iBAAXP,EAAIO,KAErBP,EAAIO,GAAK,GAAKP,EAAIO,IAGfd,GAGCO,EAAIO,GAAGK,MAAM,cAChBZ,EAAIO,GAAK,KAAOP,EAAIO,IAIlBP,EAAIO,GAAGK,MAAM,YAGhBZ,EAAIO,GAAKP,EAAIO,GAAGM,QAAQ,KAAM,MAG9Bb,EAAIO,GAAK,IAAMP,EAAIO,GAAK,KAK3B,OAAOb,GAGRG,MAAO,SAAUH,GAChB,IAAK,IAAIY,EAAI,EAAGA,EAAIZ,EAAKS,OAAQG,IAChCZ,EAAKY,GAAKZ,EAAKY,GAAGQ,KAAK,KAIxB,OAFOpB,EAAKoB,KAAK,OAMlB1B,MAAO,SAAU2B,EAAWxB,GAC3B,IAAIG,EAAOL,EAAI2B,UAAUD,GAQzB,OANA1B,EAAI4B,UAAUvB,GAEVH,GAAWA,EAAQ2B,SACtBxB,EAAOA,EAAKyB,KAAKnB,GAAQA,EAAImB,IAAI5B,EAAQ2B,WAGnCxB,GAGRsB,UAAW,SAAUD,GAGpB,IAAIK,EAAS,GAGbL,EAAYA,EAAUF,QAAQ,MAAO,IAErC,IAAIQ,GAAU,EACVC,GAAW,EAEXC,EAAa,EACbvB,EAAM,GACV,IAAK,IAAIM,EAAI,EAAGA,EAAIS,EAAUZ,OAAQG,IAAK,CAC1C,IAAIkB,EAAOT,EAAUT,GAEjBmB,EAAiB,MAATD,EACRE,EAAiB,MAATF,EACRG,EAAmB,OAATH,EACVI,EAAMtB,IAAMS,EAAUZ,OAAQ,EAElC,GAAIkB,EAEH,GAAIK,EAAO,CAIV,GAAiB,MAFFX,EAAUT,EAAE,GAEL,CAGrBA,IACA,SAMA,GAHAe,GAAU,EACVC,GAAW,GAENM,EACJ,cAGI,GAAIA,EACV,MAAM,IAAIC,MAAM,gEAAgEvB,KAIlF,IAAKe,IAAYI,GAASE,GAAWC,GAAM,CAE1C,IAAIE,EAAQf,EAAUgB,UAAUR,EAAYjB,EAAE,IAE1CmB,GAASE,KAEZG,EAAQA,EAAMC,UAAU,EAAGD,EAAM3B,OAAS,IAGvCmB,IACHA,GAAW,EAGXQ,EAAQA,EAAMC,UAAU,EAAGD,EAAM3B,OAAS,GAG1C2B,EAAQA,EAAMjB,QAAQ,MAAO,MAE9Bb,EAAIW,KAAKmB,GAELL,GAASG,GAEZ5B,EAAIW,KAAK,KAGNgB,GAAWC,KACdR,EAAOT,KAAKX,GACR2B,IACH3B,EAAM,KAIRuB,EAAajB,EAAE,MACT,IAAIgB,EACV,MAAM,IAAIO,MAAM,mFAAmFvB,KACzFoB,IACVL,GAAU,IAIZ,OAAOD,GAGRH,UAAW,SAAUvB,GAGpB,GAAIA,GAAQA,EAAKS,OAAS,EAAG,CAC5B,IAAI6B,EAAYtC,EAAK,GAAGS,OACxB,IAAK,IAAIG,EAAI,EAAGA,EAAIZ,EAAKS,OAAQG,IAGhC,GAFUZ,EAAKY,GAEPH,SAAW6B,EAClB,MAAM,IAAIH,MAAM,kBAAkBvB,qDAAqD0B,SAO5F,MAAO,CACN7C,UAAWE,EAAIF,UACfC,MAAOC,EAAID,QA3NgB,GCE7B,MAAM6C,UAAqBC,MAC1B,YAAYC,GAIXC,MAAMD,EAAYhC,QAClB,IAAK,IAAIG,EAAI,EAAGA,EAAI6B,EAAYhC,OAAQG,IACvC+B,KAAK/B,GAAK6B,EAAY7B,GAQxB,OAAOgC,GAEN,OADYD,KAAKlB,KAAKnB,GAAQA,EAAIsC,KAQnC,OAAOC,GAIN,GAAIF,KAAKlC,SAAWoC,EAAIpC,OACvB,MAAM,IAAI0B,MAAM,4BAA4BU,EAAIpC,4BAA4BkC,KAAKlC,UAGlF,MAAMqC,EAAWH,KAAK,GAAGlC,OAEzB,IAAK,IAAKG,EAAGN,KAAQqC,KAAKI,UACzBzC,EAAIW,KAAK4B,EAAIjC,IAGd,OAAOkC,EAGR,cAAcE,KAAcC,GAgB3B,OAVmBN,KAAKlB,KAAI,CAACnB,EAAKM,KACjC,MAAMsC,EAAgB,CAAC5C,GAEvB,IAAK,IAAIuC,KAAOI,EACfC,EAAcjC,KAAK4B,EAAIjC,IAGxB,OAAOoC,EAAUG,MAAMR,KAAMO,MAM/B,cAAcE,KAAaH,GAK1B,MAAMI,EAAaV,KAAKW,cAAcH,MAAMR,KAAMY,WAElD,OAAOZ,KAAKa,OAAOH,GAOpB,eAAeJ,EAAMQ,GA8BpB,OAnBAA,EAAiBA,GAAkB,KAErBd,KAAKlB,KAAKnB,IACvB,MAAMoD,EAAS,GAEf,IAAK,IAAIC,KAAWV,EAAM,CACzB,MACMW,EAAOtD,EADD2C,EAAKU,IAIhBD,EAAOC,GADJC,aAAgBpB,MACDoB,EAAKxC,KAAKqC,GAEVG,EAIpB,OAAOF,KAMT,qBAAqBT,GACpB,MAAMY,EAAQlB,KAAKmB,eAAeb,EAAM,KAGxC,OAFoBc,EAASC,sBAAsBH,GAKpD,cAAcZ,EAAMgB,GASbhB,aAAgBT,QACrBS,EAAO,CAACA,IAGT,MAAMiB,EAAU,GAChB,IAAK,IAAI5D,KAAOqC,KACf,IAAK,IAAIE,KAAOI,EAAM,CACrB,MAAMjC,EAAYV,EAAIuC,GAEtB,QAAyB,IAAd7B,GAA2C,KAAdA,EAAkB,CACzD,IAAImD,EAGHA,EADGnD,aAAqBwB,MACfxB,EAEA,CAACA,GAGX,IAAK,IAAIoD,KAASD,EACbC,KAASF,EACZA,EAAQE,KAERF,EAAQE,GAAS,GAatB,YAJyB,IAAdH,IACVC,EAAUH,EAASM,0BAA0BH,EAASD,IAGhDC,EAGR,mBAAmBrB,EAAKyB,GAMvB,MAAMC,EAAa5B,KAAK6B,cAAc3B,GAEhC4B,EAAa,GAEnB,IAAK,IAAI7D,EAAI,EAAGA,EAAI0D,EAAO7D,OAAQG,IAClC6D,EAAW7D,GAAK,EAGjB,IAAK,IAAIA,KAAK2D,EAAY,CACzB,MAAMH,EAAQG,EAAW3D,GACzB,IAAI8D,EAAQJ,EAAOK,QAAQ/D,IACZ,IAAX8D,IAEHA,EAAQJ,EAAOK,QAAQC,SAAShE,EAAG,OAGrB,IAAX8D,IACHD,EAAWC,GAASN,GAItB,OAAOK,EAGR,qBAAqBI,EAAWC,EAAeC,EAAQC,GAU7B,IAArBzB,UAAU9C,QAEbsE,EAASD,EACTA,OAAgBG,GACe,IAArB1B,UAAU9C,SAEdqE,aAAyBtC,QAE9BwC,EAAaD,EACbA,EAASD,EACTA,OAAgBG,IAIlB,MAAMC,EAAgBvC,KAAK6B,cAAcK,EAAWC,GAC9CK,EAAaxC,KAAK6B,cAAcO,EAAQC,GAExCI,EAAU,GACZN,IACHM,EAAQC,QAAUP,GAEfE,IACHI,EAAQE,KAAON,GAEhB,MAAMO,EAAKxB,EAASyB,iBAAiBJ,GAE/BK,EAAoB,GAC1B,IAAK,IAAI7E,KAAKuE,EAAY,CACzBM,EAAkB7E,GAAK,GACvB,IAAK,IAAIC,KAAKqE,EACbO,EAAkB7E,GAAGC,GAAK8B,KAAK+C,OAC9BH,EAAGR,EAAQhB,EAAS4B,cAAc/E,IACjCgF,MAAMf,EAAWd,EAAS4B,cAAc9E,KACxCJ,OAIJ,OAAOgF,EAGR,2BAA2BZ,EAAWC,EAAeC,EAAQC,GAK5D,MAAMS,EAAoB9C,KAAKkD,qBAAqB1C,MAAMR,KAAMY,WAGhE,OAFgCQ,EAASC,sBAAsByB,GAAmB,IAMpF,MAAM1B,EAAW,CAIhB+B,SAAUC,kBAAmBC,GAE5B,MAAMC,EAAWD,EAAcvE,KAAKyE,GAAenC,EAASoC,UAAUD,KAEtE,OAAIF,EAAcvF,OAAS,QAEb2F,QAAQC,IAAIJ,SAEZA,EAAS,IAIxBE,UAAWJ,eAAgBG,GAC1B,MAAMI,QAAiBC,MAAML,EAAWM,MAExC,GAAIF,EAASG,GAAI,CAChB,MAAM7G,QAAa0G,EAASI,OAEtB1G,EAAON,EAAME,EAAM,CAAE4B,OAAQuC,EAAS4B,gBAE5C,OADmB5B,EAAS4C,aAAa3G,EAAMkG,GAG/C,MAAM,IAAI/D,MAAM,2BAA2B+D,EAAWM,SAASF,EAASM,WAI1ED,aAAc,SAAU3G,EAAMkG,GAmD7BA,EAAWW,WAAaX,EAAWW,YAAc,EACjDX,EAAWY,WAAaZ,EAAWY,YAAc,EACjDZ,EAAWjD,KAAOiD,EAAWjD,MAAQ,GACrCiD,EAAWd,QAAUc,EAAWd,SAAW,GAC3Cc,EAAWa,UAAYb,EAAWa,WAAa,GAC/Cb,EAAWc,SAAWd,EAAWc,UAAY,GAC7Cd,EAAWe,WAAaf,EAAWe,YAAc,GAEjD,MAAMC,EAAa,GACnBA,EAAWjE,KAAOiD,EAAWjD,KAC7BiE,EAAW9B,QAAUc,EAAWd,QAChC8B,EAAW3B,GAAKxB,EAASyB,iBAAiBU,EAAWd,SACrD8B,EAAWF,SAAWd,EAAWc,SAEH,IAA1Bd,EAAWW,YAEd7G,EAAKmH,OAAO,EAAGjB,EAAWW,YAGG,IAA1BX,EAAWY,YAEd9G,EAAKmH,QAAQjB,EAAWY,YAIzBI,EAAWlH,KAAO,IAAIuC,EAAavC,GACnC,IAAK,IAAIY,EAAI,EAAGA,EAAIsG,EAAWlH,KAAKS,OAAQG,IAAK,CAChD,MAAMN,EAAM4G,EAAWlH,KAAKY,GAE5B,IAAK,IAAIC,KAAKqF,EAAWa,UACxBzG,EAAIO,IAAMP,EAAIO,GAAK,IAAIuG,OAAOC,MAAMnB,EAAWa,UAAUlG,IAAM,KAIhE,IAAK,IAAIA,KAAKqF,EAAWoB,iBACpBzG,KAAKqF,EAAWa,WAGfzG,EAAIO,GAAK,IAASqF,EAAWoB,iBAAiBzG,GAAK,KACvDP,EAAIO,GAAK,IAKX,IAAK,IAAIA,KAAKqF,EAAWqB,YACpB1G,KAAKqF,EAAWa,WAGS,MAAxBzG,EAAIO,GAAK,IAAIuG,SACjB9G,EAAIO,GAAKqF,EAAWqB,YAAY1G,IAQnC,OAFAqG,EAAWM,MAAQzD,EAAS0D,YAAYzH,EAAMkG,GAEvCgB,GAGRO,YAAa,SAAUzH,EAAM0H,GAC5B,MAAMF,EAAQ,GAEd,IAAK,IAAI3E,KAAO6E,EAAOzE,KAAM,CAG5B,IAAI0E,GAAU,EACVD,EAAOT,WAAWW,SAASF,EAAOzE,KAAKJ,MAC1C8E,GAAU,GAEX,IAAK,IAAIE,KAAWH,EAAOV,SAC1B,GAAIU,EAAOV,SAASa,GAASD,SAASF,EAAOzE,KAAKJ,IAAO,CACxD8E,GAAU,EACV,MAIEA,IACHH,EAAM3E,GAAO,GACbkB,EAAS+D,cAAc9H,EAAMwH,EAAM3E,GAAM6E,EAAOzE,KAAKJ,KAGvD,IAAK,IAAIgF,KAAWH,EAAOV,SAC1BQ,EAAMK,GAAW,GACjB9D,EAAS+D,cAAc3E,MAAMR,KAAM,CAAC3C,EAAMwH,EAAMK,IAAUE,OAAOL,EAAOV,SAASa,KAGlF,OAAOL,GAGRM,cAAe,SAAU9H,EAAMgI,KAAa/E,GAI3C+E,EAAWA,GAAY,GAEvB,IAAK,IAAI1H,KAAON,EACf,IAAK,IAAI6C,KAAOI,EAAM,CACrB,MAAMW,EAAOtD,EAAIuC,GAEjB,GAAIe,aAAgBpB,MACnB,IAAK,IAAI4B,KAASR,EACF,KAAVQ,IAA+C,IAA7B4D,EAASrD,QAAQP,IACvC4D,EAAS/G,KAAKmD,OAIF,KAATR,IAA6C,IAA5BoE,EAASrD,QAAQf,IACtCoE,EAAS/G,KAAK2C,GAMlB,OAAOoE,GAGRC,YAAa,YAAaC,KAsL1BvC,cAAe,SAAUwC,GAGxB,MAAe,SAAXA,GAEkB,UAAXA,GAGHpE,EAASqE,eAAeD,IAIjCC,eAAgB,SAAUD,GAGzB,IAAIE,EAAMF,EAAOhH,QAAQ,QAAS,IAElC,GAAImH,WAAWD,MAAUA,EAAK,CAG7B,GAFqBF,EAAOjH,MAAM,MAEhB,CAKjB,IAEIT,GAFY4H,EAAM,IACalH,QAAQ,SAAU,IACrBV,OAEhC4H,GAAY,IACZA,EAAMA,EAAIE,QAAQ9H,EAAO,GAE1B,OAAQ4H,EAER,OAAOF,GAOT3C,iBAAkB,SAAUJ,GAgB3B,OAfW,SAAUtC,EAAUqB,GAC9B,MAAMqE,EAAYlI,GAAQyD,EAAS0E,aAAanI,EAAKwC,EAAUqB,EAAQiB,GAWvE,OATAoD,EAAS5C,MAAQ,CAAC9C,EAAUqB,IACnB7D,GAAQkI,EAASlI,IAAQyD,EAAS0E,aAAanI,EAAKwC,EAAUqB,EAAQiB,GAE/EoD,EAASE,KAAO,CAAC5F,EAAUqB,IAClB7D,GAAQkI,EAASlI,IAAQyD,EAAS0E,aAAanI,EAAKwC,EAAUqB,EAAQiB,GAG/ErB,EAAS4E,cAAcH,EAAUpD,GAE1BoD,IAMTG,cAAe,SAAUH,EAAUpD,GAclC,OAbAoD,EAAS5C,MAAQ,CAAC9C,EAAUqB,KAC3B,MAAMyE,EAAetI,GAAQkI,EAASlI,IAAQyD,EAAS0E,aAAanI,EAAKwC,EAAUqB,EAAQiB,GAG3F,OADArB,EAAS4E,cAAcC,EAAaxD,GAC7BwD,GAERJ,EAASE,KAAO,CAAC5F,EAAUqB,KAC1B,MAAMyE,EAAetI,GAAQkI,EAASlI,IAAQyD,EAAS0E,aAAanI,EAAKwC,EAAUqB,EAAQiB,GAG3F,OADArB,EAAS4E,cAAcC,EAAaxD,GAC7BwD,GAGDJ,GAGRC,aAAc,SAAUnI,EAAKwC,EAAUqB,EAAQiB,GAE9C,GAAIjB,aAAkB0E,SACrB,OAAO1E,EAAO7D,EAAIwC,IAIbqB,aAAkB3B,QACvB2B,EAAS,CAACA,IAGX,MAAMP,EAAOtD,EAAIwC,GACjB,IAAIgG,EAGHA,EADGlF,aAAgBpB,MACNoB,EAEA,CAACA,GAGf,IAAK,IAAI5C,KAAa8H,EACrB,IAAK,IAAI1E,KAASD,EACjB,GAAIJ,EAASgF,YAAY3E,EAAOpD,EAAWoE,GAC1C,OAAO,EAKV,OAAO,GAGR2D,YAAa,SAAUnF,EAAMQ,EAAO4E,GAOnC,GAAIpF,IAASQ,EACZ,OAAO,EAIR,IAAK,IAAIxD,KAAKoI,EAAe,CAC5B,MAAMC,EAAWD,EAAcpI,GAC/B,IAAK,IAAIqD,KAAagF,EAErB,IAC+B,IAA7BhF,EAAUU,QAAQf,KACY,IAA9BK,EAAUU,QAAQP,GAEnB,OAAO,EAKV,OAAO,GAMR8E,aAAc,SAAUvF,GAGvB,GAAIwF,OAAOC,UAAUzF,IAAYA,GAAW,EAE3C,OAAOA,EACD,KAAyB,iBAAZA,GAAwBA,aAAmB0F,QAE9D,OAAO,KACD,GAAuB,IAAnB1F,EAAQlD,OAElB,OAAO,KAGR,MAAM6I,EAAW,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC/I,IAAIC,GAAa,EAEjB,MAAMC,EAAe7F,EAAQ8F,cAC7B,IAAK,IAAI7I,EAAI,EAAGA,EAAI4I,EAAa/I,OAAQG,IAAK,CAC7C,MAAMkB,EAAO0H,EAAa5I,GACpB8I,EAAYJ,EAAS3E,QAAQ7C,GAEnC,IAAmB,IAAf4H,EAEH,OAAO,KAGRH,IAAcG,EAAY,GAAKnJ,KAAKoJ,IAAIL,EAAS7I,OAAQkD,EAAQlD,QAAUG,EAAE,IAG9E,OAAO2I,GAGRK,cAAe,SAAU3G,GAExB,MAAM4G,EAAU,GAEhB,IAAK,IAAIC,KAAO7G,EACf4G,EAAQC,GAAO/F,EAASmF,aAAajG,EAAK6G,IAG3C,OAAOD,GAMR7F,sBAAuB,SAAUH,EAAOkG,EAASC,EAAqBC,GACrE,MAAMC,EAAgBF,GAAuB,KACvCG,EAAeF,GAAsB,KAE3C,IAAIG,EAAc,GAElB,MAAMC,EAAWC,IACU,iBAAfA,IACVA,EAAa,GAAKA,IAGwB,IAAvCA,EAAW3F,QAAQuF,KAGtBI,EAAa,IAAMA,EAAWnJ,QAAQ,KAAM,MAAQ,KAGrDiJ,GAAeE,EAAaJ,GAEvBK,EAAU,KAEfH,EAAcA,EAAYI,OAAO,EAAGJ,EAAY3J,OAASyJ,EAAczJ,QAAU0J,GAI9EJ,IACHK,GAAeF,GAGhB,IAAIO,GAAmB,EACvB,IAAK,IAAIC,KAAW7G,EAAO,CAC1B,IAAyB,IAArB4G,EACH,MAEDA,GAAmB,EAEnB,IAAInK,EAAMuD,EAAM6G,GAChB,IAAK,IAAI/G,KAAWrD,EACnB+J,EAAQ1G,GAGV4G,IAEA,IAAK,IAAIG,KAAW7G,EAAO,CAC1B,IAAI8G,GAAa,EACjB,MAAMrK,EAAMuD,EAAM6G,GAClB,IAAK,IAAI/G,KAAWrD,EAAK,CACxB,MAAMsD,EAAOtD,EAAIqD,GACboG,KACgB,IAAfY,GACHN,EAAQK,GAETC,GAAa,GAGdN,EAAQzG,GAET2G,IAGD,OAAOH,GAGR/F,0BAA2B,SAAUH,EAASD,GAM7C,MAAM2G,EAAa,GACnB,IAAK,IAAIhK,KAAKsD,EAAS,CACtB,IAAI2G,GAAU,EACd,IAAK,IAAIzF,KAAWnB,GACS,IAAxBmB,EAAQT,QAAQ/D,KACnBiK,GAAU,EACNzF,EAAQ,KAAMwF,EACjBA,EAAWxF,EAAQ,KAAOlB,EAAQtD,GAElCgK,EAAWxF,EAAQ,IAAMlB,EAAQtD,KAKpB,IAAZiK,IACHD,EAAWhK,GAAKsD,EAAQtD,IAI1B,OAAOgK,KAII,SACZ9E,EAAQ,aAGRoD,EAAY,cACZU,GACG7F,GCr5BYgC,iBACf,IAAI+E,EAAY,CACftE,KAAM,yCACNK,WAAY,EACZ5D,KAAM,CACL8H,KAAM,EAAsB,KAC5BC,QAAS,EAAsB,KAC/BC,WAAY,EAAsB,KAClCC,QAAS,EAAsB,KAC/BC,iBAAkB,EAAsB,KACxCC,WAAY,EAAsB,KAClCC,WAAY,EAAsB,MAEnCtE,UAAW,GACX3B,QAAS,CACR4F,QAAS,CACR,CAAC,cAAe,cAGlBhE,SAAU,IAEX8D,EAAU/D,UAAU+D,EAAU7H,KAAKkI,kBAAoB,IACvDL,EAAU/D,UAAU+D,EAAU7H,KAAKoI,YAAc,IAEjD,IAAIC,EAAY,CACf9E,KAAM,2CACNK,WAAY,EACZ5D,KAAM,CACL8H,KAAM,EAAsB,KAC5BC,QAAS,EAAsB,KAC/BC,WAAY,EAAsB,OAGhCM,EAAY,CACf/E,KAAM,2CACNK,WAAY,EACZ5D,KAAM,CACLuI,KAAM,EAAsB,KAC5BP,WAAY,EAAsB,QAI/BQ,EAAUC,EAAWC,SAAmB,EAAkBb,EAAWQ,EAAWC,GAWrF,MAAM,KACLvL,EAAI,KACJiD,EAAI,GACJsC,GACGkG,EAEJG,QAAQC,IAAI7L,GACZ4L,QAAQC,IAAI5I,GAEZ2I,QAAQC,IAAI7L,EAAK0F,OAChBH,EAAGtC,EAAKgI,YAAYa,GAAOA,EAAM,MAChClG,MAAM3C,EAAKkI,iBAAkB,SAC7BzC,KAAKzF,EAAKkI,iBAAkB,SAI/BY,I","file":"bundle.js","sourcesContent":["const { stringify, parse } = (() => {\n\tconst csv = {\n\t\tstringify: function (data, options) {\n\t\t\toptions = options || {};\n\t\t\toptions.transpose = options.transpose || false;\n\t\t\toptions.sanitise = options.sanitise || false;\n\n\t\t\t// Enforce square data and apply CSV escaping, then convert to string\n\t\t\tlet rows = data;\n\n\t\t\trows = csv._shape(data, options);\n\t\t\trows = csv._escape(rows, options);\n\n\t\t\trows = csv._join(rows);\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_shape: function (data, options) {\n\t\t\t// Pad missing cells with empty strings and,\n\t\t\t// if necessary, transpose the data\n\n\t\t\tconst transpose = options.transpose;\n\n\t\t\tconst maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\n\n\t\t\t// Flip rows and columns if transposing data\n\t\t\tconst iMax = transpose ? maxLength : data.length;\n\t\t\tconst jMax = transpose ? data.length : maxLength;\n\n\t\t\tlet rows = [];\n\t\t\tfor (let i = 0; i < iMax; i++) {\n\t\t\t\tlet row = [];\n\t\t\t\tfor (let j = 0; j < jMax; j++) {\n\t\t\t\t\tlet iRow = transpose ? j : i;\n\t\t\t\t\tlet iCol = transpose ? i : j;\n\n\t\t\t\t\tlet cellValue = data[iRow][iCol];\n\n\t\t\t\t\tif (iCol >= data[iRow].length) {\n\t\t\t\t\t\tcellValue = '';\n\t\t\t\t\t}\n\n\t\t\t\t\trow.push(cellValue);\n\t\t\t\t}\n\t\t\t\trows.push(row);\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_escape: function (rows, options) {\n\t\t\t// Make sure any cells containing \" or , or a newline are escaped appropriately\n\n\t\t\tconst sanitise = options.sanitise;\n\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\tlet row = rows[i];\n\n\t\t\t\tfor (let j = 0; j < row.length; j++) {\n\t\t\t\t\tif (typeof row[j] === 'undefined') {\n\t\t\t\t\t\t// Replace undefined with ''\n\t\t\t\t\t\trow[j] = '';\n\t\t\t\t\t} else if (typeof row[j] !== 'string') {\n\t\t\t\t\t\t// Convert to string\n\t\t\t\t\t\trow[j] = '' + row[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sanitise) {\n\t\t\t\t\t\t// Prevent spreadsheet software like\n\t\t\t\t\t\t// Excel from trying to execute code\n\t\t\t\t\t\tif (row[j].match(/^[=\\-+@]/)) {\n\t\t\t\t\t\t\trow[j] = '\\t' + row[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (row[j].match(/,|\"|\\n/)) {\n\n\t\t\t\t\t\t// Turn any double quotes into escaped double quotes\n\t\t\t\t\t\trow[j] = row[j].replace(/\"/g, '\"\"');\n\n\t\t\t\t\t\t// Wrap cell in double quotes\n\t\t\t\t\t\trow[j] = '\"' + row[j] + '\"';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_join: function (rows) {\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\trows[i] = rows[i].join(',');\n\t\t\t}\n\t\t\trows = rows.join('\\n');\n\n\t\t\treturn rows;\n\t\t},\n\n\n\t\tparse: function (csvString, options) {\n\t\t\tlet rows = csv._tokenise(csvString);\n\n\t\t\tcsv._validate(rows);\n\n\t\t\tif (options && options.mapper) {\n\t\t\t\trows = rows.map((row) => row.map(options.mapper));\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_tokenise: function (csvString) {\n\t\t\t// Walk through each character and produce an array of tokens\n\n\t\t\tlet tokens = [];\n\n\t\t\t// Remove carriage returns\n\t\t\tcsvString = csvString.replace(/\\r/g, '');\n\n\t\t\tlet inQuote = false;\n\t\t\tlet wasQuote = false;\n\n\t\t\tlet tokenStart = 0;\n\t\t\tlet row = [];\n\t\t\tfor (let i = 0; i < csvString.length; i++) {\n\t\t\t\tlet char = csvString[i];\n\n\t\t\t\tlet comma = char === ',';\n\t\t\t\tlet quote = char === '\"';\n\t\t\t\tlet newline = char === '\\n';\n\t\t\t\tlet eof = i === csvString.length -1; // eof - End Of File\n\n\t\t\t\tif (inQuote) {\n\t\t\t\t\t// Characters may be delimited\n\t\t\t\t\tif (quote) {\n\t\t\t\t\t\t// Check if the next character is another double quote, i.e. if it is escaped\n\t\t\t\t\t\tlet nextChar = csvString[i+1];\n\n\t\t\t\t\t\tif (nextChar === '\"') {\n\t\t\t\t\t\t\t// This and the next character combined make an escaped double quote,\n\t\t\t\t\t\t\t// so the quote has not ended and we should skip over the next character\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// The quote has ended\n\t\t\t\t\t\t\tinQuote = false;\n\t\t\t\t\t\t\twasQuote = true;\n\n\t\t\t\t\t\t\tif (!eof) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (eof) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Reached end of file before ending quote. At index ${i}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!inQuote && (comma || newline || eof)) {\n\t\t\t\t\t// These are the characters that denote the end of a token\n\t\t\t\t\tlet token = csvString.substring(tokenStart, i+1);\n\n\t\t\t\t\tif (comma || newline) {\n\t\t\t\t\t\t// Don't keep the separator\n\t\t\t\t\t\ttoken = token.substring(0, token.length - 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (wasQuote) {\n\t\t\t\t\t\twasQuote = false;\n\n\t\t\t\t\t\t// Remove start and end quotes\n\t\t\t\t\t\ttoken = token.substring(1, token.length - 1);\n\n\t\t\t\t\t\t// Replace escaped quotes\n\t\t\t\t\t\ttoken = token.replace(/\"\"/g, '\"');\n\t\t\t\t\t}\n\t\t\t\t\trow.push(token);\n\n\t\t\t\t\tif (comma && eof) {\n\t\t\t\t\t\t// It's the end of the last token, and the last cell is empty\n\t\t\t\t\t\trow.push('');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newline || eof) {\n\t\t\t\t\t\ttokens.push(row);\n\t\t\t\t\t\tif (newline) {\n\t\t\t\t\t\t\trow = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenStart = i+1;\n\t\t\t\t} else if (wasQuote) {\n\t\t\t\t\tthrow new Error(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\n\t\t\t\t} else if (quote) {\n\t\t\t\t\tinQuote = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tokens;\n\t\t},\n\n\t\t_validate: function (rows) {\n\t\t\t// Each row of a CSV should have the same length;\n\n\t\t\tif (rows && rows.length > 1) {\n\t\t\t\tlet rowLength = rows[0].length;\n\t\t\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\t\t\tlet row = rows[i];\n\n\t\t\t\t\tif (row.length !== rowLength) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\treturn {\n\t\tstringify: csv.stringify,\n\t\tparse: csv.parse,\n\t};\n})();\n\nexport { stringify, parse };\n","import { parse } from 'csv';\n\nclass AnalyserRows extends Array {\n\tconstructor(sourceArray) {\n\t\t// Don't use spread operator as it will cause a\n\t\t// stack overflow error with very large arrays\n\t\t// super(...sourceArray);\n\t\tsuper(sourceArray.length);\n\t\tfor (let i = 0; i < sourceArray.length; i++) {\n\t\t\tthis[i] = sourceArray[i];\n\t\t}\n\t}\n\n\n\t//////////////////////\n\t// HELPER FUNCTIONS //\n\t//////////////////////\n\tgetCol(colNum) {\n\t\tconst col = this.map((row) => row[colNum]);\n\t\treturn col;\n\t}\n\n\n\t//////////////////////////////\n\t// TRANSFORMING INFORMATION //\n\t//////////////////////////////\n\taddCol(col) {\n\t\t// Edits the passed rows array to add an extra column\n\t\t// to it, then returns the index of that new column\n\n\t\tif (this.length !== col.length) {\n\t\t\tthrow new Error(`Cannot add col of length ${col.length} to rows of length ${this.length}`);\n\t\t}\n\n\t\tconst colIndex = this[0].length;\n\n\t\tfor (let [i, row] of this.entries()) {\n\t\t\trow.push(col[i]);\n\t\t}\n\n\t\treturn colIndex;\n\t}\n\n\tgetDerivedCol(processFn, ...cols) {\n\t\t// Creates an array analogous to a column as returns\n\t\t// by the getCol function, where its output is the\n\t\t// result of applying the processFn function to the row\n\t\t// any number of values from optional column arguments\n\n\t\tconst derivedCol = this.map((row, i) => {\n\t\t\tconst derivedValues = [row];\n\n\t\t\tfor (let col of cols) {\n\t\t\t\tderivedValues.push(col[i]);\n\t\t\t}\n\n\t\t\treturn processFn.apply(this, derivedValues);\n\t\t});\n\n\t\treturn derivedCol;\n\t}\n\n\taddDerivedCol(callback, ...cols) {\n\t\t// Works like getDerivedCol, but instead of returning\n\t\t// the derived column directly it uses addCol to add\n\t\t// it to rows and returns the new column index.\n\n\t\tconst derivedCol = this.getDerivedCol.apply(this, arguments);\n\n\t\treturn this.addCol(derivedCol);\n\t}\n\n\n\t///////////////////\n\t// SUMMARY TOOLS //\n\t///////////////////\n\tcreateSubTable(cols, arraySeparator) {\n\t\t// Takes in a set of rows and a cols object formatted like this:\n\t\t// {\n\t\t// \tETHNICITY: 3,\n\t\t// \tAGE: 6\n\t\t// }\n\n\t\t// Outputs an array of objects,\n\t\t// each of which has the same indices as cols and represents a row\n\t\t// The output can be used with console.table\n\n\t\tarraySeparator = arraySeparator || ', ';\n\n\t\tconst table = this.map((row) => {\n\t\t\tconst newRow = {};\n\n\t\t\tfor (let colName in cols) {\n\t\t\t\tconst col = cols[colName];\n\t\t\t\tconst cell = row[col]\n\t\t\t\t// Join arrays so they display in console.table\n\t\t\t\tif (cell instanceof Array) {\n\t\t\t\t\tnewRow[colName] = cell.join(arraySeparator);\n\t\t\t\t} else {\n\t\t\t\t\tnewRow[colName] = cell;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRow;\n\t\t});\n\n\t\treturn table;\n\t}\n\n\tcreateSubTableString(cols) {\n\t\tconst table = this.createSubTable(cols, ',');\n\t\tconst tableString = Analyser._convertTableToString(table);\n\n\t\treturn tableString;\n\t}\n\n\tgetColSummary(cols, aliasList) {\n\t\t// Takes in a set of rows and one or more column numbers, and optionally\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\n\n\t\t// Outputs an object summarising the number of times each value\n\t\t// appeared in the given column of the given rows\n\n\n\t\t// Allow the passing of a single number or an array of column indices\n\t\tif (!(cols instanceof Array)) {\n\t\t\tcols = [cols];\n\t\t}\n\n\t\tconst summary = {};\n\t\tfor (let row of this) {\n\t\t\tfor (let col of cols) {\n\t\t\t\tconst cellValue = row[col];\n\n\t\t\t\tif (typeof cellValue !== 'undefined' && cellValue !== '') {\n\t\t\t\t\tlet values;\n\n\t\t\t\t\tif (cellValue instanceof Array) {\n\t\t\t\t\t\tvalues = cellValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues = [cellValue];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let value of values) {\n\t\t\t\t\t\tif (value in summary) {\n\t\t\t\t\t\t\tsummary[value]++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsummary[value] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (typeof aliasList !== 'undefined') {\n\t\t\tsummary = Analyser._groupColSummaryByAliases(summary, aliasList);\n\t\t}\n\n\t\treturn summary;\n\t}\n\n\tgetColAsDataSeries(col, labels) {\n\t\t// Takes in a set of rows and a column number,\n\t\t// and an array of labels. Outputs an array where\n\t\t// each element is the count of the values matching\n\t\t// the element of labels at the same index\n\n\t\tconst colSummary = this.getColSummary(col);\n\n\t\tconst dataSeries = [];\n\n\t\tfor (let i = 0; i < labels.length; i++) {\n\t\t\tdataSeries[i] = 0;\n\t\t}\n\n\t\tfor (let i in colSummary) {\n\t\t\tconst value = colSummary[i];\n\t\t\tlet index = labels.indexOf(i);\n\t\t\tif (index === -1) {\n\t\t\t\t// Couldn't find index, try forcing it to be a number\n\t\t\t\tindex = labels.indexOf(parseInt(i, 10));\n\t\t\t}\n\n\t\t\tif (index !== -1) {\n\t\t\t\tdataSeries[index] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn dataSeries;\n\t}\n\n\tgetComparisonSummary(headerCol, headerAliases, varCol, varAliases) {\n\t\t// Takes in a set of rows and two column numbers\n\t\t// Creates an object that can be used with console.table\n\t\t// with the values of headerCol used in the header, and\n\t\t// the values of varCol used for each row, with the cells\n\t\t// denoting the number of times these values coincided\n\t\t// using filterRows with the passed sets of aliases\n\n\t\t// Also optionally takes a set of aliases for one or both columns\n\n\t\tif (arguments.length === 2) {\n\t\t\t// No aliases specified\n\t\t\tvarCol = headerAliases;\n\t\t\theaderAliases = undefined;\n\t\t} else if (arguments.length === 3) {\n\t\t\t// One alias specified\n\t\t\tif (!(headerAliases instanceof Array)) {\n\t\t\t\t// headerAliases was not passed\n\t\t\t\tvarAliases = varCol;\n\t\t\t\tvarCol = headerAliases;\n\t\t\t\theaderAliases = undefined;\n\t\t\t}\n\t\t}\n\n\t\tconst headerSummary = this.getColSummary(headerCol, headerAliases);\n\t\tconst varSummary = this.getColSummary(varCol, varAliases);\n\n\t\tconst aliases = {};\n\t\tif (headerAliases) {\n\t\t\taliases.HEADERS = headerAliases;\n\t\t}\n\t\tif (varAliases) {\n\t\t\taliases.VARS = varAliases;\n\t\t}\n\t\tconst by = Analyser._getAliasFilters(aliases);\n\n\t\tconst comparisonSummary = {};\n\t\tfor (let i in varSummary) {\n\t\t\tcomparisonSummary[i] = {};\n\t\t\tfor (let j in headerSummary) {\n\t\t\t\tcomparisonSummary[i][j] = this.filter(\n\t\t\t\t\tby(varCol, Analyser._extractValue(i))\n\t\t\t\t\t.andBy(headerCol, Analyser._extractValue(j))\n\t\t\t\t).length;\n\t\t\t}\n\t\t}\n\n\t\treturn comparisonSummary;\n\t}\n\n\tgetComparisonSummaryString(headerCol, headerAliases, varCol, varAliases) {\n\t\t// Calls getComparisonSummary with all arguments passed,\n\t\t// then returns a string of the data that can be copy/pasted\n\t\t// into a spreadsheet\n\n\t\tconst comparisonSummary = this.getComparisonSummary.apply(this, arguments);\n\t\tconst comparisonSummaryString = Analyser._convertTableToString(comparisonSummary, true);\n\n\t\treturn comparisonSummaryString;\n\t}\n}\n\nconst Analyser = {\n\t/////////////////////\n\t// FILE PROCESSING //\n\t/////////////////////\n\tloadFile: async function (...fileConfigArr) {\n\t\t// Load each file, then resolve the wrapping promise once all are loaded\n\t\tconst promises = fileConfigArr.map((fileConfig) => Analyser._loadFile(fileConfig))\n\n\t\tif (fileConfigArr.length > 1) {\n\t\t\t// This returns an array matching fileConfigArr\n\t\t\treturn await Promise.all(promises);\n\t\t} else {\n\t\t\treturn await promises[0];\n\t\t}\n\t},\n\n\t_loadFile: async function (fileConfig) {\n\t\tconst response = await fetch(fileConfig.path);\n\n\t\tif (response.ok) {\n\t\t\tconst data = await response.text();\n\n\t\t\tconst rows = parse(data, { mapper: Analyser._extractValue });\n\t\t\tconst dataConfig = Analyser._processData(rows, fileConfig);\n\t\t\treturn dataConfig;\n\t\t} else {\n\t\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\n\t\t}\n\t},\n\n\t_processData: function (rows, fileConfig) {\n\t\t// TODO: Either rewrite comment or move it entirely into documentation\n\t\t// TODO: Rewrite defaultCols and defaultColValues behaviour\n\t\t// TODO: Make building nums have to be explicit, instead of default\n\n\t\t// Takes in fileConfig with the following properties:\n\t\t// The number of header rows to remove from rows\n\t\t// A fileConfig object for column names\n\t\t// An optional set of aliases\n\t\t// An optional set of columns whose values should be treated as arrays\n\t\t// An optional set of columns with default values\n\t\t// An optional map of columns that should be combined when collecting enums\n\n\t\t// The output contains the following properties:\n\t\t// The header rows that were removed\n\t\t// The fileConfig object for column names\n\t\t// A set of filters respecting the given aliases\n\t\t// Enums collected according to the specified column names and optional enumsMap\n\n\t\t// Example data:\n\t\t// headerRows = 2;\n\t\t// footerRows = 1;\n\n\t\t// cols = Analyser.getColNumbers({\n\t\t// \tETHNICITY: 'K',\n\t\t// \tTACTICS: 'M'\n\t\t// });\n\n\t\t// arrayCols = {};\n\t\t// arrayCols[cols.TACTICS] = ' ';\n\n\t\t// defaultCols = {};\n\t\t// defaultCols[cols.VALUE] = 0;\n\n\t\t// defaultColValues = {};\n\t\t// defaultColValues[cols.VALUE] = '-';\n\n\t\t// aliases = {\n\t\t// \tETHNICITY: [\n\t\t// \t\t[\n\t\t// \t\t\t'Pacific', //Not represented in data, but used as a label\n\t\t// \t\t\t'Pacific Island',\n\t\t// \t\t\t'Pacific Islander'\n\t\t// \t\t]\n\t\t// \t]\n\t\t// };\n\n\t\t// enumsMap = {\n\t\t// \tTASER_METHOD: [cols.TASER_METHOD_1, cols.TASER_METHOD_2, cols.TASER_METHOD_3]\n\t\t// };\n\n\t\tfileConfig.headerRows = fileConfig.headerRows || 0;\n\t\tfileConfig.footerRows = fileConfig.footerRows || 0;\n\t\tfileConfig.cols = fileConfig.cols || {};\n\t\tfileConfig.aliases = fileConfig.aliases || {};\n\t\tfileConfig.arrayCols = fileConfig.arrayCols || {};\n\t\tfileConfig.enumsMap = fileConfig.enumsMap || {};\n\t\tfileConfig.uniqueCols = fileConfig.uniqueCols || [];\n\n\t\tconst dataConfig = {};\n\t\tdataConfig.cols = fileConfig.cols;\n\t\tdataConfig.aliases = fileConfig.aliases;\n\t\tdataConfig.by = Analyser._getAliasFilters(fileConfig.aliases);\n\t\tdataConfig.enumsMap = fileConfig.enumsMap; // Keep this for combining data\n\n\t\tif (fileConfig.headerRows !== 0) {\n\t\t\t// Remove header rows\n\t\t\trows.splice(0, fileConfig.headerRows);\n\t\t}\n\n\t\tif (fileConfig.footerRows !== 0) {\n\t\t\t// Remove footer rows\n\t\t\trows.splice(-fileConfig.footerRows);\n\t\t}\n\n\t\t// Convert cells that are lists into arrays\n\t\tdataConfig.rows = new AnalyserRows(rows);\n\t\tfor (let i = 0; i < dataConfig.rows.length; i++) {\n\t\t\tconst row = dataConfig.rows[i];\n\n\t\t\tfor (let j in fileConfig.arrayCols) {\n\t\t\t\trow[j] = (row[j] + '').trim().split(fileConfig.arrayCols[j] || ' ');\n\t\t\t}\n\n\t\t\t// Remove default values from specified columns\n\t\t\tfor (let j in fileConfig.defaultColValues) {\n\t\t\t\tif (j in fileConfig.arrayCols) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((row[j] + '') === (fileConfig.defaultColValues[j] + '')) {\n\t\t\t\t\trow[j] = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add default values to empty cells in default cols\n\t\t\tfor (let j in fileConfig.defaultCols) {\n\t\t\t\tif (j in fileConfig.arrayCols) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((row[j] + '').trim() === '') {\n\t\t\t\t\trow[j] = fileConfig.defaultCols[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Build enums\n\t\tdataConfig.enums = Analyser._buildEnums(rows, fileConfig);\n\n\t\treturn dataConfig;\n\t},\n\n\t_buildEnums: function (rows, config) {\n\t\tconst enums = {};\n\n\t\tfor (let col in config.cols) {\n\n\t\t\t// Don't collect enums for columns specified in uniqueCols or enumsMap\n\t\t\tlet collect = true;\n\t\t\tif (config.uniqueCols.includes(config.cols[col])) {\n\t\t\t\tcollect = false;\n\t\t\t}\n\t\t\tfor (let enumCol in config.enumsMap) {\n\t\t\t\tif (config.enumsMap[enumCol].includes(config.cols[col])) {\n\t\t\t\t\tcollect = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (collect) {\n\t\t\t\tenums[col] = [];\n\t\t\t\tAnalyser._collectEnums(rows, enums[col], config.cols[col]);\n\t\t\t}\n\t\t}\n\t\tfor (let enumCol in config.enumsMap) {\n\t\t\tenums[enumCol] = [];\n\t\t\tAnalyser._collectEnums.apply(this, [rows, enums[enumCol]].concat(config.enumsMap[enumCol]));\n\t\t}\n\n\t\treturn enums;\n\t},\n\n\t_collectEnums: function (rows, enumsArr, ...cols) {\n\t\t// Go through all cells in a given set of columns\n\t\t// and add all unique entries found to enumsArr\n\n\t\tenumsArr = enumsArr || [];\n\n\t\tfor (let row of rows) {\n\t\t\tfor (let col of cols) {\n\t\t\t\tconst cell = row[col];\n\n\t\t\t\tif (cell instanceof Array) {\n\t\t\t\t\tfor (let value of cell) {\n\t\t\t\t\t\tif ((value !== '') && (enumsArr.indexOf(value) === -1)) {\n\t\t\t\t\t\t\tenumsArr.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((cell !== '') && (enumsArr.indexOf(cell) === -1)) {\n\t\t\t\t\t\tenumsArr.push(cell);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn enumsArr;\n\t},\n\n\tcombineData: function (...dataConfigs) {\n\t\t// TODO: Rewrite\n\n\t\t// // Takes in any number of dataConfig objects from _processData\n\t\t// // Combines the rows and relevant dataConfig objects (e.g. aliases, enums)\n\t\t// // Keeps only columns shared by all dataConfig objects\n\n\t\t// // Assumes there is no data shared between different sets,\n\t\t// // so duplicates will *not* be detected or removed\n\n\t\t// // The output is in the same format as for _processData\n\n\t\t// let combinedDataConfig = {\n\t\t// \tcols: {},\n\t\t// \trows: new AnalyserRows([]),\n\t\t// \taliases: {}\n\t\t// };\n\n\t\t// if (!dataConfigs || dataConfigs.length < 2) {\n\t\t// \tconsole.error('Invalid inputs passed to combineData', arguments);\n\t\t// }\n\n\t\t// // Combine cols first //\n\n\t\t// // Build base set from first cols object\n\t\t// for (let j in dataConfigs[0].cols) {\n\t\t// \tcombinedDataConfig.cols[j] = true;\n\t\t// }\n\n\t\t// // Remove any cols not shared by every other cols object\n\t\t// for (let i = 1; i < dataConfigs.length; i++) {\n\t\t// \tlet dataConfig = dataConfigs[i];\n\n\t\t// \tfor (let j in combinedDataConfig.cols) {\n\t\t// \t\tif (!(j in dataConfig.cols)) {\n\t\t// \t\t\tdelete combinedDataConfig.cols[j];\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// let colIndex = 0;\n\t\t// for (let j in combinedDataConfig.cols) {\n\t\t// \tcombinedDataConfig.cols[j] = colIndex;\n\t\t// \tcolIndex++;\n\t\t// }\n\n\t\t// // Now that we have the combined cols object, combine rows and aliases\n\t\t// for (let i = 0; i < dataConfigs.length; i++) {\n\t\t// \tlet dataConfig = dataConfigs[i];\n\t\t// \t// Combine rows //\n\n\t\t// \tfor (let j = 0; j < dataConfig.rows.length; j++) {\n\t\t// \t\tlet row = [];\n\t\t// \t\tfor (let k in combinedDataConfig.cols) {\n\t\t// \t\t\trow[combinedDataConfig.cols[k]] = dataConfig.rows[j][dataConfig.cols[k]];\n\t\t// \t\t}\n\n\t\t// \t\tcombinedDataConfig.rows.push(row);\n\t\t// \t}\n\n\n\t\t// \t// Combine aliases //\n\n\t\t// \t// Loop through each row's aliases to combine\n\t\t// \tfor (let j in dataConfig.aliases) {\n\n\t\t// \t\t// If we don't have an alias for this column, make an empty placeholder\n\t\t// \t\tif (!(j in combinedDataConfig.aliases)) {\n\t\t// \t\t\tcombinedDataConfig.aliases[j] = [];\n\t\t// \t\t}\n\n\t\t// \t\t// Loop through each aliasSet for this column\n\t\t// \t\tfor (let k = 0; k < dataConfig.aliases[j].length; k++) {\n\t\t// \t\t\tlet aliasSet = dataConfig.aliases[j][k];\n\n\t\t// \t\t\t// Combine aliasSets based off their first element, which is used as a label\n\t\t// \t\t\tlet combinedAliasSet = [];\n\t\t// \t\t\tlet l;\n\t\t// \t\t\tfor (l = 0; l < combinedDataConfig.aliases[j].length; l++) {\n\t\t// \t\t\t\tif (combinedDataConfig.aliases[j][l][0] === aliasSet[0]) {\n\t\t// \t\t\t\t\tcombinedAliasSet = combinedDataConfig.aliases[j][l];\n\t\t// \t\t\t\t\tbreak;\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\n\t\t// \t\t\tcombinedAliasSet = combinedAliasSet.concat(aliasSet);\n\n\t\t// \t\t\t// Remove duplicates\n\t\t// \t\t\tcombinedAliasSet = combinedAliasSet.filter(function (alias, index, array) {\n\t\t// \t\t\t\treturn array.indexOf(alias) === index;\n\t\t// \t\t\t});\n\n\t\t// \t\t\t// Append or replace aliasSet in combinedDataConfig\n\t\t// \t\t\tif (l < combinedDataConfig.aliases[j].length) {\n\t\t// \t\t\t\tcombinedDataConfig.aliases[j][l] = combinedAliasSet;\n\t\t// \t\t\t} else {\n\t\t// \t\t\t\tcombinedDataConfig.aliases[j].push(combinedAliasSet);\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// // Create new filters using combined aliases\n\t\t// combinedDataConfig.by = Analyser._getAliasFilters(combinedDataConfig.aliases);\n\n\t\t// // Combine uniqueCols\n\t\t// combinedDataConfig.uniqueCols = [];\n\t\t// for (let i = 0; i < dataConfigs.length; i++) {\n\t\t// \tlet dataConfig = dataConfigs[i];\n\n\t\t// \tfor (let j in dataConfig.uniqueCols) {\n\t\t// \t\tlet originalCol = dataConfig.uniqueCols[j];\n\t\t// \t\tlet originalColName = undefined;\n\t\t// \t\tfor (let k in dataConfig.cols) {\n\t\t// \t\t\tif (dataConfig.cols[l] === originalCol) {\n\t\t// \t\t\t\toriginalColName = l;\n\t\t// \t\t\t\tbreak;\n\t\t// \t\t\t}\n\t\t// \t\t}\n\n\t\t// \t\tif (originalColName) {\n\t\t// \t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\n\n\t\t// \t\t\tif (combinedDataConfig.uniqueCols.indexOf(originalColIndex) === -1) {\n\t\t// \t\t\t\tcombinedDataConfig.uniqueCols.push(combinedDataConfig.cols[originalColName]);\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\t// // Combine the enumsMaps, then build combined enums\n\t\t// combinedDataConfig.enumsMap = {};\n\t\t// for (let i = 0; i < dataConfigs.length; i++) {\n\t\t// \tlet dataConfig = dataConfigs[i];\n\n\t\t// \tfor (let j in dataConfig.enumsMap) {\n\t\t// \t\tlet originalEnumsMap = dataConfig.enumsMap[j];\n\n\t\t// \t\tif (!originalEnumsMap) {\n\t\t// \t\t\t// Mark this enumsMap as null to denote that it doesn't\n\t\t// \t\t\t// exist across all dataConfigs we are combining\n\t\t// \t\t\tcombinedDataConfig.enumsMap[j] = null;\n\t\t// \t\t} else {\n\t\t// \t\t\tif (combinedDataConfig.enumsMap[j] !== null) {\n\t\t// \t\t\t\tcombinedDataConfig.enumsMap[j] = combinedDataConfig.enumsMap[j] || [];\n\n\t\t// \t\t\t\tfor (let k = 0; k < originalEnumsMap.length; k++) {\n\t\t// \t\t\t\t\tlet originalCol = originalEnumsMap[k];\n\t\t// \t\t\t\t\tlet originalColName = undefined;\n\t\t// \t\t\t\t\tfor (let l in dataConfig.cols) {\n\t\t// \t\t\t\t\t\tif (dataConfig.cols[l] === originalCol) {\n\t\t// \t\t\t\t\t\t\toriginalColName = l;\n\t\t// \t\t\t\t\t\t\tbreak;\n\t\t// \t\t\t\t\t\t}\n\t\t// \t\t\t\t\t}\n\n\t\t// \t\t\t\t\tif (originalColName) {\n\t\t// \t\t\t\t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\n\n\t\t// \t\t\t\t\t\tif (combinedDataConfig.enumsMap[j].indexOf(originalColIndex) === -1) {\n\t\t// \t\t\t\t\t\t\tcombinedDataConfig.enumsMap[j].push(combinedDataConfig.cols[originalColName]);\n\t\t// \t\t\t\t\t\t}\n\t\t// \t\t\t\t\t}\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\n\t\t// \tfor (let j in combinedDataConfig.enumsMap) {\n\t\t// \t\tif (combinedDataConfig.enumsMap[j] === null) {\n\t\t// \t\t\tdelete combinedDataConfig[enumsMap[j]];\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t\t// combinedDataConfig.enums = Analyser._buildEnums(combinedDataConfig.rows, combinedDataConfig);\n\n\t\t// return combinedDataConfig;\n\t},\n\n\t/////////////////\n\t// CSV PARSING //\n\t/////////////////\n\t_extractValue: function (string) {\n\t\t// Convert strings to booleans or numbers where possible\n\n\t\tif (string === 'true') {\n\t\t\treturn true;\n\t\t} else if (string === 'false') {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn Analyser._extractNumber(string);\n\t\t}\n\t},\n\n\t_extractNumber: function (string) {\n\t\t// Convert strings to numbers where possible\n\n\t\tlet val = string.replace(/,|%$/g, '');\n\n\t\tif (parseFloat(val) === +val) {\n\t\t\tconst isPercentage = string.match(/%$/);\n\n\t\t\tif (isPercentage) {\n\t\t\t\t// If the value is a percentage, divide by 100\n\n\t\t\t\t// Convert to string to see how many places after the point, to round after dividing\n\t\t\t\t// Otherwise you'll get numbers like 0.10800000000000001\n\t\t\t\tlet stringVal = val + '';\n\t\t\t\tlet truncatedStringVal = stringVal.replace(/^[^.]+/, '');\n\t\t\t\tlet length = truncatedStringVal.length;\n\n\t\t\t\tval = val / 100;\n\t\t\t\tval = val.toFixed(length+2);\n\t\t\t}\n\t\t\treturn +val;\n\t\t} else {\n\t\t\treturn string;\n\t\t}\n\t},\n\n\t///////////////\n\t// FILTERING //\n\t///////////////\n\t_getAliasFilters: function (aliases) {\n\t\tconst by = function (colIndex, values) {\n\t\t\tconst filterFn = (row) => Analyser._applyFilter(row, colIndex, values, aliases);\n\n\t\t\tfilterFn.andBy = (colIndex, values) => {\n\t\t\t\treturn (row) => filterFn(row) && Analyser._applyFilter(row, colIndex, values, aliases);\n\t\t\t};\n\t\t\tfilterFn.orBy = (colIndex, values) => {\n\t\t\t\treturn (row) => filterFn(row) && Analyser._applyFilter(row, colIndex, values, aliases);\n\t\t\t};\n\n\t\t\tAnalyser._extendFilter(filterFn, aliases);\n\n\t\t\treturn filterFn;\n\t\t};\n\n\t\treturn by;\n\t},\n\n\t_extendFilter: function (filterFn, aliases) {\n\t\tfilterFn.andBy = (colIndex, values) => {\n\t\t\tconst newFilterFn = (row) => filterFn(row) && Analyser._applyFilter(row, colIndex, values, aliases);\n\n\t\t\tAnalyser._extendFilter(newFilterFn, aliases);\n\t\t\treturn newFilterFn;\n\t\t};\n\t\tfilterFn.orBy = (colIndex, values) => {\n\t\t\tconst newFilterFn = (row) => filterFn(row) || Analyser._applyFilter(row, colIndex, values, aliases);\n\n\t\t\tAnalyser._extendFilter(newFilterFn, aliases);\n\t\t\treturn newFilterFn;\n\t\t};\n\n\t\treturn filterFn;\n\t},\n\n\t_applyFilter: function (row, colIndex, values, aliases) {\n\t\t// Allow functions to be passed as filter tests\n\t\tif (values instanceof Function) {\n\t\t\treturn values(row[colIndex]);\n\t\t}\n\n\t\t// If one or more values is passed, test it against aliases\n\t\tif (!(values instanceof Array)) {\n\t\t\tvalues = [values];\n\t\t}\n\n\t\tconst cell = row[colIndex];\n\t\tlet cellValues;\n\n\t\tif (cell instanceof Array) {\n\t\t\tcellValues = cell;\n\t\t} else {\n\t\t\tcellValues = [cell];\n\t\t}\n\n\t\tfor (let cellValue of cellValues) {\n\t\t\tfor (let value of values) {\n\t\t\t\tif (Analyser._matchAlias(value, cellValue, aliases)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_matchAlias: function (cell, value, aliasSuperset) {\n\t\t// Checks if the value of a cell matches the value passed,\n\t\t// optionally taking one or more sets of aliases to match\n\n\t\t// The aliasSuperset is used because the default set of all\n\t\t// aliases will be used if no aliasSet is specified\n\n\t\tif (cell === value) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Could be array or object\n\t\tfor (let i in aliasSuperset) {\n\t\t\tconst aliasSet = aliasSuperset[i];\n\t\t\tfor (let aliasList of aliasSet) {\n\n\t\t\t\tif (\n\t\t\t\t\t(aliasList.indexOf(cell) !== -1) &&\n\t\t\t\t\t(aliasList.indexOf(value) !== -1)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t//////////////////////\n\t// HELPER FUNCTIONS //\n\t//////////////////////\n\tgetColNumber: function (colName) {\n\t\t// Takes in a string like \"CE\" and converts it to a row number like 82\n\n\t\tif (Number.isInteger(colName) && colName >= 0) {\n\t\t\t// A positive integer\n\t\t\treturn colName;\n\t\t} else if (!(typeof colName === 'string' || colName instanceof String)) {\n\t\t\t// Not a string\n\t\t\treturn null;\n\t\t} else if (colName.length === 0) {\n\t\t\t// Empty string\n\t\t\treturn null;\n\t\t}\n\n\t\tconst alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\t\tlet rowNumber = -1; // Adjust for 0-based counting\n\n\t\tconst upperColName = colName.toUpperCase();\n\t\tfor (let i = 0; i < upperColName.length; i++) {\n\t\t\tconst char = upperColName[i];\n\t\t\tconst charIndex = alphabet.indexOf(char);\n\n\t\t\tif (charIndex === -1) {\n\t\t\t\t// String contains invalid character\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\n\t\t}\n\n\t\treturn rowNumber;\n\t},\n\n\tgetColNumbers: function (cols) {\n\t\t// Takes in a flat object and runs each property through getColNumber\n\t\tconst newCols = {};\n\n\t\tfor (let key in cols) {\n\t\t\tnewCols[key] = Analyser.getColNumber(cols[key]);\n\t\t}\n\n\t\treturn newCols;\n\t},\n\n\t///////////////////\n\t// SUMMARY TOOLS //\n\t///////////////////\n\t_convertTableToString: function (table, useKeys, cellSeparatorOption, rowSeparatorOption) {\n\t\tconst cellSeparator = cellSeparatorOption || '\\t';\n\t\tconst rowSeparator = rowSeparatorOption || '\\n';\n\n\t\tlet tableString = '';\n\n\t\tconst addCell = (cellString) => {\n\t\t\tif (typeof cellString !== 'string') {\n\t\t\t\tcellString = '' + cellString;\n\t\t\t}\n\n\t\t\tif (cellString.indexOf(cellSeparator) !== -1) {\n\t\t\t\t// If the cell string contains the separator sequence,\n\t\t\t\t// wrap it in \" and escape any existing \" as \"\"\n\t\t\t\tcellString = '\"' + cellString.replace(/\"/g, '\"\"') + '\"';\n\t\t\t}\n\n\t\t\ttableString += cellString + cellSeparator;\n\t\t};\n\t\tconst endLine = () => {\n\t\t\t// Trim off last cell separator, replace with newline\n\t\t\ttableString = tableString.substr(0, tableString.length - cellSeparator.length) + rowSeparator;\n\t\t};\n\n\t\t// Render headers and create array of labels\n\t\tif (useKeys) {\n\t\t\ttableString += cellSeparator;\n\t\t}\n\n\t\tlet firstRowComplete = false;\n\t\tfor (let rowName in table) {\n\t\t\tif (firstRowComplete === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirstRowComplete = true;\n\n\t\t\tlet row = table[rowName];\n\t\t\tfor (let colName in row) {\n\t\t\t\taddCell(colName);\n\t\t\t}\n\t\t}\n\t\tendLine();\n\n\t\tfor (let rowName in table) {\n\t\t\tlet isFirstRow = false;\n\t\t\tconst row = table[rowName];\n\t\t\tfor (let colName in row) {\n\t\t\t\tconst cell = row[colName];\n\t\t\t\tif (useKeys) {\n\t\t\t\t\tif (isFirstRow === false) {\n\t\t\t\t\t\taddCell(rowName);\n\t\t\t\t\t}\n\t\t\t\t\tisFirstRow = true;\n\t\t\t\t}\n\n\t\t\t\taddCell(cell);\n\t\t\t}\n\t\t\tendLine();\n\t\t}\n\n\t\treturn tableString;\n\t},\n\n\t_groupColSummaryByAliases: function (summary, aliasList) {\n\t\t// Takes a summary object like the output from getColSummary, and\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\n\n\t\t// Outputs a summary object where values within the same set of aliases are grouped\n\n\t\tconst newSummary = {};\n\t\tfor (let i in summary) {\n\t\t\tlet inAlias = false;\n\t\t\tfor (let aliases of aliasList) {\n\t\t\t\tif (aliases.indexOf(i) !== -1) {\n\t\t\t\t\tinAlias = true;\n\t\t\t\t\tif (aliases[0] in newSummary) {\n\t\t\t\t\t\tnewSummary[aliases[0]] += summary[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewSummary[aliases[0]] = summary[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inAlias === false) {\n\t\t\t\tnewSummary[i] = summary[i];\n\t\t\t}\n\t\t}\n\n\t\treturn newSummary;\n\t}\n};\n\nexport const {\n\tloadFile,\n\t// combineData, // TODO: Rewrite\n\n\tgetColNumber,\n\tgetColNumbers,\n} = Analyser;\n","import * as analyser from '/analyser.js';\n\nconst analyse = async function () {\n\tlet fileInfoA = {\n\t\tpath: '/analyser/assets/data/city example.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tNAME: analyser.getColNumber('A'),\n\t\t\tCOUNTRY: analyser.getColNumber('B'),\n\t\t\tPOPULATION: analyser.getColNumber('C'),\n\t\t\tCAPITAL: analyser.getColNumber('D'),\n\t\t\tPUBLIC_TRANSPORT: analyser.getColNumber('E'),\n\t\t\tMAYOR_2012: analyser.getColNumber('F'),\n\t\t\tMAYOR_2018: analyser.getColNumber('G')\n\t\t},\n\t\tarrayCols: {},\n\t\taliases: {\n\t\t\tCOUNTRY: [\n\t\t\t\t['New Zealand', 'Aotearoa']\n\t\t\t]\n\t\t},\n\t\tenumsMap: {},\n\t};\n\tfileInfoA.arrayCols[fileInfoA.cols.PUBLIC_TRANSPORT] = ',';\n\tfileInfoA.arrayCols[fileInfoA.cols.MAYOR_2018] = ',';\n\n\tlet fileInfoB = {\n\t\tpath: '/analyser/assets/data/city example 2.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tNAME: analyser.getColNumber('A'),\n\t\t\tCOUNTRY: analyser.getColNumber('B'),\n\t\t\tPOPULATION: analyser.getColNumber('C')\n\t\t}\n\t};\n\tlet fileInfoC = {\n\t\tpath: '/analyser/assets/data/city example 3.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tYEAR: analyser.getColNumber('A'),\n\t\t\tPOPULATION: analyser.getColNumber('B')\n\t\t}\n\t};\n\n\tlet [cityData, cityData2, cityData3] = await analyser.loadFile(fileInfoA, fileInfoB, fileInfoC);\n\n\t// console.log(cityData.rows);\n\t// console.log(cityData.rows[0]);\n\n\t// console.log(cityData2.rows);\n\t// console.log(cityData2.rows[0]);\n\n\t// console.log(cityData3.rows);\n\t// console.log(cityData3.rows[0]);\n\n\tconst {\n\t\trows,\n\t\tcols,\n\t\tby,\n\t} = cityData;\n\n\tconsole.log(rows);\n\tconsole.log(cols);\n\n\tconsole.log(rows.filter(\n\t\tby(cols.POPULATION, pop => pop > 1000)\n\t\t.andBy(cols.PUBLIC_TRANSPORT, 'Train')\n\t\t.orBy(cols.PUBLIC_TRANSPORT, 'Bus')\n\t));\n};\n\nanalyse();\n"],"sourceRoot":""}