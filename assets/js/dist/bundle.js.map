{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/csv/csv.js","webpack:///./analyser.js","webpack:///./docs/assets/js/src/main.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","stringify","parse","csv","data","options","transpose","sanitise","rows","_shape","_escape","_join","maxLength","reduce","row","Math","max","length","iMax","jMax","j","iRow","iCol","cellValue","push","match","replace","join","csvString","_tokenise","_validate","mapper","map","tokens","inQuote","wasQuote","tokenStart","char","comma","quote","newline","eof","Error","token","substring","rowLength","AnalyserRows","Array","sourceArray","super","this","colNum","col","colIndex","entries","processFn","cols","derivedValues","apply","callback","derivedCol","getDerivedCol","arguments","addCol","arraySeparator","newRow","colName","cell","table","createSubTable","Analyser","_convertTableToString","aliasList","summary","values","_groupColSummaryByAliases","labels","colSummary","getColSummary","dataSeries","index","indexOf","parseInt","headerCol","headerAliases","varCol","varAliases","undefined","console","log","trace","headerSummary","varSummary","aliases","HEADERS","VARS","filters","_getAliasFilters","comparisonSummary","filterRows","_extractValue","getComparisonSummary","_loadFile","async","fileConfig","response","fetch","path","ok","text","_parseCsv","_processData","status","loadFile","fileConfigArr","Promise","resolve","reject","promises","all","then","headerRows","footerRows","arrayCols","enumsMap","uniqueCols","dataConfig","splice","trim","split","defaultColValues","defaultCols","_createRowFilterFunctions","enums","_buildEnums","config","collect","includes","enumCol","_collectEnums","concat","enumsArr","k","combineData","dataConfigs","combinedDataConfig","error","aliasSet","combinedAliasSet","filter","alias","array","originalCol","originalColName","originalColIndex","originalEnumsMap","string","_extractNumber","val","parseFloat","toFixed","orToggle","colIndex1","values1","colIndex2","values2","colIndexN","valuesN","and","startAt","filteredRows","isArray","Function","isMatch","_applyFilter","filterAnd","filterOr","filterRowsAnd","args","slice","filterRowsOr","from","cellValues","_matchAlias","aliasSuperset","getColNumber","String","alphabet","rowNumber","toUpperCase","charIndex","pow","getColNumbers","newCols","Number","isInteger","useKeys","cellSeparatorOption","rowSeparatorOption","cellSeparator","rowSeparator","tableString","addCell","cellString","endLine","substr","firstRowComplete","rowName","isFirstRow","newSummary","inAlias","getCol","fileInfoA","DATE","REMAND_MALE","REMAND_FEMALE","REMAND_TOTAL","SENTENCED_MALE","SENTENCED_FEMALE","SENTENCED_TOTAL","TOTAL_MALE","TOTAL_TOTAL","ETHNICITY_MAORI","ETHNICITY_EUROPEAN","ETHNICITY_PACIFIC","ETHNICITY_ASIAN","ETHNICITY_OTHER","ETHNICITY_UNKNOWN","ETHNICITY_TOTAL","PER_100_000_POPULATION","fileInfoB","TACTICAL_OPTION","EUROPEAN","MAORI","PACIFIC","OTHER","dataConfigArr","newCol","num","newColIndex","derivedColIndex","addDerivedCol","extraVal1","createSubTableString","getColAsDataSeries","keys","comparisonSummaryString","getComparisonSummaryString","analyse"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,G,sCClFrD,MAAM,UAAEC,EAAS,MAAEC,GAAU,MAC5B,MAAMC,EAAM,CACXF,UAAW,SAAUG,EAAMC,IAC1BA,EAAUA,GAAW,IACbC,UAAYD,EAAQC,YAAa,EACzCD,EAAQE,SAAWF,EAAQE,WAAY,EAGvC,IAAIC,EAAOJ,EAOX,OALAI,EAAOL,EAAIM,OAAOL,EAAMC,GACxBG,EAAOL,EAAIO,QAAQF,EAAMH,GAEzBG,EAAOL,EAAIQ,MAAMH,GAEVA,GAGRC,OAAQ,SAAUL,EAAMC,GAIvB,MAAMC,EAAYD,EAAQC,UAEpBM,EAAYR,EAAKS,OAAO,CAACD,EAAWE,IAAQC,KAAKC,IAAIJ,EAAWE,EAAIG,QAAS,GAG7EC,EAAOZ,EAAYM,EAAYR,EAAKa,OACpCE,EAAOb,EAAYF,EAAKa,OAASL,EAEvC,IAAIJ,EAAO,GACX,IAAK,IAAIvC,EAAI,EAAGA,EAAIiD,EAAMjD,IAAK,CAC9B,IAAI6C,EAAM,GACV,IAAK,IAAIM,EAAI,EAAGA,EAAID,EAAMC,IAAK,CAC9B,IAAIC,EAAOf,EAAYc,EAAInD,EACvBqD,EAAOhB,EAAYrC,EAAImD,EAEvBG,EAAYnB,EAAKiB,GAAMC,GAEvBA,GAAQlB,EAAKiB,GAAMJ,SACtBM,EAAY,IAGbT,EAAIU,KAAKD,GAEVf,EAAKgB,KAAKV,GAGX,OAAON,GAGRE,QAAS,SAAUF,EAAMH,GAGxB,MAAME,EAAWF,EAAQE,SAEzB,IAAK,IAAItC,EAAI,EAAGA,EAAIuC,EAAKS,OAAQhD,IAAK,CACrC,IAAI6C,EAAMN,EAAKvC,GAEf,IAAK,IAAImD,EAAI,EAAGA,EAAIN,EAAIG,OAAQG,SACT,IAAXN,EAAIM,GAEdN,EAAIM,GAAK,GACmB,iBAAXN,EAAIM,KAErBN,EAAIM,GAAK,GAAKN,EAAIM,IAGfb,GAGCO,EAAIM,GAAGK,MAAM,cAChBX,EAAIM,GAAK,KAAON,EAAIM,IAIlBN,EAAIM,GAAGK,MAAM,YAGhBX,EAAIM,GAAKN,EAAIM,GAAGM,QAAQ,KAAM,MAG9BZ,EAAIM,GAAK,IAAMN,EAAIM,GAAK,KAK3B,OAAOZ,GAGRG,MAAO,SAAUH,GAChB,IAAK,IAAIvC,EAAI,EAAGA,EAAIuC,EAAKS,OAAQhD,IAChCuC,EAAKvC,GAAKuC,EAAKvC,GAAG0D,KAAK,KAIxB,OAFAnB,EAAOA,EAAKmB,KAAK,OAMlBzB,MAAO,SAAU0B,EAAWvB,GAC3B,IAAIG,EAAOL,EAAI0B,UAAUD,GAQzB,OANAzB,EAAI2B,UAAUtB,GAEVH,GAAWA,EAAQ0B,SACtBvB,EAAOA,EAAKwB,IAAKlB,GAAQA,EAAIkB,IAAI3B,EAAQ0B,UAGnCvB,GAGRqB,UAAW,SAAUD,GAGpB,IAAIK,EAAS,GAGbL,EAAYA,EAAUF,QAAQ,MAAO,IAErC,IAAIQ,GAAU,EACVC,GAAW,EAEXC,EAAa,EACbtB,EAAM,GACV,IAAK,IAAI7C,EAAI,EAAGA,EAAI2D,EAAUX,OAAQhD,IAAK,CAC1C,IAAIoE,EAAOT,EAAU3D,GAEjBqE,EAAiB,MAATD,EACRE,EAAiB,MAATF,EACRG,EAAmB,OAATH,EACVI,EAAMxE,IAAM2D,EAAUX,OAAQ,EAElC,GAAIiB,EAEH,GAAIK,EAAO,CAIV,GAAiB,MAFFX,EAAU3D,EAAE,GAEL,CAGrBA,IACA,SAMA,GAHAiE,GAAU,EACVC,GAAW,GAENM,EACJ,cAGI,GAAIA,EACV,MAAM,IAAIC,MAAM,gEAAgEzE,GAIlF,IAAKiE,IAAYI,GAASE,GAAWC,GAAM,CAE1C,IAAIE,EAAQf,EAAUgB,UAAUR,EAAYnE,EAAE,IAE1CqE,GAASE,KAEZG,EAAQA,EAAMC,UAAU,EAAGD,EAAM1B,OAAS,IAGvCkB,IACHA,GAAW,EAGXQ,EAAQA,EAAMC,UAAU,EAAGD,EAAM1B,OAAS,GAG1C0B,EAAQA,EAAMjB,QAAQ,MAAO,MAE9BZ,EAAIU,KAAKmB,GAELL,GAASG,GAEZ3B,EAAIU,KAAK,KAGNgB,GAAWC,KACdR,EAAOT,KAAKV,GACR0B,IACH1B,EAAM,KAIRsB,EAAanE,EAAE,MACT,IAAIkE,EACV,MAAM,IAAIO,MAAM,mFAAmFzE,GACzFsE,IACVL,GAAU,IAIZ,OAAOD,GAGRH,UAAW,SAAUtB,GAGpB,GAAIA,GAAQA,EAAKS,OAAS,EAAG,CAC5B,IAAI4B,EAAYrC,EAAK,GAAGS,OACxB,IAAK,IAAIhD,EAAI,EAAGA,EAAIuC,EAAKS,OAAQhD,IAAK,CAGrC,GAFUuC,EAAKvC,GAEPgD,SAAW4B,EAClB,MAAM,IAAIH,MAAM,kBAAkBzE,qDAAqD4E,UAO5F,MAAO,CACN5C,UAAWE,EAAIF,UACfC,MAAOC,EAAID,QA3NgB,GCE7B,MAAM4C,UAAqBC,MAC1B,YAAYC,GAIXC,MAAMD,EAAY/B,QAClB,IAAK,IAAIhD,EAAI,EAAGA,EAAI+E,EAAY/B,OAAQhD,IACvCiF,KAAKjF,GAAK+E,EAAY/E,GAQxB,OAAOkF,GAEN,OADUD,KAAKlB,IAAKlB,GAAQA,EAAIqC,IAQjC,OAAOC,GAIN,GAAIF,KAAKjC,SAAWmC,EAAInC,OACvB,MAAM,IAAIyB,MAAM,4BAA4BU,EAAInC,4BAA4BiC,KAAKjC,UAGlF,IAAIoC,EAAWH,KAAK,GAAGjC,OAEvB,IAAK,IAAKhD,EAAG6C,KAAQoC,KAAKI,UACzBxC,EAAIU,KAAK4B,EAAInF,IAGd,OAAOoF,EAGR,cAAcE,KAAcC,GAgB3B,OAViBN,KAAKlB,IAAI,CAAClB,EAAK7C,KAC/B,IAAIwF,EAAgB,CAAC3C,GAErB,IAAK,IAAIsC,KAAOI,EACfC,EAAcjC,KAAK4B,EAAInF,IAGxB,OAAOsF,EAAUG,MAAMR,KAAMO,KAM/B,cAAcE,KAAaH,GAK1B,IAAII,EAAaV,KAAKW,cAAcH,MAAMR,KAAMY,WAEhD,OAAOZ,KAAKa,OAAOH,GAOpB,eAAeJ,EAAMQ,GA8BpB,OAnBAA,EAAiBA,GAAkB,KAEvBd,KAAKlB,IAAKlB,IACrB,IAAImD,EAAS,GAEb,IAAK,IAAIC,KAAWV,EAAM,CACzB,IACIW,EAAOrD,EADD0C,EAAKU,IAIdD,EAAOC,GADJC,aAAgBpB,MACDoB,EAAKxC,KAAKqC,GAEVG,EAIpB,OAAOF,IAMT,qBAAqBT,GACpB,IAAIY,EAAQlB,KAAKmB,eAAeb,EAAM,KAGtC,OAFkBc,EAASC,sBAAsBH,GAKlD,cAAcZ,EAAMgB,GASbhB,aAAgBT,QACrBS,EAAO,CAACA,IAGT,IAAIiB,EAAU,GACd,IAAK,IAAI3D,KAAOoC,KACf,IAAK,IAAIE,KAAOI,EAAM,CACrB,IAAIjC,EAAYT,EAAIsC,GAEpB,QAAyB,IAAd7B,GAA2C,KAAdA,EAAkB,CAEzD,IAAImD,EAEHA,EADGnD,aAAqBwB,MACfxB,EAEA,CAACA,GAGX,IAAK,IAAIrC,KAASwF,EACbxF,KAASuF,EACZA,EAAQvF,KAERuF,EAAQvF,GAAS,GAatB,YAJyB,IAAdsF,IACVC,EAAUH,EAASK,0BAA0BF,EAASD,IAGhDC,EAGR,mBAAmBrB,EAAKwB,GAMvB,IAAIC,EAAa3B,KAAK4B,cAAc1B,GAEhC2B,EAAa,GAEjB,IAAK,IAAI9G,EAAI,EAAGA,EAAI2G,EAAO3D,OAAQhD,IAClC8G,EAAW9G,GAAK,EAGjB,IAAK,IAAIA,KAAK4G,EAAY,CACzB,IAAI3F,EAAQ2F,EAAW5G,GACnB+G,EAAQJ,EAAOK,QAAQhH,IACZ,IAAX+G,IAEHA,EAAQJ,EAAOK,QAAQC,SAASjH,EAAG,OAGrB,IAAX+G,IACHD,EAAWC,GAAS9F,GAItB,OAAO6F,EAGR,qBAAqBI,EAAWC,EAAeC,EAAQC,GAU7B,IAArBxB,UAAU7C,QAEboE,EAASD,EACTA,OAAgBG,GACe,IAArBzB,UAAU7C,SAEdmE,aAAyBrC,QAE9BuC,EAAaD,EACbA,EAASD,EACTA,OAAgBG,IAIlBC,QAAQC,IAAIvC,MACZsC,QAAQE,QACR,IAAIC,EAAgBzC,KAAK4B,cAAcK,EAAWC,GAC9CQ,EAAa1C,KAAK4B,cAAcO,EAAQC,GAExCO,EAAU,GACVT,IACHS,EAAQC,QAAUV,GAEfE,IACHO,EAAQE,KAAOT,GAEhB,IAAIU,EAAU1B,EAAS2B,iBAAiBJ,GAEpCK,EAAoB,GACxB,IAAK,IAAIjI,KAAK2H,EAAY,CACzBM,EAAkBjI,GAAK,GACvB,IAAK,IAAImD,KAAKuE,EACbO,EAAkBjI,GAAGmD,GAAK4E,EAAQG,WAAWjD,KAC5CmC,EAAQf,EAAS8B,cAAcnI,GAC/BkH,EAAWb,EAAS8B,cAAchF,IACjCH,OAIJ,OAAOiF,EAGR,2BAA2Bf,EAAWC,EAAeC,EAAQC,GAK5D,IAAIY,EAAoBhD,KAAKmD,qBAAqB3C,MAAMR,KAAMY,WAG9D,OAF8BQ,EAASC,sBAAsB2B,GAAmB,IAMlF,MAAM5B,EAAW,CAIhBgC,UAAWC,eAAgBC,GAC1B,IAAIC,QAAiBC,MAAMF,EAAWG,MAEtC,GAAIF,EAASG,GAAI,CAChB,IAAIxG,QAAaqG,EAASI,OAEtBrG,EAAO8D,EAASwC,UAAU1G,GAE9B,OADiBkE,EAASyC,aAAavG,EAAMgG,GAG7C,MAAM,IAAI9D,MAAM,2BAA2B8D,EAAWG,SAASF,EAASO,WAI1EC,SAAU,YAAaC,GACtB,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAE5B,IAAIC,EAAWJ,EAAclF,IAAKwE,GAAelC,EAASgC,UAAUE,IACpEW,QAAQI,IAAID,GAAUE,KAAKJ,MAI7BL,aAAc,SAAUvG,EAAMgG,GA+C7BA,EAAWiB,WAAajB,EAAWiB,YAAc,EACjDjB,EAAWkB,WAAalB,EAAWkB,YAAc,EACjDlB,EAAWhD,KAAOgD,EAAWhD,MAAQ,GACrCgD,EAAWX,QAAUW,EAAWX,SAAW,GAC3CW,EAAWmB,UAAYnB,EAAWmB,WAAa,GAC/CnB,EAAWoB,SAAWpB,EAAWoB,UAAY,GAC7CpB,EAAWqB,WAAarB,EAAWqB,YAAc,GAEjD,IAAIC,EAAa,GACjBA,EAAWtE,KAAOgD,EAAWhD,KAC7BsE,EAAWjC,QAAUW,EAAWX,QAChCiC,EAAW9B,QAAU1B,EAAS2B,iBAAiBO,EAAWX,SAC1DiC,EAAWF,SAAWpB,EAAWoB,SAEH,IAA1BpB,EAAWiB,YAEdjH,EAAKuH,OAAO,EAAGvB,EAAWiB,YAGG,IAA1BjB,EAAWkB,YAEdlH,EAAKuH,QAAQvB,EAAWkB,YAIzBI,EAAWtH,KAAO,IAAIsC,EAAatC,GACnC,IAAK,IAAIvC,EAAI,EAAGA,EAAI6J,EAAWtH,KAAKS,OAAQhD,IAAK,CAChD,IAAI6C,EAAMgH,EAAWtH,KAAKvC,GAE1B,IAAK,IAAImD,KAAKoF,EAAWmB,UACxB7G,EAAIM,IAAMN,EAAIM,GAAK,IAAI4G,OAAOC,MAAMzB,EAAWmB,UAAUvG,IAAM,KAIhE,IAAK,IAAIA,KAAKoF,EAAW0B,iBACpB9G,KAAKoF,EAAWmB,WAGf7G,EAAIM,GAAK,IAASoF,EAAW0B,iBAAiB9G,GAAK,KACvDN,EAAIM,GAAK,IAKX,IAAK,IAAIA,KAAKoF,EAAW2B,YACpB/G,KAAKoF,EAAWmB,WAGS,MAAxB7G,EAAIM,GAAK,IAAI4G,SACjBlH,EAAIM,GAAKoF,EAAW2B,YAAY/G,IAWnC,OALAkD,EAAS8D,0BAA0BN,EAAWtH,KAAMsH,EAAW9B,SAG/D8B,EAAWO,MAAQ/D,EAASgE,YAAY9H,EAAMgG,GAEvCsB,GAGRQ,YAAa,SAAU9H,EAAM+H,GAC5B,IAAIF,EAAQ,GAEZ,IAAK,IAAIjF,KAAOmF,EAAO/E,KAAM,CAG5B,IAAIgF,GAAU,EACVD,EAAOV,WAAWY,SAASF,EAAO/E,KAAKJ,MAC1CoF,GAAU,GAEX,IAAK,IAAIE,KAAWH,EAAOX,SAC1B,GAAIW,EAAOX,SAASc,GAASD,SAASF,EAAO/E,KAAKJ,IAAO,CACxDoF,GAAU,EACV,MAIEA,IACHH,EAAMjF,GAAO,GACbkB,EAASqE,cAAcnI,EAAM6H,EAAMjF,GAAMmF,EAAO/E,KAAKJ,KAGvD,IAAK,IAAIsF,KAAWH,EAAOX,SAC1BS,EAAMK,GAAW,GACjBpE,EAASqE,cAAcjF,MAAMR,KAAM,CAAC1C,EAAM6H,EAAMK,IAAUE,OAAOL,EAAOX,SAASc,KAGlF,OAAOL,GAGRM,cAAe,SAAUnI,EAAMqI,KAAarF,GAI3CqF,EAAWA,GAAY,GAEvB,IAAK,IAAI5K,EAAI,EAAGA,EAAIuC,EAAKS,OAAQhD,IAAK,CACrC,IAAI6C,EAAMN,EAAKvC,GACf,IAAK,IAAImD,EAAI,EAAGA,EAAIoC,EAAKvC,OAAQG,IAAK,CACrC,IAAIgC,EAAMI,EAAKpC,GAEf,GAAIN,EAAIsC,aAAgBL,MACvB,IAAK,IAAI+F,EAAI,EAAGA,EAAIhI,EAAIsC,GAAKnC,OAAQ6H,IACf,KAAhBhI,EAAIsC,GAAK0F,KAAkD,IAAnCD,EAAS5D,QAAQnE,EAAIsC,GAAK0F,KACtDD,EAASrH,KAAKV,EAAIsC,GAAK0F,QAIP,KAAbhI,EAAIsC,KAAiD,IAAhCyF,EAAS5D,QAAQnE,EAAIsC,KAC9CyF,EAASrH,KAAKV,EAAIsC,KAMtB,OAAOyF,GAGRE,YAAa,YAAaC,GAUzB,IAAIC,EAAqB,CACxBzF,KAAM,GACNhD,KAAM,IAAIsC,EAAa,IACvB+C,QAAS,MAGLmD,GAAeA,EAAY/H,OAAS,IACxCuE,QAAQ0D,MAAM,uCAAwCpF,WAMvD,IAAK,IAAI1C,KAAK4H,EAAY,GAAGxF,KAC5ByF,EAAmBzF,KAAKpC,IAAK,EAI9B,IAAK,IAAInD,EAAI,EAAGA,EAAI+K,EAAY/H,OAAQhD,IAAK,CAC5C,IAAI6J,EAAakB,EAAY/K,GAE7B,IAAK,IAAImD,KAAK6H,EAAmBzF,KAC1BpC,KAAK0G,EAAWtE,aACdyF,EAAmBzF,KAAKpC,GAKlC,IAAIiC,EAAW,EACf,IAAK,IAAIjC,KAAK6H,EAAmBzF,KAChCyF,EAAmBzF,KAAKpC,GAAKiC,EAC7BA,IAID,IAAK,IAAIpF,EAAI,EAAGA,EAAI+K,EAAY/H,OAAQhD,IAAK,CAC5C,IAAI6J,EAAakB,EAAY/K,GAG7B,IAAK,IAAImD,EAAI,EAAGA,EAAI0G,EAAWtH,KAAKS,OAAQG,IAAK,CAChD,IAAIN,EAAM,GACV,IAAK,IAAIgI,KAAKG,EAAmBzF,KAChC1C,EAAImI,EAAmBzF,KAAKsF,IAAMhB,EAAWtH,KAAKY,GAAG0G,EAAWtE,KAAKsF,IAGtEG,EAAmBzI,KAAKgB,KAAKV,GAO9B,IAAK,IAAIM,KAAK0G,EAAWjC,QAAS,CAG3BzE,KAAK6H,EAAmBpD,UAC7BoD,EAAmBpD,QAAQzE,GAAK,IAIjC,IAAK,IAAI0H,EAAI,EAAGA,EAAIhB,EAAWjC,QAAQzE,GAAGH,OAAQ6H,IAAK,CACtD,IAII5K,EAJAiL,EAAWrB,EAAWjC,QAAQzE,GAAG0H,GAGjCM,EAAmB,GAEvB,IAAKlL,EAAI,EAAGA,EAAI+K,EAAmBpD,QAAQzE,GAAGH,OAAQ/C,IACrD,GAAI+K,EAAmBpD,QAAQzE,GAAGlD,GAAG,KAAOiL,EAAS,GAAI,CACxDC,EAAmBH,EAAmBpD,QAAQzE,GAAGlD,GACjD,MAIFkL,EAAmBA,EAAiBR,OAAOO,GAG3CC,EAAmBA,EAAiBC,QAAO,SAAUC,EAAOtE,EAAOuE,GAClE,OAAOA,EAAMtE,QAAQqE,KAAWtE,KAI7B9G,EAAI+K,EAAmBpD,QAAQzE,GAAGH,OACrCgI,EAAmBpD,QAAQzE,GAAGlD,GAAKkL,EAEnCH,EAAmBpD,QAAQzE,GAAGI,KAAK4H,KAOvCH,EAAmBjD,QAAU1B,EAAS2B,iBAAiBgD,EAAmBpD,SAC1EvB,EAAS8D,0BAA0Ba,EAAmBzI,KAAMyI,EAAmBjD,SAG/EiD,EAAmBpB,WAAa,GAChC,IAAK,IAAI5J,EAAI,EAAGA,EAAI+K,EAAY/H,OAAQhD,IAAK,CAC5C,IAAI6J,EAAakB,EAAY/K,GAE7B,IAAK,IAAImD,KAAK0G,EAAWD,WAAY,CACpC,IAAI2B,EAAc1B,EAAWD,WAAWzG,GACpCqI,OAAkBlE,EACtB,IAAK,IAAIuD,KAAKhB,EAAWtE,KACxB,GAAIsE,EAAWtE,KAAKtF,KAAOsL,EAAa,CACvCC,EAAkBvL,EAClB,MAIF,GAAIuL,EAAiB,CACpB,IAAIC,EAAmBT,EAAmBzF,KAAKiG,IAEkB,IAA7DR,EAAmBpB,WAAW5C,QAAQyE,IACzCT,EAAmBpB,WAAWrG,KAAKyH,EAAmBzF,KAAKiG,MAO/DR,EAAmBrB,SAAW,GAC9B,IAAK,IAAI3J,EAAI,EAAGA,EAAI+K,EAAY/H,OAAQhD,IAAK,CAC5C,IAAI6J,EAAakB,EAAY/K,GAE7B,IAAK,IAAImD,KAAK0G,EAAWF,SAAU,CAClC,IAAI+B,EAAmB7B,EAAWF,SAASxG,GAE3C,GAAKuI,GAKJ,GAAuC,OAAnCV,EAAmBrB,SAASxG,GAAa,CAC5C6H,EAAmBrB,SAASxG,GAAK6H,EAAmBrB,SAASxG,IAAM,GAEnE,IAAK,IAAI0H,EAAI,EAAGA,EAAIa,EAAiB1I,OAAQ6H,IAAK,CACjD,IAAIU,EAAcG,EAAiBb,GAC/BW,OAAkBlE,EACtB,IAAK,IAAIrH,KAAK4J,EAAWtE,KACxB,GAAIsE,EAAWtE,KAAKtF,KAAOsL,EAAa,CACvCC,EAAkBvL,EAClB,MAIF,GAAIuL,EAAiB,CACpB,IAAIC,EAAmBT,EAAmBzF,KAAKiG,IAEmB,IAA9DR,EAAmBrB,SAASxG,GAAG6D,QAAQyE,IAC1CT,EAAmBrB,SAASxG,GAAGI,KAAKyH,EAAmBzF,KAAKiG,YAnBhER,EAAmBrB,SAASxG,GAAK,KA2BnC,IAAK,IAAIA,KAAK6H,EAAmBrB,SACO,OAAnCqB,EAAmBrB,SAASxG,WACxB6H,EAAmBrB,SAASxG,IAMtC,OAFA6H,EAAmBZ,MAAQ/D,EAASgE,YAAYW,EAAmBzI,KAAMyI,GAElEA,GAMRnC,UAAW,SAAU3G,GAOpB,OAFWD,EAAMC,EAAK,CAAE4B,OAAQuC,EAAS8B,iBAK1CA,cAAe,SAAUwD,GAGxB,MAAe,SAAXA,GAEkB,UAAXA,GAGHtF,EAASuF,eAAeD,IAIjCC,eAAgB,SAAUD,GAGzB,IAAIE,EAAMF,EAAOlI,QAAQ,QAAS,IAElC,GAAIqI,WAAWD,MAAUA,EAAK,CAC7B,GAAIF,EAAOnI,MAAM,MAAO,CAKvB,IAAIR,EAAU6I,EAAM,GACpB7I,EAAOS,QAAQ,SAAU,IACzBT,EAASA,EAAOA,OAEhB6I,GAAY,IACZA,EAAMA,EAAIE,QAAQ/I,EAAO,GAE1B,OAAQ6I,EAER,OAAOF,GAOT3D,iBAAkB,SAAUJ,GAC3B,MAAMM,EAAa,SAAU3F,EAAMyJ,EAAUC,EAAWC,EAASC,EAAWC,EAASC,EAAWC,GAU/F,IAAIC,GAAOP,EACPQ,EAAU,EAEVC,EAAe,GAEnB,IAAK5G,UAAU7C,OAAS,IAAS6C,UAAU7C,OAAO,GAAK,GAAO,KAE7DuJ,GAAM,EACNC,EAAU,EACL3G,UAAU7C,OAAS,IAAS6C,UAAU7C,OAAO,GAAK,GAAO,GAE7D,OADAuE,QAAQ0D,MAAM,wDACP,GAIT,IAAIlD,EAAU,GACd,IAAK,IAAI/H,EAAIwM,EAASxM,EAAI6F,UAAU7C,OAAO,EAAGhD,GAAK,EAAG,CACrD,IAAIoL,EAAS,CACZhG,SAAUS,UAAU7F,GACpByG,OAAQZ,UAAU7F,EAAE,IAGf8E,MAAM4H,QAAQtB,EAAO3E,SAAW2E,EAAO3E,kBAAkBkG,WAC9DvB,EAAO3E,OAAS,CAAC2E,EAAO3E,SAGzBsB,EAAQxE,KAAK6H,GAGd,IAAK,IAAIpL,EAAI,EAAGA,EAAIuC,EAAKS,OAAQhD,IAAK,CACrC,IAAI6C,EAAMN,EAAKvC,GAEX4M,IAAYL,EAEhB,IAAK,IAAIpJ,EAAI,EAAGA,EAAI4E,EAAQ/E,OAAQG,IAAK,CACxC,IAAIiI,EAASrD,EAAQ5E,GAGpByJ,EADGL,EACOK,GAAWvG,EAASwG,aAAahK,EAAKuI,EAAOhG,SAAUgG,EAAO3E,OAAQmB,GAEtEgF,GAAWvG,EAASwG,aAAahK,EAAKuI,EAAOhG,SAAUgG,EAAO3E,OAAQmB,GAI9EgF,GACHH,EAAalJ,KAAKV,GASpB,OALA4J,EAAe,IAAI5H,EAAa4H,GAChCA,EAAarB,OAAS7I,EAAK6I,OAC3BqB,EAAaK,UAAYvK,EAAKuK,UAC9BL,EAAaM,SAAWxK,EAAKwK,SAEtBN,GAuBR,MAAO,CACNvE,WAAYA,EACZ8E,cAtBqB,SAAUzK,EAAM0J,EAAWC,EAASC,EAAWC,EAASC,EAAWC,GACxF,IAAIW,EAAOnI,MAAMlD,UAAUsL,MAAMzH,MAAMI,WAMvC,OAJAoH,EAAOA,EAAKC,MAAM,GAClBD,EAAKnD,OAAO,EAAG,GAAG,GAClBmD,EAAKnD,OAAO,EAAG,EAAGvH,GAEX2F,EAAWzC,MAAMR,KAAMgI,IAgB9BE,aAboB,SAAU5K,EAAM0J,EAAWC,EAASC,EAAWC,EAASC,EAAWC,GACvF,IAAIW,EAAOnI,MAAMlD,UAAUsL,MAAMzH,MAAMI,WAMvC,OAJAoH,EAAOA,EAAKC,MAAM,GAClBD,EAAKnD,OAAO,EAAG,GAAG,GAClBmD,EAAKnD,OAAO,EAAG,EAAGvH,GAEX2F,EAAWzC,MAAMR,KAAMgI,MAUhC9C,0BAA2B,SAAU5H,EAAMwF,GAC1CxF,EAAK6I,OAAS,WACb,IAAI6B,EAAO,CAAChI,MAAM0F,OAAO7F,MAAMsI,KAAKvH,YAEpC,OAAOkC,EAAQG,WAAWzC,MAAMR,KAAMgI,IAGvC1K,EAAKwK,SAAW,WACf,IAAIE,EAAO,CAAChI,MAAM0F,OAAO7F,MAAMsI,KAAKvH,YAEpC,OAAOkC,EAAQoF,aAAa1H,MAAMR,KAAMgI,IAGzC1K,EAAKuK,UAAY,WAChB,IAAIG,EAAO,CAAChI,MAAM0F,OAAO7F,MAAMsI,KAAKvH,YAEpC,OAAOkC,EAAQiF,cAAcvH,MAAMR,KAAMgI,KAI3CJ,aAAc,SAAUhK,EAAKuC,EAAUqB,EAAQmB,GAE9C,GAAInB,aAAkBkG,SACrB,OAAOlG,EAAO5D,EAAIuC,IAIbqB,aAAkB3B,QACvB2B,EAAS,CAACA,IAGX,IACI4G,EADAnH,EAAOrD,EAAIuC,GAIdiI,EADGnH,aAAgBpB,MACNoB,EAEA,CAACA,GAGf,IAAK,IAAIlG,EAAI,EAAGA,EAAIqN,EAAWrK,OAAQhD,IAAK,CAC3C,IAAIsD,EAAY+J,EAAWrN,GAE3B,IAAK,IAAI6K,EAAI,EAAGA,EAAIpE,EAAOzD,OAAQ6H,IAClC,GAAIxE,EAASiH,YAAY7G,EAAOoE,GAAIvH,EAAWsE,GAC9C,OAAO,EAKV,OAAO,GAGR0F,YAAa,SAAUpH,EAAMjF,EAAOsM,GAOnC,GAAIrH,IAASjF,EACZ,OAAO,EAIR,IAAK,IAAIjB,KAAKuN,EAAe,CAC5B,IAAIrC,EAAWqC,EAAcvN,GAC7B,IAAK,IAAImD,EAAI,EAAGA,EAAI+H,EAASlI,OAAQG,IAAK,CACzC,IAAIoD,EAAY2E,EAAS/H,GAEzB,IAC+B,IAA7BoD,EAAUS,QAAQd,KACY,IAA9BK,EAAUS,QAAQ/F,GAEnB,OAAO,GAKV,OAAO,GAMRuM,aAAc,SAAUvH,GAGvB,KAAyB,iBAAZA,GAAwBA,aAAmBwH,QAEvD,OAAO,KAGR,IAAIC,EAAW,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACzIC,GAAa,EAEjB,IAAK,IAAI3N,EAAI,EAAGA,EAAIiG,EAAQjD,OAAQhD,IAAK,CACxC,IAAIoE,EAAO6B,EAAQ2H,cAAc5N,GAC7B6N,EAAYH,EAAS1G,QAAQ5C,GAEjC,IAAmB,IAAfyJ,EAEH,OAAO,KAGRF,IAAcE,EAAY,GAAK/K,KAAKgL,IAAIJ,EAAS1K,OAAQiD,EAAQjD,QAAUhD,EAAE,IAG9E,OAAO2N,GAGRI,cAAe,SAAUxI,GAExB,IAAIyI,EAAU,GAEd,IAAK,IAAIzM,KAAOgE,EAAM,CACrB,IAAIsG,EAAMtG,EAAKhE,IAEI,iBAARsK,GAAoBA,aAAe4B,UAC7C5B,EAAMxF,EAASmH,aAAajI,EAAKhE,KAG9B0M,OAAOC,UAAUrC,IAAQA,GAAO,IACnCmC,EAAQzM,GAAOsK,GAIjB,OAAOmC,GAMR1H,sBAAuB,SAAUH,EAAOgI,EAASC,EAAqBC,GACrE,MAAMC,EAAgBF,GAAuB,KACvCG,EAAeF,GAAsB,KAE3C,IAAIG,EAAc,GAEdC,EAAWC,IACY,iBAAfA,IACVA,EAAa,GAAKA,IAGwB,IAAvCA,EAAW1H,QAAQsH,KAGtBI,EAAa,IAAMA,EAAWjL,QAAQ,KAAM,MAAQ,KAGrD+K,GAAeE,EAAaJ,GAEzBK,EAAU,KAEbH,EAAcA,EAAYI,OAAO,EAAGJ,EAAYxL,OAASsL,EAActL,QAAUuL,GAI9EJ,IACHK,GAAeF,GAGhB,IAAIO,GAAmB,EACvB,IAAK,IAAIC,KAAW3I,EAAO,CAC1B,IAAyB,IAArB0I,EACH,MAEDA,GAAmB,EAEnB,IAAIhM,EAAMsD,EAAM2I,GAChB,IAAK,IAAI7I,KAAWpD,EACnB4L,EAAQxI,GAGV0I,IAEA,IAAK,IAAIG,KAAW3I,EAAO,CAC1B,IAAI4I,GAAa,EACblM,EAAMsD,EAAM2I,GAChB,IAAK,IAAI7I,KAAWpD,EAAK,CACxB,IAAIqD,EAAOrD,EAAIoD,GACXkI,KACgB,IAAfY,GACHN,EAAQK,GAETC,GAAa,GAGdN,EAAQvI,GAETyI,IAGD,OAAOH,GAGR9H,0BAA2B,SAAUF,EAASD,GAM7C,IAAIyI,EAAa,GACjB,IAAK,IAAIhP,KAAKwG,EAAS,CACtB,IAAIyI,GAAU,EACd,IAAK,IAAI9L,EAAI,EAAGA,EAAIoD,EAAUvD,OAAQG,IAAK,CAC1C,IAAIyE,EAAUrB,EAAUpD,IAEI,IAAxByE,EAAQZ,QAAQhH,KACnBiP,GAAU,EACNrH,EAAQ,KAAMoH,EACjBA,EAAWpH,EAAQ,KAAOpB,EAAQxG,GAElCgP,EAAWpH,EAAQ,IAAMpB,EAAQxG,KAKpB,IAAZiP,IACHD,EAAWhP,GAAKwG,EAAQxG,IAI1B,OAAOgP,KAII,SACZhG,EAAQ,YACR8B,EAAW,aAEX0C,EAAY,cACZO,EAAa,OACbmB,GACG7I,GCh/BYiC,iBACf,MAAM6G,EAAY,CACjBzG,KAAM,2CACNc,WAAY,EACZjE,KAAM,EAAuB,CAC5B6J,KAAM,IACNC,YAAa,IACbC,cAAe,IACfC,aAAc,IACdC,eAAgB,IAChBC,iBAAkB,IAClBC,gBAAiB,IACjBC,WAAY,IACZA,WAAY,IACZC,YAAa,IACbC,gBAAiB,IACjBC,mBAAoB,IACpBC,kBAAmB,IACnBC,gBAAiB,IACjBC,gBAAiB,IACjBC,kBAAmB,IACnBC,gBAAiB,IACjBC,uBAAwB,OAIpBC,EAAY,CACjB3H,KAAM,+CACNc,WAAY,EACZjE,KAAM,EAAuB,CAC5B+K,gBAAiB,IACjBC,SAAU,IACVC,MAAO,IACPC,QAAS,IACTC,MAAO,OAIT,IAAIC,QAAsB,EAAkBxB,EAAWkB,GAEvD,IAAK,IAAIxG,KAAc8G,EAAe,CACrC,IAAI,KAAEpO,EAAI,KAAEgD,GAASsE,EAErBtC,QAAQC,IAAIjF,GACZgF,QAAQC,IAAIjF,EAAK2M,OAAO,IAGzB,IAAI,KAAE3M,EAAI,KAAEgD,GAASoL,EAAc,GAE/BC,EAASrO,EAAK2M,OAAO3J,EAAK8J,aAAatL,IAAK8M,GAAQA,EAAI,IAExDC,EAAcvO,EAAKuD,OAAO8K,GAC9BrJ,QAAQC,IAAIjF,EAAK2M,OAAO4B,IAExB,IAAIC,EAAkBxO,EAAKyO,cAAc,CAACnO,EAAKoO,IACvCpO,EAAI,GAAKA,EAAI,GAAKoO,EACvBL,GACHrJ,QAAQC,IAAIjF,EAAK2M,OAAO6B,IAExBxJ,QAAQpB,MAAM5D,EAAK6D,eAAeb,IAClCgC,QAAQC,IAAIjF,EAAK2O,qBAAqB3L,IAEtChD,EAAOoO,EAAc,GAAGpO,KACxBgD,EAAOoL,EAAc,GAAGpL,KAExBgC,QAAQC,IAAIjF,EAAKsE,cAActB,EAAK+K,kBAEpC,IAAIxJ,EAAavE,EAAK4O,mBAAmB5L,EAAK+K,gBAAiB5P,OAAO0Q,KAAK7O,EAAKsE,cAActB,EAAK+K,mBACnG/I,QAAQC,IAAIV,GAEZ,IAAImB,EAAoB1F,EAAK6F,qBAAqB7C,EAAK+K,gBAAiB/K,EAAKiL,OAC7EjJ,QAAQC,IAAIS,GAEZ,IAAIoJ,EAA0B9O,EAAK+O,2BAA2B/L,EAAK+K,gBAAiB/K,EAAKiL,OACzFjJ,QAAQC,IAAI6J,GAEZ9J,QAAQC,IAAIjF,EAAK+O,2BAA2B/L,EAAK+K,gBAAiB/K,EAAKiL,QAGxEe","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const { stringify, parse } = (() => {\n\tconst csv = {\n\t\tstringify: function (data, options) {\n\t\t\toptions = options || {};\n\t\t\toptions.transpose = options.transpose || false;\n\t\t\toptions.sanitise = options.sanitise || false;\n\n\t\t\t// Enforce square data and apply CSV escaping, then convert to string\n\t\t\tlet rows = data;\n\n\t\t\trows = csv._shape(data, options);\n\t\t\trows = csv._escape(rows, options);\n\n\t\t\trows = csv._join(rows);\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_shape: function (data, options) {\n\t\t\t// Pad missing cells with empty strings and,\n\t\t\t// if necessary, transpose the data\n\n\t\t\tconst transpose = options.transpose;\n\n\t\t\tconst maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\n\n\t\t\t// Flip rows and columns if transposing data\n\t\t\tconst iMax = transpose ? maxLength : data.length;\n\t\t\tconst jMax = transpose ? data.length : maxLength;\n\n\t\t\tlet rows = [];\n\t\t\tfor (let i = 0; i < iMax; i++) {\n\t\t\t\tlet row = [];\n\t\t\t\tfor (let j = 0; j < jMax; j++) {\n\t\t\t\t\tlet iRow = transpose ? j : i;\n\t\t\t\t\tlet iCol = transpose ? i : j;\n\n\t\t\t\t\tlet cellValue = data[iRow][iCol];\n\n\t\t\t\t\tif (iCol >= data[iRow].length) {\n\t\t\t\t\t\tcellValue = '';\n\t\t\t\t\t}\n\n\t\t\t\t\trow.push(cellValue);\n\t\t\t\t}\n\t\t\t\trows.push(row);\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_escape: function (rows, options) {\n\t\t\t// Make sure any cells containing \" or , or a newline are escaped appropriately\n\n\t\t\tconst sanitise = options.sanitise;\n\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\tlet row = rows[i];\n\n\t\t\t\tfor (let j = 0; j < row.length; j++) {\n\t\t\t\t\tif (typeof row[j] === 'undefined') {\n\t\t\t\t\t\t// Replace undefined with ''\n\t\t\t\t\t\trow[j] = '';\n\t\t\t\t\t} else if (typeof row[j] !== 'string') {\n\t\t\t\t\t\t// Convert to string\n\t\t\t\t\t\trow[j] = '' + row[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sanitise) {\n\t\t\t\t\t\t// Prevent spreadsheet software like\n\t\t\t\t\t\t// Excel from trying to execute code\n\t\t\t\t\t\tif (row[j].match(/^[=\\-+@]/)) {\n\t\t\t\t\t\t\trow[j] = '\\t' + row[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (row[j].match(/,|\"|\\n/)) {\n\n\t\t\t\t\t\t// Turn any double quotes into escaped double quotes\n\t\t\t\t\t\trow[j] = row[j].replace(/\"/g, '\"\"');\n\n\t\t\t\t\t\t// Wrap cell in double quotes\n\t\t\t\t\t\trow[j] = '\"' + row[j] + '\"';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_join: function (rows) {\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\trows[i] = rows[i].join(',');\n\t\t\t}\n\t\t\trows = rows.join('\\n');\n\n\t\t\treturn rows;\n\t\t},\n\n\n\t\tparse: function (csvString, options) {\n\t\t\tlet rows = csv._tokenise(csvString);\n\n\t\t\tcsv._validate(rows);\n\n\t\t\tif (options && options.mapper) {\n\t\t\t\trows = rows.map((row) => row.map(options.mapper));\n\t\t\t}\n\n\t\t\treturn rows;\n\t\t},\n\n\t\t_tokenise: function (csvString) {\n\t\t\t// Walk through each character and produce an array of tokens\n\n\t\t\tlet tokens = [];\n\n\t\t\t// Remove carriage returns\n\t\t\tcsvString = csvString.replace(/\\r/g, '');\n\n\t\t\tlet inQuote = false;\n\t\t\tlet wasQuote = false;\n\n\t\t\tlet tokenStart = 0;\n\t\t\tlet row = [];\n\t\t\tfor (let i = 0; i < csvString.length; i++) {\n\t\t\t\tlet char = csvString[i];\n\n\t\t\t\tlet comma = char === ',';\n\t\t\t\tlet quote = char === '\"';\n\t\t\t\tlet newline = char === '\\n';\n\t\t\t\tlet eof = i === csvString.length -1; // eof - End Of File\n\n\t\t\t\tif (inQuote) {\n\t\t\t\t\t// Characters may be delimited\n\t\t\t\t\tif (quote) {\n\t\t\t\t\t\t// Check if the next character is another double quote, i.e. if it is escaped\n\t\t\t\t\t\tlet nextChar = csvString[i+1];\n\n\t\t\t\t\t\tif (nextChar === '\"') {\n\t\t\t\t\t\t\t// This and the next character combined make an escaped double quote,\n\t\t\t\t\t\t\t// so the quote has not ended and we should skip over the next character\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// The quote has ended\n\t\t\t\t\t\t\tinQuote = false;\n\t\t\t\t\t\t\twasQuote = true;\n\n\t\t\t\t\t\t\tif (!eof) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (eof) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Reached end of file before ending quote. At index ${i}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!inQuote && (comma || newline || eof)) {\n\t\t\t\t\t// These are the characters that denote the end of a token\n\t\t\t\t\tlet token = csvString.substring(tokenStart, i+1);\n\n\t\t\t\t\tif (comma || newline) {\n\t\t\t\t\t\t// Don't keep the separator\n\t\t\t\t\t\ttoken = token.substring(0, token.length - 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (wasQuote) {\n\t\t\t\t\t\twasQuote = false;\n\n\t\t\t\t\t\t// Remove start and end quotes\n\t\t\t\t\t\ttoken = token.substring(1, token.length - 1);\n\n\t\t\t\t\t\t// Replace escaped quotes\n\t\t\t\t\t\ttoken = token.replace(/\"\"/g, '\"');\n\t\t\t\t\t}\n\t\t\t\t\trow.push(token);\n\n\t\t\t\t\tif (comma && eof) {\n\t\t\t\t\t\t// It's the end of the last token, and the last cell is empty\n\t\t\t\t\t\trow.push('');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newline || eof) {\n\t\t\t\t\t\ttokens.push(row);\n\t\t\t\t\t\tif (newline) {\n\t\t\t\t\t\t\trow = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenStart = i+1;\n\t\t\t\t} else if (wasQuote) {\n\t\t\t\t\tthrow new Error(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\n\t\t\t\t} else if (quote) {\n\t\t\t\t\tinQuote = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tokens;\n\t\t},\n\n\t\t_validate: function (rows) {\n\t\t\t// Each row of a CSV should have the same length;\n\n\t\t\tif (rows && rows.length > 1) {\n\t\t\t\tlet rowLength = rows[0].length;\n\t\t\t\tfor (let i = 1; i < rows.length; i++) {\n\t\t\t\t\tlet row = rows[i];\n\n\t\t\t\t\tif (row.length !== rowLength) {\n\t\t\t\t\t\tthrow new Error(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\treturn {\n\t\tstringify: csv.stringify,\n\t\tparse: csv.parse,\n\t};\n})();\n\nexport { stringify, parse };\n","import { parse } from 'csv';\n\nclass AnalyserRows extends Array {\n\tconstructor(sourceArray) {\n\t\t// Don't use spread operator as it will cause a\n\t\t// stack overflow error with very large arrays\n\t\t// super(...sourceArray);\n\t\tsuper(sourceArray.length);\n\t\tfor (let i = 0; i < sourceArray.length; i++) {\n\t\t\tthis[i] = sourceArray[i];\n\t\t}\n\t}\n\n\n\t//////////////////////\n\t// HELPER FUNCTIONS //\n\t//////////////////////\n\tgetCol(colNum) {\n\t\tlet col = this.map((row) => row[colNum]);\n\t\treturn col;\n\t}\n\n\n\t//////////////////////////////\n\t// TRANSFORMING INFORMATION //\n\t//////////////////////////////\n\taddCol(col) {\n\t\t// Edits the passed rows array to add an extra column\n\t\t// to it, then returns the index of that new column\n\n\t\tif (this.length !== col.length) {\n\t\t\tthrow new Error(`Cannot add col of length ${col.length} to rows of length ${this.length}`);\n\t\t}\n\n\t\tlet colIndex = this[0].length;\n\n\t\tfor (let [i, row] of this.entries()) {\n\t\t\trow.push(col[i]);\n\t\t}\n\n\t\treturn colIndex;\n\t}\n\n\tgetDerivedCol(processFn, ...cols) {\n\t\t// Creates an array analogous to a column as returns\n\t\t// by the getCol function, where its output is the\n\t\t// result of applying the processFn function to the row\n\t\t// any number of values from optional column arguments\n\n\t\tlet derivedCol = this.map((row, i) => {\n\t\t\tlet derivedValues = [row];\n\n\t\t\tfor (let col of cols) {\n\t\t\t\tderivedValues.push(col[i]);\n\t\t\t}\n\n\t\t\treturn processFn.apply(this, derivedValues);\n\t\t});\n\n\t\treturn derivedCol;\n\t}\n\n\taddDerivedCol(callback, ...cols) {\n\t\t// Works like getDerivedCol, but instead of returning\n\t\t// the derived column directly it uses addCol to add\n\t\t// it to rows and returns the new column index.\n\n\t\tlet derivedCol = this.getDerivedCol.apply(this, arguments);\n\n\t\treturn this.addCol(derivedCol);\n\t}\n\n\n\t///////////////////\n\t// SUMMARY TOOLS //\n\t///////////////////\n\tcreateSubTable(cols, arraySeparator) {\n\t\t// Takes in a set of rows and a cols object formatted like this:\n\t\t// {\n\t\t// \tETHNICITY: 3,\n\t\t// \tAGE: 6\n\t\t// }\n\n\t\t// Outputs an array of objects,\n\t\t// each of which has the same indices as cols and represents a row\n\t\t// The output can be used with console.table\n\n\t\tarraySeparator = arraySeparator || ', ';\n\n\t\tlet table = this.map((row) => {\n\t\t\tlet newRow = {};\n\n\t\t\tfor (let colName in cols) {\n\t\t\t\tlet col = cols[colName];\n\t\t\t\tlet cell = row[col]\n\t\t\t\t// Join arrays so they display in console.table\n\t\t\t\tif (cell instanceof Array) {\n\t\t\t\t\tnewRow[colName] = cell.join(arraySeparator);\n\t\t\t\t} else {\n\t\t\t\t\tnewRow[colName] = cell;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRow;\n\t\t});\n\n\t\treturn table;\n\t}\n\n\tcreateSubTableString(cols) {\n\t\tlet table = this.createSubTable(cols, ',');\n\t\tlet tableString = Analyser._convertTableToString(table);\n\n\t\treturn tableString;\n\t}\n\n\tgetColSummary(cols, aliasList) {\n\t\t// Takes in a set of rows and one or more column numbers, and optionally\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\n\n\t\t// Outputs an object summarising the number of times each value\n\t\t// appeared in the given column of the given rows\n\n\n\t\t// Allow the passing of a single number or an array of column indices\n\t\tif (!(cols instanceof Array)) {\n\t\t\tcols = [cols];\n\t\t}\n\n\t\tlet summary = {};\n\t\tfor (let row of this) {\n\t\t\tfor (let col of cols) {\n\t\t\t\tlet cellValue = row[col];\n\n\t\t\t\tif (typeof cellValue !== 'undefined' && cellValue !== '') {\n\n\t\t\t\t\tlet values;\n\t\t\t\t\tif (cellValue instanceof Array) {\n\t\t\t\t\t\tvalues = cellValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues = [cellValue];\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let value of values) {\n\t\t\t\t\t\tif (value in summary) {\n\t\t\t\t\t\t\tsummary[value]++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsummary[value] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (typeof aliasList !== 'undefined') {\n\t\t\tsummary = Analyser._groupColSummaryByAliases(summary, aliasList);\n\t\t}\n\n\t\treturn summary;\n\t}\n\n\tgetColAsDataSeries(col, labels) {\n\t\t// Takes in a set of rows and a column number,\n\t\t// and an array of labels. Outputs an array where\n\t\t// each element is the count of the values matching\n\t\t// the element of labels at the same index\n\n\t\tlet colSummary = this.getColSummary(col);\n\n\t\tlet dataSeries = [];\n\n\t\tfor (let i = 0; i < labels.length; i++) {\n\t\t\tdataSeries[i] = 0;\n\t\t}\n\n\t\tfor (let i in colSummary) {\n\t\t\tlet value = colSummary[i];\n\t\t\tlet index = labels.indexOf(i);\n\t\t\tif (index === -1) {\n\t\t\t\t// Couldn't find index, try forcing it to be a number\n\t\t\t\tindex = labels.indexOf(parseInt(i, 10));\n\t\t\t}\n\n\t\t\tif (index !== -1) {\n\t\t\t\tdataSeries[index] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn dataSeries;\n\t}\n\n\tgetComparisonSummary(headerCol, headerAliases, varCol, varAliases) {\n\t\t// Takes in a set of rows and two column numbers\n\t\t// Creates an object that can be used with console.table\n\t\t// with the values of headerCol used in the header, and\n\t\t// the values of varCol used for each row, with the cells\n\t\t// denoting the number of times these values coincided\n\t\t// using filterRows with the passed sets of aliases\n\n\t\t// Also optionally takes a set of aliases for one or both columns\n\n\t\tif (arguments.length === 2) {\n\t\t\t// No aliases specified\n\t\t\tvarCol = headerAliases;\n\t\t\theaderAliases = undefined;\n\t\t} else if (arguments.length === 3) {\n\t\t\t// One alias specified\n\t\t\tif (!(headerAliases instanceof Array)) {\n\t\t\t\t// headerAliases was not passed\n\t\t\t\tvarAliases = varCol;\n\t\t\t\tvarCol = headerAliases;\n\t\t\t\theaderAliases = undefined;\n\t\t\t}\n\t\t}\n\n\t\tconsole.log(this);\n\t\tconsole.trace();\n\t\tlet headerSummary = this.getColSummary(headerCol, headerAliases);\n\t\tlet varSummary = this.getColSummary(varCol, varAliases);\n\n\t\tlet aliases = {};\n\t\tif (headerAliases) {\n\t\t\taliases.HEADERS = headerAliases;\n\t\t}\n\t\tif (varAliases) {\n\t\t\taliases.VARS = varAliases;\n\t\t}\n\t\tlet filters = Analyser._getAliasFilters(aliases);\n\n\t\tlet comparisonSummary = {};\n\t\tfor (let i in varSummary) {\n\t\t\tcomparisonSummary[i] = {};\n\t\t\tfor (let j in headerSummary) {\n\t\t\t\tcomparisonSummary[i][j] = filters.filterRows(this,\n\t\t\t\t\tvarCol, Analyser._extractValue(i),\n\t\t\t\t\theaderCol, Analyser._extractValue(j)\n\t\t\t\t).length;\n\t\t\t}\n\t\t}\n\n\t\treturn comparisonSummary;\n\t}\n\n\tgetComparisonSummaryString(headerCol, headerAliases, varCol, varAliases) {\n\t\t// Calls getComparisonSummary with all arguments passed,\n\t\t// then returns a string of the data that can be copy/pasted\n\t\t// into a spreadsheet\n\n\t\tlet comparisonSummary = this.getComparisonSummary.apply(this, arguments);\n\t\tlet comparisonSummaryString = Analyser._convertTableToString(comparisonSummary, true);\n\n\t\treturn comparisonSummaryString;\n\t}\n}\n\nconst Analyser = {\n\t/////////////////////\n\t// FILE PROCESSING //\n\t/////////////////////\n\t_loadFile: async function (fileConfig) {\n\t\tlet response = await fetch(fileConfig.path);\n\n\t\tif (response.ok) {\n\t\t\tlet data = await response.text();\n\n\t\t\tlet rows = Analyser._parseCsv(data);\n\t\t\tlet dataConfig = Analyser._processData(rows, fileConfig);\n\t\t\treturn dataConfig;\n\t\t} else {\n\t\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\n\t\t}\n\t},\n\n\tloadFile: function (...fileConfigArr) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\t// Load each file, then resolve the wrapping promise once all are loaded\n\t\t\tlet promises = fileConfigArr.map((fileConfig) => Analyser._loadFile(fileConfig))\n\t\t\tPromise.all(promises).then(resolve);\n\t\t});\n\t},\n\n\t_processData: function (rows, fileConfig) {\n\t\t// Takes in fileConfig with the following properties:\n\t\t// The number of header rows to remove from rows\n\t\t// A fileConfig object for column names\n\t\t// An optional set of aliases\n\t\t// An optional set of columns whose values should be treated as arrays\n\t\t// An optional set of columns with default values\n\t\t// An optional map of columns that should be combined when collecting enums\n\n\t\t// The output contains the following properties:\n\t\t// The header rows that were removed\n\t\t// The fileConfig object for column names\n\t\t// A set of filters respecting the given aliases\n\t\t// Enums collected according to the specified column names and optional enumsMap\n\n\t\t// Example data:\n\t\t// headerRows = 2;\n\t\t// footerRows = 1;\n\n\t\t// cols = Analyser.getColNumbers({\n\t\t// \tETHNICITY: 'K',\n\t\t// \tTACTICS: 'M'\n\t\t// });\n\n\t\t// arrayCols = {};\n\t\t// arrayCols[cols.TACTICS] = ' ';\n\n\t\t// defaultCols = {};\n\t\t// defaultCols[cols.VALUE] = 0;\n\n\t\t// defaultColValues = {};\n\t\t// defaultColValues[cols.VALUE] = '-';\n\n\t\t// aliases = {\n\t\t// \tETHNICITY: [\n\t\t// \t\t[\n\t\t// \t\t\t'Pacific', //Not represented in data, but used as a label\n\t\t// \t\t\t'Pacific Island',\n\t\t// \t\t\t'Pacific Islander'\n\t\t// \t\t]\n\t\t// \t]\n\t\t// };\n\n\t\t// enumsMap = {\n\t\t// \tTASER_METHOD: [cols.TASER_METHOD_1, cols.TASER_METHOD_2, cols.TASER_METHOD_3]\n\t\t// };\n\n\t\tfileConfig.headerRows = fileConfig.headerRows || 0;\n\t\tfileConfig.footerRows = fileConfig.footerRows || 0;\n\t\tfileConfig.cols = fileConfig.cols || {};\n\t\tfileConfig.aliases = fileConfig.aliases || {};\n\t\tfileConfig.arrayCols = fileConfig.arrayCols || {};\n\t\tfileConfig.enumsMap = fileConfig.enumsMap || {};\n\t\tfileConfig.uniqueCols = fileConfig.uniqueCols || [];\n\n\t\tlet dataConfig = {};\n\t\tdataConfig.cols = fileConfig.cols;\n\t\tdataConfig.aliases = fileConfig.aliases;\n\t\tdataConfig.filters = Analyser._getAliasFilters(fileConfig.aliases);\n\t\tdataConfig.enumsMap = fileConfig.enumsMap; // Keep this for combining data\n\n\t\tif (fileConfig.headerRows !== 0) {\n\t\t\t// Remove header rows\n\t\t\trows.splice(0, fileConfig.headerRows);\n\t\t}\n\n\t\tif (fileConfig.footerRows !== 0) {\n\t\t\t// Remove footer rows\n\t\t\trows.splice(-fileConfig.footerRows);\n\t\t}\n\n\t\t// Convert cells that are lists into arrays\n\t\tdataConfig.rows = new AnalyserRows(rows);\n\t\tfor (let i = 0; i < dataConfig.rows.length; i++) {\n\t\t\tlet row = dataConfig.rows[i];\n\n\t\t\tfor (let j in fileConfig.arrayCols) {\n\t\t\t\trow[j] = (row[j] + '').trim().split(fileConfig.arrayCols[j] || ' ');\n\t\t\t}\n\n\t\t\t// Remove default values from specified columns\n\t\t\tfor (let j in fileConfig.defaultColValues) {\n\t\t\t\tif (j in fileConfig.arrayCols) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((row[j] + '') === (fileConfig.defaultColValues[j] + '')) {\n\t\t\t\t\trow[j] = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add default values to empty cells in default cols\n\t\t\tfor (let j in fileConfig.defaultCols) {\n\t\t\t\tif (j in fileConfig.arrayCols) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((row[j] + '').trim() === '') {\n\t\t\t\t\trow[j] = fileConfig.defaultCols[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set filters on rows object\n\t\tAnalyser._createRowFilterFunctions(dataConfig.rows, dataConfig.filters);\n\n\t\t// Build enums\n\t\tdataConfig.enums = Analyser._buildEnums(rows, fileConfig);\n\n\t\treturn dataConfig;\n\t},\n\n\t_buildEnums: function (rows, config) {\n\t\tlet enums = {};\n\n\t\tfor (let col in config.cols) {\n\n\t\t\t// Don't collect enums for columns specified in uniqueCols or enumsMap\n\t\t\tlet collect = true;\n\t\t\tif (config.uniqueCols.includes(config.cols[col])) {\n\t\t\t\tcollect = false;\n\t\t\t}\n\t\t\tfor (let enumCol in config.enumsMap) {\n\t\t\t\tif (config.enumsMap[enumCol].includes(config.cols[col])) {\n\t\t\t\t\tcollect = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (collect) {\n\t\t\t\tenums[col] = [];\n\t\t\t\tAnalyser._collectEnums(rows, enums[col], config.cols[col]);\n\t\t\t}\n\t\t}\n\t\tfor (let enumCol in config.enumsMap) {\n\t\t\tenums[enumCol] = [];\n\t\t\tAnalyser._collectEnums.apply(this, [rows, enums[enumCol]].concat(config.enumsMap[enumCol]));\n\t\t}\n\n\t\treturn enums;\n\t},\n\n\t_collectEnums: function (rows, enumsArr, ...cols) {\n\t\t// Go through all cells in a given set of columns\n\t\t// and add all unique entries found to enumsArr\n\n\t\tenumsArr = enumsArr || [];\n\n\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\tlet row = rows[i];\n\t\t\tfor (let j = 0; j < cols.length; j++) {\n\t\t\t\tlet col = cols[j];\n\n\t\t\t\tif (row[col] instanceof Array) {\n\t\t\t\t\tfor (let k = 0; k < row[col].length; k++) {\n\t\t\t\t\t\tif ((row[col][k] !== '') && (enumsArr.indexOf(row[col][k]) === -1)) {\n\t\t\t\t\t\t\tenumsArr.push(row[col][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((row[col] !== '') && (enumsArr.indexOf(row[col]) === -1)) {\n\t\t\t\t\t\tenumsArr.push(row[col]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn enumsArr;\n\t},\n\n\tcombineData: function (...dataConfigs) {\n\t\t// Takes in any number of dataConfig objects from _processData\n\t\t// Combines the rows and relevant dataConfig objects (e.g. aliases, enums)\n\t\t// Keeps only columns shared by all dataConfig objects\n\n\t\t// Assumes there is no data shared between different sets,\n\t\t// so duplicates will *not* be detected or removed\n\n\t\t// The output is in the same format as for _processData\n\n\t\tlet combinedDataConfig = {\n\t\t\tcols: {},\n\t\t\trows: new AnalyserRows([]),\n\t\t\taliases: {}\n\t\t};\n\n\t\tif (!dataConfigs || dataConfigs.length < 2) {\n\t\t\tconsole.error('Invalid inputs passed to combineData', arguments);\n\t\t}\n\n\t\t// Combine cols first //\n\n\t\t// Build base set from first cols object\n\t\tfor (let j in dataConfigs[0].cols) {\n\t\t\tcombinedDataConfig.cols[j] = true;\n\t\t}\n\n\t\t// Remove any cols not shared by every other cols object\n\t\tfor (let i = 1; i < dataConfigs.length; i++) {\n\t\t\tlet dataConfig = dataConfigs[i];\n\n\t\t\tfor (let j in combinedDataConfig.cols) {\n\t\t\t\tif (!(j in dataConfig.cols)) {\n\t\t\t\t\tdelete combinedDataConfig.cols[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet colIndex = 0;\n\t\tfor (let j in combinedDataConfig.cols) {\n\t\t\tcombinedDataConfig.cols[j] = colIndex;\n\t\t\tcolIndex++;\n\t\t}\n\n\t\t// Now that we have the combined cols object, combine rows and aliases\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\n\t\t\tlet dataConfig = dataConfigs[i];\n\t\t\t// Combine rows //\n\n\t\t\tfor (let j = 0; j < dataConfig.rows.length; j++) {\n\t\t\t\tlet row = [];\n\t\t\t\tfor (let k in combinedDataConfig.cols) {\n\t\t\t\t\trow[combinedDataConfig.cols[k]] = dataConfig.rows[j][dataConfig.cols[k]];\n\t\t\t\t}\n\n\t\t\t\tcombinedDataConfig.rows.push(row);\n\t\t\t}\n\n\n\t\t\t// Combine aliases //\n\n\t\t\t// Loop through each row's aliases to combine\n\t\t\tfor (let j in dataConfig.aliases) {\n\n\t\t\t\t// If we don't have an alias for this column, make an empty placeholder\n\t\t\t\tif (!(j in combinedDataConfig.aliases)) {\n\t\t\t\t\tcombinedDataConfig.aliases[j] = [];\n\t\t\t\t}\n\n\t\t\t\t// Loop through each aliasSet for this column\n\t\t\t\tfor (let k = 0; k < dataConfig.aliases[j].length; k++) {\n\t\t\t\t\tlet aliasSet = dataConfig.aliases[j][k];\n\n\t\t\t\t\t// Combine aliasSets based off their first element, which is used as a label\n\t\t\t\t\tlet combinedAliasSet = [];\n\t\t\t\t\tlet l;\n\t\t\t\t\tfor (l = 0; l < combinedDataConfig.aliases[j].length; l++) {\n\t\t\t\t\t\tif (combinedDataConfig.aliases[j][l][0] === aliasSet[0]) {\n\t\t\t\t\t\t\tcombinedAliasSet = combinedDataConfig.aliases[j][l];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcombinedAliasSet = combinedAliasSet.concat(aliasSet);\n\n\t\t\t\t\t// Remove duplicates\n\t\t\t\t\tcombinedAliasSet = combinedAliasSet.filter(function (alias, index, array) {\n\t\t\t\t\t\treturn array.indexOf(alias) === index;\n\t\t\t\t\t});\n\n\t\t\t\t\t// Append or replace aliasSet in combinedDataConfig\n\t\t\t\t\tif (l < combinedDataConfig.aliases[j].length) {\n\t\t\t\t\t\tcombinedDataConfig.aliases[j][l] = combinedAliasSet;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcombinedDataConfig.aliases[j].push(combinedAliasSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create new filters using combined aliases\n\t\tcombinedDataConfig.filters = Analyser._getAliasFilters(combinedDataConfig.aliases);\n\t\tAnalyser._createRowFilterFunctions(combinedDataConfig.rows, combinedDataConfig.filters);\n\n\t\t// Combine uniqueCols\n\t\tcombinedDataConfig.uniqueCols = [];\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\n\t\t\tlet dataConfig = dataConfigs[i];\n\n\t\t\tfor (let j in dataConfig.uniqueCols) {\n\t\t\t\tlet originalCol = dataConfig.uniqueCols[j];\n\t\t\t\tlet originalColName = undefined;\n\t\t\t\tfor (let k in dataConfig.cols) {\n\t\t\t\t\tif (dataConfig.cols[l] === originalCol) {\n\t\t\t\t\t\toriginalColName = l;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (originalColName) {\n\t\t\t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\n\n\t\t\t\t\tif (combinedDataConfig.uniqueCols.indexOf(originalColIndex) === -1) {\n\t\t\t\t\t\tcombinedDataConfig.uniqueCols.push(combinedDataConfig.cols[originalColName]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Combine the enumsMaps, then build combined enums\n\t\tcombinedDataConfig.enumsMap = {};\n\t\tfor (let i = 0; i < dataConfigs.length; i++) {\n\t\t\tlet dataConfig = dataConfigs[i];\n\n\t\t\tfor (let j in dataConfig.enumsMap) {\n\t\t\t\tlet originalEnumsMap = dataConfig.enumsMap[j];\n\n\t\t\t\tif (!originalEnumsMap) {\n\t\t\t\t\t// Mark this enumsMap as null to denote that it doesn't\n\t\t\t\t\t// exist across all dataConfigs we are combining\n\t\t\t\t\tcombinedDataConfig.enumsMap[j] = null;\n\t\t\t\t} else {\n\t\t\t\t\tif (combinedDataConfig.enumsMap[j] !== null) {\n\t\t\t\t\t\tcombinedDataConfig.enumsMap[j] = combinedDataConfig.enumsMap[j] || [];\n\n\t\t\t\t\t\tfor (let k = 0; k < originalEnumsMap.length; k++) {\n\t\t\t\t\t\t\tlet originalCol = originalEnumsMap[k];\n\t\t\t\t\t\t\tlet originalColName = undefined;\n\t\t\t\t\t\t\tfor (let l in dataConfig.cols) {\n\t\t\t\t\t\t\t\tif (dataConfig.cols[l] === originalCol) {\n\t\t\t\t\t\t\t\t\toriginalColName = l;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (originalColName) {\n\t\t\t\t\t\t\t\tlet originalColIndex = combinedDataConfig.cols[originalColName];\n\n\t\t\t\t\t\t\t\tif (combinedDataConfig.enumsMap[j].indexOf(originalColIndex) === -1) {\n\t\t\t\t\t\t\t\t\tcombinedDataConfig.enumsMap[j].push(combinedDataConfig.cols[originalColName]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let j in combinedDataConfig.enumsMap) {\n\t\t\t\tif (combinedDataConfig.enumsMap[j] === null) {\n\t\t\t\t\tdelete combinedDataConfig[enumsMap[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcombinedDataConfig.enums = Analyser._buildEnums(combinedDataConfig.rows, combinedDataConfig);\n\n\t\treturn combinedDataConfig;\n\t},\n\n\t/////////////////\n\t// CSV PARSING //\n\t/////////////////\n\t_parseCsv: function (csv) {\n\t\t// Parse a CSV file then process the data\n\t\t// Convert strings to numbers where appropriate,\n\t\t// then pass the data to a callback function\n\n\t\tlet data = parse(csv, { mapper: Analyser._extractValue });\n\n\t\treturn data;\n\t},\n\n\t_extractValue: function (string) {\n\t\t// Convert strings to booleans or numbers where possible\n\n\t\tif (string === 'true') {\n\t\t\treturn true;\n\t\t} else if (string === 'false') {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn Analyser._extractNumber(string);\n\t\t}\n\t},\n\n\t_extractNumber: function (string) {\n\t\t// Convert strings to numbers where possible\n\n\t\tlet val = string.replace(/,|%$/g, '');\n\n\t\tif (parseFloat(val) === +val) {\n\t\t\tif (string.match(/%$/)) {\n\t\t\t\t// If the value is a percentage, divide by 100\n\n\t\t\t\t// Convert to string to see how many places after the point, to round after dividing\n\t\t\t\t// Otherwise you'll get numbers like 0.10800000000000001\n\t\t\t\tlet length = (val + '');\n\t\t\t\tlength.replace(/^[^.]+/, '');\n\t\t\t\tlength = length.length;\n\n\t\t\t\tval = val / 100;\n\t\t\t\tval = val.toFixed(length+2);\n\t\t\t}\n\t\t\treturn +val;\n\t\t} else {\n\t\t\treturn string;\n\t\t}\n\t},\n\n\t///////////////\n\t// FILTERING //\n\t///////////////\n\t_getAliasFilters: function (aliases) {\n\t\tconst filterRows = function (rows, orToggle, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\n\t\t\t// Takes in a rows object (imported from csv),\n\t\t\t// a boolean specifying whether it's an \"and\" or an \"or\" filter,\n\t\t\t// and any number of pairs (at least one) of\n\t\t\t// the index of the column to consider, and an array of values\n\n\t\t\t// Returns an array of rows where the cell in the column\n\t\t\t// specified contains a value in the array of values given\n\t\t\t// for all column and value pairs\n\n\t\t\tlet and = !orToggle;\n\t\t\tlet startAt = 2;\n\n\t\t\tlet filteredRows = [];\n\n\t\t\tif ((arguments.length < 4) || (((arguments.length-2) % 2) !== 0)) {\n\t\t\t\t// Assume \"andToggle\" has not been passed\n\t\t\t\tand = true;\n\t\t\t\tstartAt = 1;\n\t\t\t\tif ((arguments.length < 3) || (((arguments.length-1) % 2) !== 0)) {\n\t\t\t\t\tconsole.error('An invalid set of arguments was passed to filterRows');\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet filters = [];\n\t\t\tfor (let i = startAt; i < arguments.length-1; i += 2) {\n\t\t\t\tlet filter = {\n\t\t\t\t\tcolIndex: arguments[i],\n\t\t\t\t\tvalues: arguments[i+1]\n\t\t\t\t};\n\n\t\t\t\tif (!(Array.isArray(filter.values) || filter.values instanceof Function)) {\n\t\t\t\t\tfilter.values = [filter.values];\n\t\t\t\t}\n\n\t\t\t\tfilters.push(filter);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < rows.length; i++) {\n\t\t\t\tlet row = rows[i];\n\n\t\t\t\tlet isMatch = !!and;\n\n\t\t\t\tfor (let j = 0; j < filters.length; j++) {\n\t\t\t\t\tlet filter = filters[j];\n\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tisMatch = isMatch && Analyser._applyFilter(row, filter.colIndex, filter.values, aliases);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisMatch = isMatch || Analyser._applyFilter(row, filter.colIndex, filter.values, aliases);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isMatch) {\n\t\t\t\t\tfilteredRows.push(row);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfilteredRows = new AnalyserRows(filteredRows);\n\t\t\tfilteredRows.filter = rows.filter;\n\t\t\tfilteredRows.filterAnd = rows.filterAnd;\n\t\t\tfilteredRows.filterOr = rows.filterOr;\n\n\t\t\treturn filteredRows;\n\t\t};\n\n\t\tconst filterRowsAnd = function (rows, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\n\t\t\tlet args = Array.prototype.slice.apply(arguments);\n\n\t\t\targs = args.slice(1);\n\t\t\targs.splice(0, 0, false);\n\t\t\targs.splice(0, 0, rows);\n\n\t\t\treturn filterRows.apply(this, args);\n\t\t};\n\n\t\tconst filterRowsOr = function (rows, colIndex1, values1, colIndex2, values2, colIndexN, valuesN) {\n\t\t\tlet args = Array.prototype.slice.apply(arguments);\n\n\t\t\targs = args.slice(1);\n\t\t\targs.splice(0, 0, true);\n\t\t\targs.splice(0, 0, rows);\n\n\t\t\treturn filterRows.apply(this, args);\n\t\t};\n\n\t\treturn {\n\t\t\tfilterRows: filterRows,\n\t\t\tfilterRowsAnd: filterRowsAnd,\n\t\t\tfilterRowsOr: filterRowsOr\n\t\t};\n\t},\n\n\t_createRowFilterFunctions: function (rows, filters) {\n\t\trows.filter = function () {\n\t\t\tvar args = [this].concat(Array.from(arguments));\n\n\t\t\treturn filters.filterRows.apply(this, args);\n\t\t};\n\n\t\trows.filterOr = function () {\n\t\t\tvar args = [this].concat(Array.from(arguments));\n\n\t\t\treturn filters.filterRowsOr.apply(this, args);\n\t\t};\n\n\t\trows.filterAnd = function () {\n\t\t\tvar args = [this].concat(Array.from(arguments));\n\n\t\t\treturn filters.filterRowsAnd.apply(this, args);\n\t\t};\n\t},\n\n\t_applyFilter: function (row, colIndex, values, aliases) {\n\t\t// Allow functions to be passed as filter tests\n\t\tif (values instanceof Function) {\n\t\t\treturn values(row[colIndex]);\n\t\t}\n\n\t\t// If one or more values is passed, test it against aliases\n\t\tif (!(values instanceof Array)) {\n\t\t\tvalues = [values];\n\t\t}\n\n\t\tlet cell = row[colIndex];\n\t\tlet cellValues;\n\n\t\tif (cell instanceof Array) {\n\t\t\tcellValues = cell;\n\t\t} else {\n\t\t\tcellValues = [cell];\n\t\t}\n\n\t\tfor (let i = 0; i < cellValues.length; i++) {\n\t\t\tlet cellValue = cellValues[i];\n\n\t\t\tfor (let k = 0; k < values.length; k++) {\n\t\t\t\tif (Analyser._matchAlias(values[k], cellValue, aliases)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_matchAlias: function (cell, value, aliasSuperset) {\n\t\t// Checks if the value of a cell matches the value passed,\n\t\t// optionally taking one or more sets of aliases to match\n\n\t\t// The aliasSuperset is used because the default set of all\n\t\t// aliases will be used if no aliasSet is specified\n\n\t\tif (cell === value) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Could be array or object\n\t\tfor (let i in aliasSuperset) {\n\t\t\tlet aliasSet = aliasSuperset[i];\n\t\t\tfor (let j = 0; j < aliasSet.length; j++) {\n\t\t\t\tlet aliasList = aliasSet[j];\n\n\t\t\t\tif (\n\t\t\t\t\t(aliasList.indexOf(cell) !== -1) &&\n\t\t\t\t\t(aliasList.indexOf(value) !== -1)\n\t\t\t\t) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t//////////////////////\n\t// HELPER FUNCTIONS //\n\t//////////////////////\n\tgetColNumber: function (colName) {\n\t\t// Takes in a string like \"CE\" and converts it to a row number like 82\n\n\t\tif (!(typeof colName === 'string' || colName instanceof String)) {\n\t\t\t// Not a string\n\t\t\treturn null;\n\t\t}\n\n\t\tlet alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\t\tlet rowNumber = -1; // Adjust for 0-based counting\n\n\t\tfor (let i = 0; i < colName.length; i++) {\n\t\t\tlet char = colName.toUpperCase()[i];\n\t\t\tlet charIndex = alphabet.indexOf(char);\n\n\t\t\tif (charIndex === -1) {\n\t\t\t\t// String contains invalid character\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\n\t\t}\n\n\t\treturn rowNumber;\n\t},\n\n\tgetColNumbers: function (cols) {\n\t\t// Takes in a flat object and runs each property through getColNumber\n\t\tlet newCols = {};\n\n\t\tfor (let key in cols) {\n\t\t\tlet val = cols[key];\n\n\t\t\tif (typeof val === 'string' || val instanceof String) {\n\t\t\t\tval = Analyser.getColNumber(cols[key]);\n\t\t\t}\n\n\t\t\tif (Number.isInteger(val) && val >= 0) {\n\t\t\t\tnewCols[key] = val;\n\t\t\t}\n\t\t}\n\n\t\treturn newCols;\n\t},\n\n\t///////////////////\n\t// SUMMARY TOOLS //\n\t///////////////////\n\t_convertTableToString: function (table, useKeys, cellSeparatorOption, rowSeparatorOption) {\n\t\tconst cellSeparator = cellSeparatorOption || '\\t';\n\t\tconst rowSeparator = rowSeparatorOption || '\\n';\n\n\t\tlet tableString = '';\n\n\t\tlet addCell = (cellString) => {\n\t\t\tif (typeof cellString !== 'string') {\n\t\t\t\tcellString = '' + cellString;\n\t\t\t}\n\n\t\t\tif (cellString.indexOf(cellSeparator) !== -1) {\n\t\t\t\t// If the cell string contains the separator sequence,\n\t\t\t\t// wrap it in \" and escape any existing \" as \"\"\n\t\t\t\tcellString = '\"' + cellString.replace(/\"/g, '\"\"') + '\"';\n\t\t\t}\n\n\t\t\ttableString += cellString + cellSeparator;\n\t\t};\n\t\tlet endLine = () => {\n\t\t\t// Trim off last cell separator, replace with newline\n\t\t\ttableString = tableString.substr(0, tableString.length - cellSeparator.length) + rowSeparator;\n\t\t};\n\n\t\t// Render headers and create array of labels\n\t\tif (useKeys) {\n\t\t\ttableString += cellSeparator;\n\t\t}\n\n\t\tlet firstRowComplete = false;\n\t\tfor (let rowName in table) {\n\t\t\tif (firstRowComplete === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirstRowComplete = true;\n\n\t\t\tlet row = table[rowName];\n\t\t\tfor (let colName in row) {\n\t\t\t\taddCell(colName);\n\t\t\t}\n\t\t}\n\t\tendLine();\n\n\t\tfor (let rowName in table) {\n\t\t\tlet isFirstRow = false;\n\t\t\tlet row = table[rowName];\n\t\t\tfor (let colName in row) {\n\t\t\t\tlet cell = row[colName];\n\t\t\t\tif (useKeys) {\n\t\t\t\t\tif (isFirstRow === false) {\n\t\t\t\t\t\taddCell(rowName);\n\t\t\t\t\t}\n\t\t\t\t\tisFirstRow = true;\n\t\t\t\t}\n\n\t\t\t\taddCell(cell);\n\t\t\t}\n\t\t\tendLine();\n\t\t}\n\n\t\treturn tableString;\n\t},\n\n\t_groupColSummaryByAliases: function (summary, aliasList) {\n\t\t// Takes a summary object like the output from getColSummary, and\n\t\t// a list of aliases - an array of arrays of strings to be grouped together\n\n\t\t// Outputs a summary object where values within the same set of aliases are grouped\n\n\t\tlet newSummary = {};\n\t\tfor (let i in summary) {\n\t\t\tlet inAlias = false;\n\t\t\tfor (let j = 0; j < aliasList.length; j++) {\n\t\t\t\tlet aliases = aliasList[j];\n\n\t\t\t\tif (aliases.indexOf(i) !== -1) {\n\t\t\t\t\tinAlias = true;\n\t\t\t\t\tif (aliases[0] in newSummary) {\n\t\t\t\t\t\tnewSummary[aliases[0]] += summary[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewSummary[aliases[0]] = summary[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inAlias === false) {\n\t\t\t\tnewSummary[i] = summary[i];\n\t\t\t}\n\t\t}\n\n\t\treturn newSummary;\n\t}\n};\n\nexport const {\n\tloadFile,\n\tcombineData,\n\n\tgetColNumber,\n\tgetColNumbers,\n\tgetCol,\n} = Analyser;\n","import * as analyser from '/analyser';\n\nconst analyse = async function () {\n\tconst fileInfoA = {\n\t\tpath: '/assets/data/Prison Population - raw.csv',\n\t\theaderRows: 1,\n\t\tcols: analyser.getColNumbers({\n\t\t\tDATE: 'A',\n\t\t\tREMAND_MALE: 'B',\n\t\t\tREMAND_FEMALE: 'C',\n\t\t\tREMAND_TOTAL: 'D',\n\t\t\tSENTENCED_MALE: 'E',\n\t\t\tSENTENCED_FEMALE: 'F',\n\t\t\tSENTENCED_TOTAL: 'G',\n\t\t\tTOTAL_MALE: 'H',\n\t\t\tTOTAL_MALE: 'I',\n\t\t\tTOTAL_TOTAL: 'J',\n\t\t\tETHNICITY_MAORI: 'K',\n\t\t\tETHNICITY_EUROPEAN: 'L',\n\t\t\tETHNICITY_PACIFIC: 'M',\n\t\t\tETHNICITY_ASIAN: 'N',\n\t\t\tETHNICITY_OTHER: 'O',\n\t\t\tETHNICITY_UNKNOWN: 'P',\n\t\t\tETHNICITY_TOTAL: 'A',\n\t\t\tPER_100_000_POPULATION: 'R',\n\t\t}),\n\t};\n\n\tconst fileInfoB = {\n\t\tpath: '/assets/data/Tactical Options 2014 - raw.csv',\n\t\theaderRows: 1,\n\t\tcols: analyser.getColNumbers({\n\t\t\tTACTICAL_OPTION: 'A',\n\t\t\tEUROPEAN: 'B',\n\t\t\tMAORI: 'C',\n\t\t\tPACIFIC: 'D',\n\t\t\tOTHER: 'E',\n\t\t}),\n\t};\n\n\tlet dataConfigArr = await analyser.loadFile(fileInfoA, fileInfoB);\n\n\tfor (let dataConfig of dataConfigArr) {\n\t\tlet { rows, cols } = dataConfig;\n\n\t\tconsole.log(rows);\n\t\tconsole.log(rows.getCol(0));\n\t}\n\n\tlet { rows, cols } = dataConfigArr[0];\n\n\tlet newCol = rows.getCol(cols.REMAND_MALE).map((num) => num/10);\n\n\tlet newColIndex = rows.addCol(newCol);\n\tconsole.log(rows.getCol(newColIndex));\n\n\tlet derivedColIndex = rows.addDerivedCol((row, extraVal1) => {\n\t\treturn row[1] + row[2] - extraVal1;\n\t}, newCol);\n\tconsole.log(rows.getCol(derivedColIndex));\n\n\tconsole.table(rows.createSubTable(cols));\n\tconsole.log(rows.createSubTableString(cols));\n\n\trows = dataConfigArr[1].rows;\n\tcols = dataConfigArr[1].cols;\n\n\tconsole.log(rows.getColSummary(cols.TACTICAL_OPTION));\n\n\tlet dataSeries = rows.getColAsDataSeries(cols.TACTICAL_OPTION, Object.keys(rows.getColSummary(cols.TACTICAL_OPTION)));\n\tconsole.log(dataSeries);\n\n\tlet comparisonSummary = rows.getComparisonSummary(cols.TACTICAL_OPTION, cols.MAORI);\n\tconsole.log(comparisonSummary);\n\n\tlet comparisonSummaryString = rows.getComparisonSummaryString(cols.TACTICAL_OPTION, cols.MAORI);\n\tconsole.log(comparisonSummaryString);\n\n\tconsole.log(rows.getComparisonSummaryString(cols.TACTICAL_OPTION, cols.MAORI));\n};\n\nanalyse();\n"],"sourceRoot":""}