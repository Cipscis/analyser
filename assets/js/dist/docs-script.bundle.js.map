{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/analyser/webpack/bootstrap","webpack://@cipscis/analyser/webpack/runtime/define property getters","webpack://@cipscis/analyser/webpack/runtime/hasOwnProperty shorthand","webpack://@cipscis/analyser/webpack/runtime/make namespace object","webpack://@cipscis/analyser/./node_modules/@cipscis/codebook/dist/codebook.js","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/stringify.js","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/parse.js","webpack://@cipscis/analyser/./src/FileConfig.ts","webpack://@cipscis/analyser/./src/AnalyserRows.ts","webpack://@cipscis/analyser/./src/helpers.ts","webpack://@cipscis/analyser/./src/AnalyserGroup.ts","webpack://@cipscis/analyser/./src/filtering.ts","webpack://@cipscis/analyser/./src/transformers.ts","webpack://@cipscis/analyser/./src/file-processing.ts","webpack://@cipscis/analyser/./src/grouping.ts","webpack://@cipscis/analyser/./src/statistics.ts","webpack://@cipscis/analyser/./src/charts/ChartData.ts","webpack://@cipscis/analyser/./src/charts/Scale.ts","webpack://@cipscis/analyser/./src/charts/chart.ts","webpack://@cipscis/analyser/./src/charts/bar.ts","webpack://@cipscis/analyser/./src/charts/line.ts","webpack://@cipscis/analyser/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const selectors = Object.freeze({\r\n    block: '.js-codebook__block',\r\n    set: '.js-codebook__set',\r\n    inert: '.js-codebook__inert',\r\n});\r\nconst dataAttributes = Object.freeze({\r\n    set: 'data-codebook-set',\r\n    index: 'data-codebook-index',\r\n    log: 'data-codebook-log',\r\n    html: 'data-codebook-html',\r\n});\r\nconst defaultSetName = 'default';\r\n// Create a single textarea element for decoding HTML\r\nconst $textarea = document.createElement('textarea');\r\n/**\r\n * Run all Codebook blocks in all Codebook sets in order, with any specified external arguments made available.\r\n */\r\nexport function run(args) {\r\n    return new Promise((resolve, reject) => {\r\n        const sets = _createCodeSets(args);\r\n        const promises = [];\r\n        for (let setName in sets) {\r\n            const set = sets[setName];\r\n            promises.push(_runSet(set));\r\n        }\r\n        Promise.all(promises)\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n}\r\nexport async function runSet(setNameOrArgs, argsParam) {\r\n    let setName;\r\n    let args = undefined;\r\n    // Figure out which arguments were passed.\r\n    if (typeof setNameOrArgs === 'string') {\r\n        setName = setNameOrArgs;\r\n        if (argsParam) {\r\n            args = argsParam;\r\n        }\r\n    }\r\n    else {\r\n        // If no set name was specified, use the default set name.\r\n        setName = defaultSetName;\r\n        if (setNameOrArgs) {\r\n            args = setNameOrArgs;\r\n        }\r\n    }\r\n    const sets = _createCodeSets(args);\r\n    if (setName in sets) {\r\n        const set = sets[setName];\r\n        return _runSet(set);\r\n    }\r\n    else {\r\n        throw new RangeError(`Codebook: Cannot run unrecognised set '${setName}'`);\r\n    }\r\n}\r\n/**\r\n * Adjust the indentation of Codebook sets so it appears correctly when viewed on a page.\r\n */\r\nexport function tidy() {\r\n    const $blocks = document.querySelectorAll(`${selectors.block}, ${selectors.inert}`);\r\n    for (let $block of $blocks) {\r\n        const code = $block.innerHTML;\r\n        // Look for tab indentation only\r\n        const match = code.match(/^(\\t*)\\S/m);\r\n        if (match) {\r\n            const indentation = match[1];\r\n            const level = indentation.length;\r\n            const pattern = new RegExp(`^\\\\t{${level}}`, 'gm');\r\n            $block.innerHTML = code.replace(pattern, '').trim();\r\n        }\r\n    }\r\n    ;\r\n}\r\n/**\r\n * Gathers all Codebook sets, and sorts blocks within their sets according to their index where applicable.\r\n */\r\nfunction _createCodeSets(args) {\r\n    const sets = _gatherSetBlocks(args);\r\n    // Loop through created sets and sort their blocks by index\r\n    for (let setName in sets) {\r\n        const set = sets[setName];\r\n        _sortCodeBlocks(set);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Gathers all Codebook blocks according to the order in which they appear in the markup,\r\n * and adds them to the set they belong to.\r\n */\r\nfunction _gatherSetBlocks(args) {\r\n    const $blocks = document.querySelectorAll(selectors.block);\r\n    const setNames = [];\r\n    const sets = {};\r\n    // Loop through all elements and add them to the right set\r\n    for (let $block of $blocks) {\r\n        const setName = _getSetName($block);\r\n        let set;\r\n        if (setNames.includes(setName)) {\r\n            set = sets[setName];\r\n        }\r\n        else {\r\n            setNames.push(setName);\r\n            set = _createNewSet(args);\r\n            sets[setName] = set;\r\n        }\r\n        set.blocks.push($block);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Sorts Codebook blocks according to their index data attribute, if they have one.\r\n */\r\nfunction _sortCodeBlocks(set) {\r\n    // If any blocks have an explicit index, sort them\r\n    set.blocks.sort(($blockA, $blockB) => {\r\n        const iA = $blockA.getAttribute(dataAttributes.index);\r\n        const iB = $blockB.getAttribute(dataAttributes.index);\r\n        if (iA === iB) {\r\n            return 0; // Leave the order unchanged\r\n        }\r\n        else if (iA !== null && iB === null) {\r\n            return -1; // Put $blockA first\r\n        }\r\n        else if (iA === null && iB !== null) {\r\n            return +1; // Put $blockB first\r\n        }\r\n        else {\r\n            // Neither index is null\r\n            return (+iA) - (+iB); // Put the code with the lower index first\r\n        }\r\n    });\r\n}\r\n/**\r\n * Creates a new Codebook set.\r\n */\r\nfunction _createNewSet(args) {\r\n    args = args || {};\r\n    return {\r\n        blocks: [],\r\n        args: Object.assign({}, args),\r\n    };\r\n}\r\n/**\r\n * Clears a set's logs, then runs each block within it with the `log` and `html` utility functions available.\r\n */\r\nfunction _runSet(set) {\r\n    const code = set.blocks.reduce(_combineCode, '');\r\n    _clearLogs(set);\r\n    const args = set.args;\r\n    const [argNames, argValues] = _spreadArgs(args);\r\n    if (argNames.includes('_log') ||\r\n        argNames.includes('_$log') ||\r\n        argNames.includes('log') ||\r\n        argNames.includes('_html') ||\r\n        argNames.includes('_$html') ||\r\n        argNames.includes('html')) {\r\n        throw new Error(`Codebook: The following argument names are reserved and cannot be used:\\n'_log', '_$log', 'log', '_html', '_$html', 'html'`);\r\n    }\r\n    const fnFactory = Function.apply(null, argNames.concat(['_log', '_html', `\r\n\t\treturn async () => {\r\n\t\t\t'use strict';\r\n\r\n\t\t\tlet _$log = null;\r\n\t\t\tlet log = function () {};\r\n\r\n\t\t\tlet _$html = null;\r\n\t\t\tlet html = function () {};\r\n\r\n\t\t\t${code}\r\n\t\t};\r\n\t`]));\r\n    const fn = fnFactory.apply(null, argValues.concat([_logOutput, _htmlOutput]));\r\n    return fn();\r\n}\r\n/**\r\n * Clears the contents of all log elements for each block in a given Codebook set.\r\n */\r\nfunction _clearLogs(set) {\r\n    for (let $block of set.blocks) {\r\n        const logId = $block.getAttribute(dataAttributes.log);\r\n        if (logId) {\r\n            const $log = document.getElementById(`${logId}`);\r\n            if ($log) {\r\n                $log.innerHTML = '';\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Converts a CodebookSetArgs object into separate arrays of its arguments' names and values.\r\n */\r\nfunction _spreadArgs(args) {\r\n    const names = Object.keys(args);\r\n    const values = Object.values(args);\r\n    return [\r\n        names,\r\n        values,\r\n    ];\r\n}\r\n/**\r\n * To be used with `Array.prototype.reduce`, combines the code for all blocks within\r\n * a Codebook set and ensures the special `log` and `html` functions always have correct values.\r\n */\r\nfunction _combineCode(allCode, $newCode) {\r\n    let newCode = _decodeHtml($newCode.textContent || '');\r\n    const logId = $newCode.getAttribute(dataAttributes.log);\r\n    if (logId) {\r\n        newCode = `\r\n\t\t\t_$log = document.getElementById('${logId}');\r\n\t\t\tlog = function (...output) {\r\n\t\t\t\t_log(_$log, ...output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\tlog = function () {};\r\n\t\t`;\r\n    }\r\n    const htmlId = $newCode.getAttribute(dataAttributes.html);\r\n    if (htmlId) {\r\n        newCode = `\r\n\t\t\t_$html = document.getElementById('${htmlId}');\r\n\t\t\thtml = function (output) {\r\n\t\t\t\t_html(_$html, output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\thtml = function () {};\r\n\t\t`;\r\n    }\r\n    const combinedCode = `${allCode}\\n${newCode}`;\r\n    return combinedCode;\r\n}\r\n/**\r\n * Read the name of a Codebook block's set.\r\n */\r\nfunction _getSetName($block) {\r\n    let setName = $block.getAttribute(dataAttributes.set);\r\n    if (!setName) {\r\n        const $parent = $block.closest(selectors.set);\r\n        if ($parent) {\r\n            setName = $parent.getAttribute(dataAttributes.set);\r\n        }\r\n        if (!setName) {\r\n            setName = defaultSetName;\r\n        }\r\n    }\r\n    return setName;\r\n}\r\n/**\r\n * A helper function used to create the special `log` function, allowing values inside\r\n * Codebook blocks to be logged to that block's log element.\r\n */\r\nfunction _logOutput($log, ...output) {\r\n    if ($log) {\r\n        output.forEach((outputEl) => {\r\n            let outputString;\r\n            if (outputEl instanceof Date) {\r\n                function padZeroes(num, minLength = 2) {\r\n                    let numStr = num.toString();\r\n                    while (numStr.length < minLength) {\r\n                        numStr = `0${numStr}`;\r\n                    }\r\n                    return numStr;\r\n                }\r\n                const year = outputEl.getFullYear();\r\n                const month = padZeroes(outputEl.getMonth() + 1);\r\n                const day = padZeroes(outputEl.getDate());\r\n                outputString = `${year}-${month}-${day}`;\r\n                if (outputEl.getHours() || outputEl.getMinutes() || outputEl.getSeconds()) {\r\n                    const hours = padZeroes(outputEl.getHours());\r\n                    const minutes = padZeroes(outputEl.getMinutes());\r\n                    const seconds = padZeroes(outputEl.getSeconds());\r\n                    outputString += ` ${hours}:${minutes}:${seconds}`;\r\n                }\r\n            }\r\n            else if (typeof outputEl === 'object') {\r\n                outputString = JSON.stringify(outputEl, null, '\\t');\r\n            }\r\n            else if (typeof outputEl === 'string') {\r\n                outputString = outputEl;\r\n            }\r\n            else {\r\n                // Can't rely on everything having a `toString` method, so use type coercion.\r\n                outputString = '' + outputEl;\r\n            }\r\n            $log.innerHTML += `${outputString}\\n`;\r\n        });\r\n    }\r\n}\r\n/**\r\n * A helper function used to create the special `html` function, allowing values inside\r\n * Codebook blocks to be logged to that block's html element.\r\n */\r\nfunction _htmlOutput($html, output) {\r\n    if ($html) {\r\n        $html.innerHTML = output;\r\n    }\r\n}\r\n/**\r\n * Decode HTML entities in a string by applying it as the value\r\n * of an HTMLTextAreaElement then reading it back again.\r\n */\r\nfunction _decodeHtml(htmlString) {\r\n    // We don't want to see things like =&gt; in code when we really mean =>\r\n    $textarea.innerHTML = htmlString;\r\n    const decodedString = $textarea.value;\r\n    return decodedString;\r\n}\r\n//# sourceMappingURL=codebook.js.map","/**\r\n * Converts a 2D Array into a CSV string.\r\n *\r\n * `stringify` converts most falsey values into empty cells. `undefined`, `''`, and `[]` are all treated this way. `null` and `false`, however, are converted into string representations when stringifying CSV data.\r\n *\r\n * If you need to maintain a value of `undefined`, `''`, or `[]` when stringifying your CSV data, convert it to a string first (e.g. `'undefined'`)\r\n *\r\n * @param {any[][]} data - A 2D Array to convert into a CSV string.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} CSV string\r\n */\r\nfunction stringify(data, options) {\r\n    options = options || {};\r\n    options.transpose = options.transpose || false;\r\n    options.sanitise = options.sanitise || false;\r\n    // Enforce square data and apply CSV escaping, then convert to string\r\n    const rows = data;\r\n    const shapedRows = _shape(data, options);\r\n    const escapedRows = _escape(shapedRows, options);\r\n    const joinedRows = _join(escapedRows);\r\n    return joinedRows;\r\n}\r\n/**\r\n * Pad missing cells with empty strings and, if necessary, transpose the data\r\n *\r\n * @param {any[][]} data - A 2D Array to pad and potentially transpose.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {any[][]} Shaped CSV data\r\n */\r\nfunction _shape(data, options) {\r\n    const transpose = options?.transpose ?? false;\r\n    const maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\r\n    // Flip rows and columns if transposing data\r\n    const iMax = transpose ? maxLength : data.length;\r\n    const jMax = transpose ? data.length : maxLength;\r\n    const rows = [];\r\n    for (let i = 0; i < iMax; i++) {\r\n        const row = [];\r\n        for (let j = 0; j < jMax; j++) {\r\n            const iRow = transpose ? j : i;\r\n            const iCol = transpose ? i : j;\r\n            let cellValue = data[iRow][iCol];\r\n            if (iCol >= data[iRow].length) {\r\n                cellValue = '';\r\n            }\r\n            row.push(cellValue);\r\n        }\r\n        rows.push(row);\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any[][]} rows - A 2D Array with values to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string[][]} Escaped CSV data\r\n */\r\nfunction _escape(rows, options) {\r\n    for (const row of rows) {\r\n        for (let j = 0; j < row.length; j++) {\r\n            row[j] = _escapeCell(row[j], options);\r\n        }\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any} cell - A single value to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} Escaped value\r\n */\r\nfunction _escapeCell(cell, options) {\r\n    const sanitise = options?.sanitise ?? false;\r\n    // Convert to string\r\n    let cellString;\r\n    if (typeof cell === 'undefined') {\r\n        // Replace undefined with ''\r\n        cellString = '';\r\n    }\r\n    else if (typeof cell !== 'string') {\r\n        // Convert to string\r\n        cellString = '' + cell;\r\n    }\r\n    else {\r\n        cellString = cell;\r\n    }\r\n    // Sanitise\r\n    if (sanitise) {\r\n        // Prevent spreadsheet software like\r\n        // Excel from trying to execute code\r\n        if (cellString.match(/^[=\\-+@]/)) {\r\n            cellString = '\\t' + cell;\r\n        }\r\n    }\r\n    // Escape\r\n    if (cellString.match(/,|\"|\\n|\\r/)) {\r\n        // Turn any double quotes into escaped double quotes\r\n        cellString = cellString.replace(/\"/g, '\"\"');\r\n        // Wrap cell in double quotes\r\n        cellString = '\"' + cellString + '\"';\r\n    }\r\n    return cellString;\r\n}\r\n/**\r\n * Join escaped CSV data into a single string.\r\n *\r\n * @param  {string[][]} rows - A 2D Array containing escaped CSV data\r\n *\r\n * @return {string} A CSV string\r\n */\r\nfunction _join(rows) {\r\n    const rowStrings = [];\r\n    for (let i = 0; i < rows.length; i++) {\r\n        rowStrings.push(rows[i].join(','));\r\n    }\r\n    const rowsString = rowStrings.join('\\n');\r\n    return rowsString;\r\n}\r\nexport { stringify };\r\n//# sourceMappingURL=stringify.js.map","function parse(csvString, mapper) {\r\n    const stringRows = _tokenise(csvString);\r\n    _validate(stringRows);\r\n    if (typeof mapper !== 'undefined') {\r\n        const dataRows = stringRows.map((row) => row.map(mapper));\r\n        return dataRows;\r\n    }\r\n    else {\r\n        return stringRows;\r\n    }\r\n}\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString) {\r\n    // Walk through each character and produce an array of tokens\r\n    const tokens = [];\r\n    // Remove carriage returns\r\n    csvString = csvString.replace(/\\r/g, '');\r\n    let inQuote = false;\r\n    let wasQuote = false;\r\n    let tokenStart = 0;\r\n    let row = [];\r\n    for (let i = 0; i < csvString.length; i++) {\r\n        const char = csvString[i];\r\n        const comma = char === ',';\r\n        const quote = char === '\"';\r\n        const newline = char === '\\n';\r\n        const eof = i === csvString.length - 1; // eof - End Of File\r\n        if (inQuote) {\r\n            // Characters may be delimited\r\n            if (quote) {\r\n                // Check if the next character is another double quote, i.e. if it is escaped\r\n                const nextChar = csvString[i + 1];\r\n                if (nextChar === '\"') {\r\n                    // This and the next character combined make an escaped double quote,\r\n                    // so the quote has not ended and we should skip over the next character\r\n                    i++;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // The quote has ended\r\n                    inQuote = false;\r\n                    wasQuote = true;\r\n                    if (!eof) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            else if (eof) {\r\n                throw new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n            }\r\n        }\r\n        if (!inQuote && (comma || newline || eof)) {\r\n            // These are the characters that denote the end of a token\r\n            let token = csvString.substring(tokenStart, i + 1);\r\n            if (comma || newline) {\r\n                // Don't keep the separator\r\n                token = token.substring(0, token.length - 1);\r\n            }\r\n            if (wasQuote) {\r\n                wasQuote = false;\r\n                // Remove start and end quotes\r\n                token = token.substring(1, token.length - 1);\r\n                // Replace escaped quotes\r\n                token = token.replace(/\"\"/g, '\"');\r\n            }\r\n            row.push(token);\r\n            if (comma && eof) {\r\n                // It's the end of the last token, and the last cell is empty\r\n                row.push('');\r\n            }\r\n            if (newline || eof) {\r\n                tokens.push(row);\r\n                if (newline) {\r\n                    row = [];\r\n                }\r\n            }\r\n            tokenStart = i + 1;\r\n        }\r\n        else if (wasQuote) {\r\n            throw new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n        }\r\n        else if (quote) {\r\n            inQuote = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows) {\r\n    // Each row of a CSV should have the same length;\r\n    if (rows && rows.length > 1) {\r\n        let rowLength = rows[0].length;\r\n        for (let i = 1; i < rows.length; i++) {\r\n            let row = rows[i];\r\n            if (row.length !== rowLength) {\r\n                throw new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport { parse };\r\n//# sourceMappingURL=parse.js.map","import { TransformerFn } from './transformers.js';\n\ninterface FileConfig<T extends string> {\n\tpath: string,\n\tcols: Record<T, string | number>,\n\n\theaderRows?: number,\n\tfooterRows?: number,\n\n\taliases?: string[][],\n\ttransform?: Partial<Record<T, TransformerFn<any>>>,\n}\n\n/**\n * Use this function when creating a FileConfig object.\n *\n * It is a noop function, but it's necessary to use a function here\n * in order for the TypeScript compiler to correctly infer the type of T\n */\nconst fileConfig = <T extends string>(fileConfig: FileConfig<T>) => fileConfig;\n\nexport { FileConfig, fileConfig };\n","interface AnalyserRows {\n\tfilter(...args: Parameters<typeof Array.prototype.filter>): this;\n}\n\nclass AnalyserRows extends Array<unknown[]> {\n\tconstructor(source?: unknown[][] | number) {\n\t\tif (Array.isArray(source)) {\n\t\t\tsuper(source.length);\n\t\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\t\tthis[i] = source[i];\n\t\t\t}\n\t\t} else if (typeof source === 'number') {\n\t\t\tsuper(source);\n\t\t} else {\n\t\t\tsuper();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the specified column.\n\t */\n\tgetCol(colNum: number): unknown[] {\n\t\tif (typeof colNum !== 'number') {\n\t\t\tthrow new TypeError(`colNum must be a number.`);\n\t\t} else if (colNum < 0 || colNum >= this[0]?.length) {\n\t\t\tthrow new RangeError(`colNum out of range.`);\n\t\t}\n\n\t\tconst col: unknown[] = [];\n\t\tfor (let row of this) {\n\t\t\tcol.push(row[colNum]);\n\t\t}\n\n\t\treturn col;\n\t}\n\n\t/**\n\t * Adds a new column to AnalyserRows, and returns its index.\n\t */\n\taddCol<T>(creator: (row: any[], index: number) => T): number\n\taddCol<T>(newRow: T[]): number\n\taddCol<T>(creator: ((row: any[], index: number) => T) | T[]): number {\n\t\tconst colIndex = this[0].length;\n\n\t\tif (Array.isArray(creator)) {\n\t\t\tif (this.length !== creator.length) {\n\t\t\t\tthrow new Error(`New column of length ${creator.length} cannot be added. It must be of length ${this.length}.`);\n\t\t\t}\n\n\t\t\tfor (let [i, row] of this.entries()) {\n\t\t\t\trow.push(creator[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let [i, row] of this.entries()) {\n\t\t\t\trow.push(creator(row, i));\n\t\t\t}\n\t\t}\n\n\t\treturn colIndex;\n\t}\n}\n\nexport { AnalyserRows };\n","/**\n * Convert a column heading from spreadsheet software to its integer representation. For example, converts 'A' to 0, or 'ZE' to 680.\n *\n * If a non-negative integer is passed, it will be returned untransformed. Any other value, including an invalid string, will return null.\n */\nfunction getColNumber<T extends number>(colName: T): T | null\nfunction getColNumber<T extends string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null {\n\tif (typeof colName === 'number') {\n\t\tif (Number.isInteger(colName) && colName >= 0) {\n\t\t\treturn colName;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t} else if (colName === '') {\n\t\treturn null;\n\t} else if (typeof colName !== 'string') {\n\t\treturn null;\n\t}\n\n\tconst alphabet: readonly string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\tlet rowNumber = -1; // Adjust for 0-based counting\n\n\tconst upperColName = colName.toUpperCase();\n\tfor (let i = 0; i < upperColName.length; i++) {\n\t\tconst char = upperColName[i];\n\t\tconst charIndex = alphabet.indexOf(char);\n\n\t\tif (charIndex === -1) {\n\t\t\t// colName contains an invalid character\n\t\t\treturn null;\n\t\t}\n\n\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\n\t}\n\n\treturn rowNumber;\n}\n\n/**\n * Converts a map of column names to column identifiers using getColNumbers so all column identifiers are integers.\n *\n * Any columns with invalid identifiers will be removed from the result.\n */\nfunction getColNumbers<T extends string>(colsConfig: Record<T, number | string>): Record<T, number> {\n\tconst newCols: Partial<Record<T, number>> = {};\n\n\tfor (let key in colsConfig) {\n\t\tconst value = colsConfig[key];\n\t\tconst colNumber = getColNumber(value);\n\n\t\tif (typeof colNumber === 'number') {\n\t\t\tnewCols[key] = colNumber;\n\t\t}\n\t}\n\n\treturn newCols as Record<T, number>;\n}\n\nexport {\n\tgetColNumber,\n\tgetColNumbers,\n};\n","import { AnalyserRows } from './AnalyserRows.js';\n\n/**\n * A function for summarising a set of AnalyserRows\n */\ntype AnalyserSummariser<T = any, G = any> = (rows: AnalyserRows, groupName: G) => T;\n\n/**\n * A group of AnalyserSummariser functions\n */\ntype AnalyserSummarisers<SummaryName extends string> = Record<SummaryName, AnalyserSummariser>;\n\nconst defaultSummarisers = {\n\tCount: (rows: AnalyserRows) => rows.length\n} as const;\ntype DefaultSummaryName = keyof typeof defaultSummarisers;\n\n/**\n * A 2D array of the results of AnalyserSummariser functions applied to an AnalyserGroup of AnalyserRows,\n * able to be printed to the console using `console.table`.\n *\n * After the first header row, each row represents a set of AnalyserRows grouped by the value given in the first cell.\n * After the first column, each column represents a summary of a group of AnalyserRows. The name of the summary is given in the first cell.\n */\nexport type AnalyserSummary<SummaryName extends string> = [[unknown, ...SummaryName[]], ...[any, ...any[]][]];\n\ninterface AnalyserGroupOptions {\n\tdiscrete?: boolean,\n}\n\nexport class AnalyserGroup extends Map<any, AnalyserRows> {\n\t#discrete: boolean\n\n\tconstructor(options?: AnalyserGroupOptions) {\n\t\tsuper();\n\n\t\tif (typeof options?.discrete === 'boolean') {\n\t\t\tthis.#discrete = options.discrete;\n\t\t} else {\n\t\t\tthis.#discrete = true;\n\t\t}\n\t}\n\n\t/**\n\t * Create a 2D summary array that can be printed using console.table.\n\t */\n\tsummarise(): AnalyserSummary<DefaultSummaryName>\n\tsummarise<SummaryName extends string>(summarisers: AnalyserSummarisers<SummaryName>): AnalyserSummary<SummaryName>\n\tsummarise<SummaryName extends string>(summarisersArg?: AnalyserSummarisers<SummaryName>): AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName> {\n\t\t// If there was no argument, use a default value instead. This will affect the return type, as per the overloads\n\t\tconst summarisers = summarisersArg ?? defaultSummarisers;\n\n\t\tconst summaryNames = Object.keys(summarisers) as (DefaultSummaryName)[] | SummaryName[];\n\t\tconst summaryHeaderRow = ['Value', ...summaryNames] as const;\n\n\t\tlet summaryValueRows: [any, ...any[]][] = [];\n\t\tfor (let [groupName, rows] of this.entries()) {\n\t\t\tconst summaryRow: [any, ...any[]] = [groupName];\n\n\t\t\tfor (let [, summariser] of Object.entries<AnalyserSummariser>(summarisers)) {\n\t\t\t\tconst rowSummary = summariser(rows, groupName);\n\t\t\t\tsummaryRow.push(rowSummary);\n\t\t\t}\n\n\t\t\tsummaryValueRows.push(summaryRow);\n\t\t}\n\n\t\tif (this.#discrete) {\n\t\t\t// Sort summary based on its values\n\n\t\t\t// Use basic Array.prototype.sort to sort numbers or strings, to use as a reference when sorting the summary\n\t\t\tconst summaryValues = summaryValueRows.map((summaryRow) => summaryRow[0]);\n\t\t\tconst summaryValuesSorted = summaryValues.sort();\n\n\t\t\t// Sort summary value rows using the sorted values as a reference\n\t\t\tsummaryValueRows = summaryValueRows.sort((a, b) => summaryValuesSorted.indexOf(a[0]) - summaryValuesSorted.indexOf(b[0]));\n\t\t}\n\n\t\tconst summary = [summaryHeaderRow, ...summaryValueRows];\n\n\t\t// Let the overloads tell TypeScript which type the summary actually is.\n\t\t// If there was no `summarisersArg` argument, it will be AnalyserSummary<DefaultSummaryNames>,\n\t\t// otherwise the type T could be inferred so no default was necessary and it will be AnalyserSummary<SummaryName>\n\t\treturn summary as AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName>;\n\t}\n}\n","import { AnalyserRows } from './AnalyserRows.js';\n\ntype FilterInput = ((value: any) => boolean) | any[] | Exclude<any, []>\n\n/**\n * A function used by Array.prototype.filter\n */\ninterface FilterResolver {\n\t(val: any, index: number, arr: any[]): boolean,\n}\n\n/**\n * A FilterResolver that can be extended using FilterResolverExtender methods\n */\ninterface ExtensibleFilterResolver extends FilterResolver {\n\tandBy: FilterResolverExtender,\n\torBy: FilterResolverExtender,\n}\n\n/**\n * A function that either creates a new FilterResolver or extends and existing one, embedding information about the column to look at and the values to match.\n */\ninterface FilterResolverExtender {\n\t(colIndex: number, values: FilterInput): ExtensibleFilterResolver,\n}\n\n/**\n * Creates a function that remembers a set of aliases, and can be called\n * to create a function that can be used with Array.prototype.filter to\n * use that alias when filtering a set of data using _applyFilter.\n */\nfunction createFilterFn(aliases?: string[][]): FilterResolverExtender {\n\tconst by = function (colIndex: number, values: FilterInput) {\n\t\tconst applyFilterToRow: FilterResolver = function (row, index, arr) {\n\t\t\treturn _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst extendedApplyFilterToRow = _extendFilterFn(applyFilterToRow, aliases);\n\n\t\treturn extendedApplyFilterToRow;\n\t};\n\n\treturn by;\n}\n\n/**\n * Extend a FilterResolver into an ExtensibleFilterResolver, including embedding an optional set of aliases.\n */\nfunction _extendFilterFn(filterResolver: FilterResolver, aliases?: string[][]): ExtensibleFilterResolver {\n\tconst extendedFilterResolver = filterResolver as ExtensibleFilterResolver;\n\n\textendedFilterResolver.andBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) && _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\textendedFilterResolver.orBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) || _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\treturn extendedFilterResolver;\n}\n\n/**\n * Applies a filter to a specific row, looking at a specified column index\n * and checking its value against either a specific value, a set of values,\n * or a function.\n *\n * If the value or values being checked against are strings, a set of\n * aliases can be used as well.\n */\nfunction _applyFilter(row: any[], colIndex: number, values: FilterInput, aliases?: string[][]): boolean {\n\tif (typeof values === 'function') {\n\t\treturn values(row[colIndex]);\n\t}\n\n\tif (!Array.isArray(values)) {\n\t\tvalues = [values];\n\t}\n\n\tconst cell = row[colIndex];\n\tlet cellValues;\n\n\tif (Array.isArray(cell)) {\n\t\tcellValues = cell;\n\t} else {\n\t\tcellValues = [cell];\n\t}\n\n\tfor (let cellValue of cellValues) {\n\t\tfor (let value of values) {\n\t\t\tif (_matchAlias(value, cellValue, aliases)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Checks if the value of a cell matches the value passed,\n * optionally taking one or more sets of aliases to match.\n */\nfunction _matchAlias(cell: any, value: any, aliases?: string[][]): boolean {\n\tif (cell === value) {\n\t\treturn true;\n\t}\n\n\tif (aliases && typeof cell === 'string' && typeof value === 'string') {\n\t\tfor (let aliasList of aliases) {\n\t\t\tif (aliasList.includes(cell) && aliasList.includes(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport {\n\tcreateFilterFn,\n\n\tFilterResolverExtender,\n\tExtensibleFilterResolver,\n};\n","//////////////////////////\n// Appearance functions //\n//////////////////////////\n\nexport interface TransformerFn<T> {\n\t(value: string, locationIdentifier?: string): T extends any[] ? T : (T | null)\n}\n\n/**\n * Checks if a string appears like it represents true\n */\nfunction appearsTrue(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'true';\n}\n\n/**\n * Checks if a string appears like it represents false\n */\nfunction appearsFalse(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'false';\n}\n\n/**\n * Checks if a string appears like it represents a boolean vaue\n */\nfunction appearsBoolean(value: string): boolean {\n\treturn appearsTrue(value) || appearsFalse(value);\n}\n\ntype NoCommas<T extends string> = T extends `${infer U},${infer V}` ? NoCommas<`${U}${V}`> : T;\ntype NoPercent<T extends string> = T extends `${infer W}%` ? W : T;\ntype CleanNumberLike<T extends string> = NoCommas<NoPercent<T>>;\n\n/**\n * Removes any ',' characters, and any '%' at the end of\n * a string that may appear like it represents a number\n */\nfunction cleanNumberLike<T extends string>(value: T): CleanNumberLike<T> {\n\tconst cleanValue = value.replace(/,|%$/g, '') as CleanNumberLike<T>;\n\treturn cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a number\n */\nfunction appearsNumber(value: string): boolean {\n\tconst cleanValue = cleanNumberLike(value);\n\n\treturn parseFloat(cleanValue) === +cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a percentage\n */\nfunction appearsPercentage(value: string): boolean {\n\treturn appearsNumber(value) && !!value.match(/%$/);\n}\n\n///////////////////////////\n// Transformer functions //\n///////////////////////////\n\n/**\n * Splits a string into an array using String.prototype.split\n */\nexport function array(separator: string | RegExp, limit?: number): TransformerFn<string[]> {\n\treturn function (value: string): string[] {\n\t\treturn value.split(separator, limit);\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation using a custom definition.\n *\n *  If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport function booleanCustom(truthy: string | RegExp = 'true', falsey: string | RegExp = 'false'): TransformerFn<boolean> {\n\treturn function (value: string, locationIdentifier?: string): boolean | null {\n\t\tconst cleanedValue = value.trim().toLowerCase();\n\n\t\tif (typeof truthy === 'string') {\n\t\t\tif (cleanedValue === truthy.trim().toLowerCase()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (truthy.test(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof falsey === 'string') {\n\t\t\tif (cleanedValue === falsey.trim().toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (falsey.test(value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (value) {\n\t\t\tconsole.warn(`Boolean value not found in '${value}', checking for ${truthy} or ${falsey} (${locationIdentifier})`);\n\t\t}\n\t\treturn null;\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation, if it contains one.\n *\n * If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport const boolean = booleanCustom();\n\n/**\n * Extracts a number from a string representation, if it contains one.\n * Strings ending with '%' are treated as percentages and divided by 100.\n *\n * If the value doesn't appear like it represents a number, a warning will be generated.\n */\nexport const number: TransformerFn<number> = (value: string, locationIdentifier?: string): number | null => {\n\tif (appearsNumber(value)) {\n\t\t// Condition matches if the entire string represents a number\n\n\t\tlet cleanValue: string = cleanNumberLike(value);\n\n\t\tif (appearsPercentage(value)) {\n\t\t\t// If value is a percentage string, divide by 100\n\t\t\tconst numValue = +cleanValue / 100;\n\n\t\t\t// To prevent division causing rounding errors, like\n\t\t\t// 0.10800000000000001, use string representation to\n\t\t\t// determine how to round the number.\n\n\t\t\t// Remove everything up to (and including) a radix point\n\t\t\t// e.g. convert '82.643' to '643'\n\t\t\tconst truncatedValue = cleanValue.replace(/^[^.]+\\.?/, '');\n\n\t\t\tconst precision = truncatedValue.length;\n\n\t\t\t// Add 2 to precision to compensate for dividing by 100\n\t\t\tcleanValue = numValue.toFixed(precision + 2);\n\t\t}\n\n\t\treturn +cleanValue;\n\t} else {\n\t\tif (value) {\n\t\t\tconsole.warn(`Number value not found in '${value}' (${locationIdentifier})`);\n\t\t}\n\t\treturn null;\n\t}\n}\n\n/**\n * Extracts boolean or number values from string representations if appropriate.\n *\n * No warnings will be generated if the value doesn't appear like a boolean or number.\n */\nexport const value: TransformerFn<boolean | number> = (value: string, locationIdentifier?: string): boolean | number | null => {\n\tif (appearsBoolean(value)) {\n\t\treturn boolean(value);\n\t} else if (appearsNumber(value)) {\n\t\treturn number(value);\n\t} else {\n\t\tconsole.warn(`Boolean or number value not found in '${value}' (${locationIdentifier})`);\n\t\treturn null;\n\t}\n}\n\n/**\n * Checks that the value, if it exists, is a member of an enum.\n *\n * If the value does not exist, it is transformed to null.\n *\n * If a recoding map is passed, and it contains instructions for this value, it is recoded first.\n *\n * If the value exists but it is not a member of the enum and cannot be recoded,\n * a warning will be generated and null will be returned.\n */\nexport function enumValue<E extends string>(enums: Record<string, E>, recodeMap?: Record<string, E>): TransformerFn<E> {\n\tconst enumValues: E[] = Object.values(enums);\n\n\tfunction isEnumMember(val: unknown): val is E {\n\t\t// Use `as any[]` so TypeScript doesn't complain when using Array.prototype.includes\n\t\treturn (enumValues as any[]).includes(val);\n\t}\n\n\tconst transformer = ((value: string, locationIdentifier?: string) => {\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isEnumMember(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (recodeMap && value in recodeMap) {\n\t\t\tconst recodedValue = recodeMap[value];\n\t\t\treturn recodedValue;\n\t\t}\n\n\t\tconsole.warn(`Value '${value}' does not exist within ${enumValues.join(', ')} (${locationIdentifier})`);\n\t\treturn null;\n\t}) as TransformerFn<E>;\n\t// Need to use a type assertion here as TypeScript doesn't know how to use the generic constraint to resolve the conditional type\n\t// See https://stackoverflow.com/questions/70553130/typescript-generic-conditional-type-as-return-value-for-generic-function/70553240#70553240\n\n\treturn transformer;\n}\n","import { parse as parseCSV } from '@cipscis/csv';\n\nimport { AnalyserRows } from './AnalyserRows.js';\nimport { FileConfig } from './FileConfig.js';\nimport { DataConfig } from './DataConfig.js';\n\nimport { getColNumbers } from './helpers.js';\n\nimport { createGroupFn } from './grouping.js';\nimport { createFilterFn } from './filtering.js';\n\nimport * as transformers from './transformers.js';\n\n/**\n * Load a single CSV file and process its contents, then return them.\n */\nasync function loadFile<T extends string>(fileConfig: FileConfig<T>): Promise<DataConfig<T>> {\n\tconst response = await fetch(fileConfig.path);\n\n\tif (response.ok) {\n\t\tconst data = await response.text();\n\n\t\tconst rows = parseCSV(data);\n\t\tconst dataConfig = _processData(rows, fileConfig);\n\t\treturn dataConfig;\n\t} else {\n\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\n\t}\n}\n\n/**\n * Processes CSV data into a DataConfig object ready for analysis via code.\n */\nfunction _processData<T extends string>(rows: string[][], fileConfig: FileConfig<T>): DataConfig<T> {\n\t// Remove header rows\n\tif (fileConfig.headerRows) {\n\t\trows.splice(0, fileConfig.headerRows);\n\t}\n\n\t// Remove footer rows\n\tif (fileConfig.footerRows) {\n\t\trows.splice(-fileConfig.footerRows);\n\t}\n\n\tconst by = createFilterFn(fileConfig.aliases);\n\tconst group = createGroupFn(by, fileConfig.aliases);\n\n\tconst dataConfig: DataConfig<T> = {\n\t\trows: new AnalyserRows(rows),\n\t\tcols: getColNumbers(fileConfig.cols),\n\t\taddedCols: {},\n\t\tby,\n\t\tgroup,\n\t};\n\n\tif (fileConfig.aliases) {\n\t\tdataConfig.aliases = fileConfig.aliases;\n\t}\n\n\tif (fileConfig.transform) {\n\t\tfor (let colName in fileConfig.transform) {\n\t\t\tif (!(colName in dataConfig.cols)) {\n\t\t\t\tconsole.warn(`Column '${colName}' specified in transform not found in cols.`);\n\t\t\t} else {\n\t\t\t\tconst colNum = dataConfig.cols[colName];\n\t\t\t\tconst transformFn = fileConfig.transform[colName];\n\n\t\t\t\t// Some of these conditions are ignored because they're intended to help when TypeScript isn't being used\n\t\t\t\tif (transformFn === transformers.array) {\n\t\t\t\t\tthrow new Error(`The 'array' transformer cannot be used directly. Please pass a 'separator' argument.`);\n\t\t\t\t} else if (transformFn === transformers.booleanCustom) {\n\t\t\t\t\tthrow new Error(`The 'booleanCustom' transformer cannot be used directly. Please invoke it to create a transformer function.`);\n\t\t\t\t// @ts-ignore\n\t\t\t\t} else if (transformFn === transformers.enumValue) {\n\t\t\t\t\tthrow new Error(`The 'enumValue' transformer cannot be used directly. Please pass an 'enums' argument.`);\n\t\t\t\t}\n\n\t\t\t\tfor (let row of rows) {\n\t\t\t\t\tif (transformFn) {\n\t\t\t\t\t\tconst locationIdentifier = `column ${colName}, row ${rows.indexOf(row)}`;\n\t\t\t\t\t\trow[colNum] = transformFn(row[colNum], locationIdentifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dataConfig;\n}\n\nexport { loadFile };\n","import { AnalyserRows } from './AnalyserRows.js';\nimport { FilterResolverExtender, ExtensibleFilterResolver } from './filtering.js';\n\nimport { AnalyserGroup } from './AnalyserGroup.js';\n\ninterface Grouper {\n\t(rows: AnalyserRows, colNum: number): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, numGroups: number, right?: boolean): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, splitPoints: number[], right?: boolean): AnalyserGroup\n}\n\n/**\n * Creates a function that uses a FilterResolverExtender with an embedded\n * set of aliases, to create a summarisable group of AnalyserRows split\n * based on the specified column.\n */\nfunction createGroupFn (by: FilterResolverExtender, aliases?: string[][]): Grouper {\n\tconst grouperFn: Grouper = function (rows: AnalyserRows, colNum: number, splitting?: number | number[], right: boolean = true): AnalyserGroup {\n\t\t// Ignore aliases for now, and don't worry about splitting\n\n\t\t// First, collect enums\n\t\tconst enums: Set<unknown> = new Set();\n\t\tfor (let row of rows) {\n\t\t\tconst cellValue = row[colNum];\n\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\tfor (let value of cellValue) {\n\t\t\t\t\tenums.add(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenums.add(cellValue);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof splitting === 'undefined') {\n\t\t\t// Treat data as discrete\n\n\t\t\tif (aliases) {\n\t\t\t\tfor (let val of enums) {\n\t\t\t\t\tif (typeof val === 'string') {\n\t\t\t\t\t\t// If the value is a string in one or more alias sets,\n\t\t\t\t\t\t// ensure those sets will be used for grouping and\n\t\t\t\t\t\t// ensure only canonical values will be checked directly.\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and is **not** the canonical value */\n\t\t\t\t\t\tlet isNonCanonical = false;\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and **is** the canonical value */\n\t\t\t\t\t\tlet isCanonical = false;\n\n\t\t\t\t\t\tfor (let aliasList of aliases) {\n\t\t\t\t\t\t\tif (aliasList.includes(val)) {\n\t\t\t\t\t\t\t\tif (aliasList[0] === val) {\n\t\t\t\t\t\t\t\t\tisCanonical = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tisNonCanonical = true;\n\n\t\t\t\t\t\t\t\t\t// Remember the canonical value\n\t\t\t\t\t\t\t\t\tif (enums.has(aliasList[0]) === false) {\n\t\t\t\t\t\t\t\t\t\tenums.add(aliasList[0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the value is one one or more alias sets, but is never the canonical value,\n\t\t\t\t\t\t// then remove it from the set of enums to use for grouping.\n\t\t\t\t\t\tif (isCanonical === false && isNonCanonical === true) {\n\t\t\t\t\t\t\tenums.delete(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Then, interate through each enum and filter rows into groups\n\t\t\tconst group = new AnalyserGroup();\n\t\t\tfor (let val of enums) {\n\t\t\t\tconst matchingRows = rows.filter(by(colNum, val));\n\t\t\t\tgroup.set(val, matchingRows);\n\t\t\t}\n\t\t\treturn group;\n\t\t} else {\n\t\t\t// Treat data as continuous\n\n\t\t\t// Create the limits for each set\n\t\t\tconst setLimits: [number, number][] = [];\n\t\t\tif (typeof splitting === 'number') {\n\t\t\t\t// Create splitting number of groups based on values retrieved\n\n\t\t\t\tif (Number.isInteger(splitting) === false || splitting < 2) {\n\t\t\t\t\tthrow new RangeError(`The 'numGroups' argument must be an integer greater than 1.`);\n\t\t\t\t}\n\n\t\t\t\t// Sets are unordered, so create and sort an array (ascending)\n\t\t\t\tconst enumArr = new Array(...enums);\n\n\t\t\t\tif (enumArr.every((x: any): x is number => typeof x === 'number')) {\n\t\t\t\t\tconst values = enumArr.sort((a, b) => a - b);\n\n\t\t\t\t\tconst [min, max] = [values[0], values[values.length-1]];\n\n\t\t\t\t\tconst setSize = (max - min) / splitting;\n\t\t\t\t\tfor (let i = 0; i < splitting; i++) {\n\t\t\t\t\t\tconst setMin = min + i * setSize;\n\t\t\t\t\t\tconst setMax = min + (i+1) * setSize;\n\n\t\t\t\t\t\tsetLimits.push([setMin, setMax]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError(`Cannot split values based on a number unless each of those values is a number.`);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(splitting)) {\n\t\t\t\tif (splitting.length === 0) {\n\t\t\t\t\tthrow new RangeError(`At least one number is required for the 'splitPoints' argument.`);\n\t\t\t\t} else if (splitting.every((val) => typeof val === 'number') === false) {\n\t\t\t\t\tthrow new TypeError(`All 'splitPoints' must be numbers.`);\n\t\t\t\t}\n\n\t\t\t\t// Ensure splitting values are ordered (ascending)\n\t\t\t\tconst splitValues = splitting.concat().sort((a, b) => a - b);\n\n\t\t\t\t// Outer bounds will be -Infinity and Infinity\n\t\t\t\tsetLimits.push([-Infinity, splitValues[0]]);\n\n\t\t\t\tfor (let i = 0; i < splitValues.length-1; i++) {\n\t\t\t\t\tsetLimits.push([splitValues[i], splitValues[i+1]]);\n\t\t\t\t}\n\n\t\t\t\tsetLimits.push([splitValues[splitValues.length-1], Infinity]);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError(`Invalid argument type: ${typeof splitting}`);\n\t\t\t}\n\n\t\t\t// Group rows based on set limits\n\t\t\tconst group = new AnalyserGroup({ discrete: false });\n\t\t\tfor (let row of rows) {\n\t\t\t\tfor (let set of setLimits) {\n\t\t\t\t\tlet setName = '';\n\t\t\t\t\tlet filterFn: ExtensibleFilterResolver;\n\n\t\t\t\t\tif (right) {\n\t\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\t\tsetName += `${set[0]} < `;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetName += `x`;\n\t\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\t\tsetName += ` <= ${set[1]}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] < val && val <= set[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\t\tsetName += `${set[0]} <= `;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetName += `x`;\n\t\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\t\tsetName += ` < ${set[1]}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] <= val && val < set[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst matchingRows = rows.filter(filterFn);\n\n\t\t\t\t\tgroup.set(setName, matchingRows);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\t};\n\n\treturn grouperFn;\n}\n\nexport {\n\tcreateGroupFn,\n\n\tGrouper,\n};","function getNumArray(val: number[] | [number[]]): number[] {\n\tif (\n\t\t((value: any[]): value is [number[]] => {\n\t\t\treturn value.length === 1 && Array.isArray(value[0]);\n\t\t})(val)\n\t) {\n\t\treturn val[0];\n\t} else {\n\t\treturn val;\n\t}\n}\n\n/**\n * Return the sum of an array of numbers.\n */\nexport function sum(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn numbers.reduce(function (sum: number, val: number) {\n\t\treturn sum + val;\n\t}, 0);\n}\n\n/**\n * Returns the mean of an array of numbers.\n */\nexport function mean(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn sum(numbers) / numbers.length;\n}\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { ChartOptions } from './ChartOptions.js';\n\nexport type ChartData<GroupName extends string = string> = {\n\tlabels: any[],\n\tgroupNames: GroupName[],\n\tgroups: number[][],\n\n\tmin?: number,\n\tmax?: number,\n\n\tstacked?: boolean,\n};\n\nexport function getChartData<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: ChartOptions<GroupName>): ChartData<GroupName> {\n\tconst [[, ...groupNames]] = summary; // Ignore first 'Value' entry in first row\n\tlet [, ...valueRows] = summary; // Ignore first row of group names\n\n\t// Extract the labels\n\tlet labels = valueRows.map((row) => row[0]);\n\n\t// If the x axis is qualitative, and its labels were limited in its options\n\tif (options?.x && 'labels' in options.x && options.x.labels) {\n\t\t// Remove any labels not specified in the axis options\n\t\tfor (let i = 0; i < labels.length; i++) {\n\t\t\tconst label = labels[i];\n\t\t\tif (options.x.labels.includes(label) === false) {\n\t\t\t\tlabels.splice(i, 1);\n\t\t\t\tvalueRows.splice(i, 1);\n\t\t\t\ti -= i;\n\t\t\t}\n\t\t}\n\n\t\t// Go through specified labels, and if any weren't in the dataset then add empty data\n\t\tfor (let i = 0; i < options.x.labels.length; i++) {\n\t\t\tconst label = options.x.labels[i];\n\t\t\tif (labels.includes(label) === false) {\n\t\t\t\tconst emptyData: [string, ...0[]] = [label, ...(new Array(valueRows[0].length-1)).fill(0)];\n\t\t\t\tlabels.splice(i, 0, label);\n\t\t\t\tvalueRows.splice(i, 0, emptyData);\n\t\t\t}\n\t\t}\n\n\t\t// Also update order of labels and value rows to match specified label order\n\t\tlabels = options.x.labels;\n\t\tvalueRows = valueRows.sort((rowA, rowB) => {\n\t\t\tconst labelA = rowA[0];\n\t\t\tconst indexA = labels.indexOf(labelA);\n\n\t\t\tconst labelB = rowB[0];\n\t\t\tconst indexB = labels.indexOf(labelB);\n\n\t\t\treturn indexA - indexB;\n\t\t});\n\t}\n\n\t// Transpose valueRows to get groups\n\tconst valueGroups: any[][] = [];\n\tfor (let i = 0; i < valueRows.length; i++) {\n\t\t// Start at j = 1 to ignore labels\n\t\tfor (let j = 1; j < valueRows[i].length; j++) {\n\t\t\tif (typeof valueGroups[j] === 'undefined') {\n\t\t\t\tvalueGroups[j] = [];\n\t\t\t}\n\t\t\tvalueGroups[j][i] = valueRows[i][j]\n\t\t}\n\t}\n\t// This method has given us an empty element at index 0, so remove it\n\tvalueGroups.splice(0, 1);\n\n\t// We can only graph groups if all their values are numbers\n\tconst numberValueGroups = valueGroups.filter(\n\t\t(group): group is number[] => group.every(\n\t\t\t(value): value is number => typeof value === 'number'\n\t\t)\n\t);\n\n\t// Filter out the same non-number groups from the groupNames list\n\tconst numberValueGroupNames = groupNames.filter(\n\t\t(groupName, index) => numberValueGroups.includes(valueGroups[index])\n\t);\n\n\tconst chartData: ChartData<GroupName> = {\n\t\tlabels,\n\t\tgroupNames: numberValueGroupNames,\n\t\tgroups: numberValueGroups,\n\t};\n\n\tif (options && 'stacked' in options) {\n\t\tchartData.stacked = options.stacked;\n\t}\n\n\treturn chartData;\n}\n","import * as statistics from '../statistics.js';\nimport { ChartData } from './ChartData.js';\nimport { ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\n\nexport interface ScaleOptions {\n\tmin: number,\n\tmax: number,\n}\n\nexport class Scale {\n\tmin: number;\n\tmax: number;\n\n\tget width(): number {\n\t\treturn this.max - this.min;\n\t};\n\n\tconstructor(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x') {\n\t\t[this.min, this.max] = getMinMax(options, chartOptions, type);\n\t}\n\n\t/**\n\t * Standardises the scale to go from 0 to 1,\n\t * then finds the value's position within it.\n\t */\n\tgetProportion(value: number): number {\n\t\tconst proportion = (value - this.min) / this.width;\n\n\t\treturn proportion;\n\t}\n\n\t/**\n\t * Given a proportion value on a scale from 0 to 1,\n\t * find the equivalent value on this scale.\n\t */\n\tgetValue(proportion: number): number {\n\t\tconst value = this.width * proportion + this.min;\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * For a given length of at least 2, create an array\n\t * of numbers from the bottom of the scale to the top,\n\t * with an equal step between each number in the range.\n\t */\n\tgetSeries(length: number): number[] {\n\t\tif (length < 2) {\n\t\t\tlength = 2;\n\t\t}\n\n\t\tconst stepSize = this.width / (length-1);\n\n\t\t// Start with minimum value\n\t\tconst series: number[] = [this.min];\n\n\t\t// Add intermediate steps\n\t\tfor (let i = 0; i < length-2; i++) {\n\t\t\tseries.push(series[series.length-1] + stepSize);\n\t\t}\n\n\t\t// End with max value\n\t\tseries.push(this.max);\n\n\t\treturn series;\n\t}\n}\n\n/**\n * Determines the appropriate method for reading or calculating min and max values,\n * based on the available data and options, then reads or calculates them.\n */\nfunction getMinMax(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x'): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\t// First, get minMax from options\n\tif ('groups' in options) {\n\t\t// options is of type ChartData, so determine min and max based on\n\t\t// the labels or the data, depending on the type of scale being created\n\t\tif (type === 'x') {\n\t\t\t[min, max] = getMinMaxFromChartDataLabels(options);\n\t\t} else {\n\t\t\t[min, max] = getMinMaxFromChartData(options);\n\t\t}\n\t} else {\n\t\t// options is a ScaleOptions, so read min and max directly\n\t\t[min, max] = getMinMaxFromScaleOptions(options);\n\t}\n\n\t// If min is larger than max, swap them around\n\tif (min > max) {\n\t\t[min, max] = [max, min];\n\t}\n\n\t// Then, see if min and/or max are overridden by chartOptions\n\tif (type && chartOptions) {\n\t\tconst axisOptions = chartOptions[type];\n\t\tif (axisOptions && ('min' in axisOptions || 'max' in axisOptions || 'values' in axisOptions)) {\n\t\t\tconst allowAuto = type !== 'x';\n\t\t\t[min, max] = getMinMaxFromAxisOptions(axisOptions, min, max, allowAuto);\n\t\t}\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the values contained in a set of ChartData.\n */\nfunction getMinMaxFromChartData(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { groups } = options;\n\n\tif (!groups.length || !groups[0].length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tlet allValues: number[];\n\tif ('stacked' in options && options.stacked) {\n\t\tallValues = groups[0].map((el, i) => groups.reduce((sum, group) => sum + group[i], 0));\n\t} else {\n\t\t// Use `as number[]` here so TypeScript doesn't complain when using Array.prototype.concat\n\t\tallValues = ([] as number[]).concat(...groups);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...allValues);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...allValues);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the labels for a set of ChartData.\n * Assumes all labels can be converted to numbers, and will throw an error if this assumption is false.\n */\nfunction getMinMaxFromChartDataLabels(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { labels } = options;\n\n\tif (!labels.length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tconst numberLabels = labels.map((label) => typeof label === 'number' ? label : +label);\n\tif (!numberLabels.every((label) => isNaN(label) === false)) {\n\t\tthrow new TypeError(`Cannot extract minimum or maximum values from labels that aren't all numbers.`);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...numberLabels);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...numberLabels);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Reads min and max values directly from a ScaleOptions object.\n */\nfunction getMinMaxFromScaleOptions(options: ScaleOptions): [number, number] {\n\tconst { min, max } = options;\n\n\treturn [min, max];\n}\n\n/**\n * Determines min and max values from an AxisOptions object, either reading them\n * directly from the options or calculating them from the highest order of magnitude\n * and, if specified, the number of values that needs to display on an axis.\n */\nfunction getMinMaxFromAxisOptions(axisOptions: AxisOptionsQuantitative, min: number, max: number, allowAuto = true): [number, number] {\n\tif (\n\t\t(Array.isArray(axisOptions.values) && axisOptions.values.length) ||\n\t\t(Array.isArray(axisOptions.gridlines) && axisOptions.gridlines.length)\n\t) {\n\t\t// If all the axis values or gridlines are specified,\n\t\t// the values they determine can extend min and/or max\n\t\t// past the values already determined.\n\n\t\t// Axis options can specify values as dates, but Scale always works with numbers\n\t\tlet allValues: number[] = [];\n\t\tif (Array.isArray(axisOptions.values)) {\n\t\t\tallValues = allValues.concat(axisOptions.values.map((val) => +val));\n\t\t}\n\t\tif (Array.isArray(axisOptions.gridlines)) {\n\t\t\tallValues = allValues.concat(axisOptions.gridlines.map((val) => +val));\n\t\t}\n\t\tmin = Math.min(min, ...allValues);\n\t\tmax = Math.max(max, ...allValues);\n\t}\n\n\tif (typeof axisOptions.min === 'number') {\n\t\tmin = axisOptions.min;\n\t} else if (allowAuto && (axisOptions.min === 'auto' || typeof axisOptions.min === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Round down min to nearest multiple of that power of 10\n\t\tconst widthRoundTo = Math.pow(10, maxPower);\n\t\tmin = Math.floor(min / widthRoundTo) * widthRoundTo;\n\n\t\t// If the power was negative, fix any floating point issues that may have arisen\n\t\tif (maxPower < 0) {\n\t\t\tmin = +(min.toFixed(-maxPower));\n\t\t}\n\t}\n\n\tif (typeof axisOptions.max === 'number') {\n\t\tmax = axisOptions.max;\n\t} else if (allowAuto && (axisOptions.max === 'auto' || typeof axisOptions.max === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Subtract min so we're working directly with the width\n\t\tmax -= min;\n\n\t\t// Round up max to nearest multiple of that power of 10\n\t\tlet widthRoundTo = Math.pow(10, maxPower);\n\t\tmax = Math.ceil(max / widthRoundTo) * widthRoundTo;\n\n\t\t// If the number of values to be displayed has been set\n\t\tif (typeof axisOptions.values === 'number') {\n\t\t\t// Only integers are accepted\n\t\t\tif (Number.isInteger(axisOptions.values) === false) {\n\t\t\t\tthrow new TypeError(`axisOptions.values must be an integer.`);\n\t\t\t}\n\n\t\t\t// Continue to increase max until it is a multiple of the next\n\t\t\t// greatest power of 10 below the largest one beneath max.\n\t\t\t// Also, ensure max is greater than min\n\t\t\tconst valuePower = maxPower - 1;\n\t\t\tlet valueRoundTo = Math.pow(10, valuePower) * axisOptions.values;\n\n\t\t\t// If that power is negative, JavaScript can run into issues\n\t\t\t// to do with numbers like 0.1 being unable to be represented in binary.\n\t\t\t// So multiply everything by that power and round it, then divide and fix at the end\n\t\t\tif (valuePower < 0) {\n\t\t\t\tvalueRoundTo = Math.round(valueRoundTo / Math.pow(10, valuePower));\n\t\t\t\twidthRoundTo = Math.round(widthRoundTo / Math.pow(10, valuePower));\n\t\t\t\tmax = Math.round(max / Math.pow(10, valuePower));\n\t\t\t}\n\n\t\t\tfor (let iterations = 0; iterations < 1000; iterations++) {\n\t\t\t\tlet remainder = max % valueRoundTo;\n\n\t\t\t\tif (remainder === 0 && max > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tmax += widthRoundTo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we muliplied everything earlier, undo that now then fix any floating point issues\n\t\t\tif (valuePower < 0) {\n\t\t\t\tmax = +(max * Math.pow(10, valuePower)).toFixed(-valuePower);\n\t\t\t}\n\t\t}\n\n\t\t// Add min back to convert width back to max\n\t\tmax += min;\n\t}\n\n\treturn [min, max];\n}\n","import { ChartData } from './ChartData.js';\nimport { BaseChartOptions, ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\nimport { Scale } from './Scale.js';\n\nexport function chart<GroupName extends string>(chartData: ChartData<GroupName>, contents: string, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<figure class=\"chart\">\n\t\t\t${options?.title ? title(options) : ''}\n\n\t\t\t<div class=\"chart__area\">\n\t\t\t\t${options?.legend ? legend(chartData, options) : ''}\n\n\t\t\t\t${yGridlines(chartData, options)}\n\n\t\t\t\t${xGridlines(chartData, options)}\n\n\t\t\t\t${contents}\n\t\t\t</div>\n\n\t\t\t${yAxis(chartData, options)}\n\n\t\t\t${xAxis(chartData, options)}\n\t\t</figure>\n\t`;\n}\n\nfunction title<GroupName extends string>(options: ChartOptions<GroupName>): string {\n\treturn `<figcaption class=\"chart__title\">${options.title}</figcaption>`;\n}\n\nfunction legend<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<div class=\"chart__legend\">\n\t\t\t<span class=\"chart__legend__title\">Legend</span>\n\n\t\t\t<ul class=\"chart__legend__items\">\n\t\t\t\t${chartData.groupNames.map((groupName, index) => {\n\t\t\t\t\tconst colour = options?.colours && options.colours[groupName];\n\n\t\t\t\t\tconst str = `<li class=\"chart__legend__item\">\n\t\t\t\t\t\t<span class=\"chart__legend__item__swatch\"${colour ? ` style=\"background-color: ${colour};\"` : ''}></span>\n\t\t\t\t\t\t<span class=\"chart__legend__item__name\">${groupName}</span>\n\t\t\t\t\t</li>`;\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t</div>\n\t`;\n}\n\nfunction yAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.y;\n\n\tconst scale = new Scale(chartData, options, 'y');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\t// Render axis based on scale\n\treturn `\n\t<div class=\"chart__y-axis\">\n\t\t${axisOptions?.title ? `\n\t\t<span class=\"chart__y-axis__title\">${axisOptions.title}</span>\n\t\t` : ''}\n\n\t\t<ul class=\"chart__y-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__y-axis__value\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\tif (axisOptions) {\n\t\t// AxisOptions has no required values, so we can only be certain what axis type we're dealing with if labels or values is specified\n\t\tif ('labels' in axisOptions) {\n\t\t\treturn xAxisQualitative(chartData, options);\n\t\t} else if ('values' in axisOptions) {\n\t\t\treturn xAxisQuantitative(chartData, options);\n\t\t}\n\t}\n\n\treturn xAxisMinimal(chartData, options);\n}\n\nfunction xAxisQualitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst { labels } = chartData;\n\n\t// For each label, render that label\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__label-list\">\n\t\t\t${labels.map((label) => `<li class=\"chart__x-axis__label\">${applyFormat(label, axisOptions)}</li>`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisQuantitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst scale = new Scale(chartData, options, 'x');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__x-axis__value\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisMinimal<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t</div>`;\n}\n\nfunction yGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst scale = new Scale(chartData, options, 'y');\n\n\tconst axisOptions = options?.y;\n\tconst { values } = getAxisGridlines(scale, options?.y);\n\n\t// Render gridlines based on scale\n\treturn `\n\t\t<ul class=\"chart__y-gridlines\" role=\"presentation\">\n\t\t\t${values.map((val, index) => {\n\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t// since that line is already drawn by the x axis\n\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t<li class=\"chart__y-gridline\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t'';\n\n\t\t\t\treturn gridlines\n\t\t\t}).join('')}\n\t\t</ul>\n\t`;\n}\n\nfunction xGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\tif (axisOptions && ('values' in axisOptions || 'gridlines' in axisOptions)) {\n\t\tconst scale = new Scale(chartData, options, 'x');\n\t\tconst { values } = getAxisGridlines(scale, axisOptions);\n\n\t\t// Render gridlines based on scale\n\t\treturn `\n\t\t\t<ul class=\"chart__x-gridlines\" role=\"presentation\">\n\t\t\t\t${values.map((val, index) => {\n\t\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t\t// since that line is already drawn by the y axis\n\t\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t\t<li class=\"chart__x-gridline\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t\t'';\n\n\t\t\t\t\treturn gridlines\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t`;\n\t} else {\n\t\treturn '';\n\t}\n}\n\nexport function tooltip<GroupName extends string>(chartData: ChartData<GroupName>, group: number[], label: string, options?: ChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst groupIndex = groups.indexOf(group);\n\tif (groupIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised group`);\n\t}\n\n\tconst groupName = groupNames[groupIndex];\n\n\tconst labelIndex = labels.indexOf(label);\n\tif (labelIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised label`);\n\t}\n\n\tconst value = group[labelIndex];\n\n\tconst str = `\n\t<div class=\"chart__tooltip\">\n\t\t${groups.length > 1 ? groupName : ''} ${label}: ${applyFormat(value, options?.y)}\n\t</div>`;\n\n\treturn str;\n}\n\ninterface AxisValues {\n\tvalues: number[],\n\tdates: boolean,\n}\n\nfunction getAxisValues(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.values !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.values);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tvalues = scale.getSeries(2);\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\nfunction getAxisGridlines(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.gridlines !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.gridlines);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tconst axisValues = getAxisValues(scale, axisOptions);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\n/**\n * Both axis values and axis gridlines are retrieved in the same way, only with different fallbacks.\n * This base function contains that shared functionality, including the necessary conversion from\n * Date to number if the specified values are Dates, while remembering that they were Dates so they\n * can be converted back to Dates further down the line.\n */\nfunction getAxisValuesBase(scale: Scale, axisValues: Exclude<AxisOptionsQuantitative['values'], undefined>): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisValues === 'number') {\n\t\tconst numValues = axisValues + 1;\n\t\tvalues = scale.getSeries(numValues);\n\t} else if (axisValues.length > 0) {\n\t\t// These type assertions are necessary because of how `Array.prototype.every` has been typed\n\t\t// https://stackoverflow.com/questions/71012370/narrowing-a-union-of-array-types-using-array-every\n\t\tif ((axisValues as unknown[]).every((val: unknown): val is number => typeof val === 'number')) {\n\t\t\tvalues = axisValues as number[];\n\t\t} else {\n\t\t\tdates = true;\n\t\t\tvalues = axisValues.map((val) => +val);\n\t\t}\n\t} else {\n\t\tvalues = axisValues as [];\n\t}\n\n\treturn { values, dates };\n}\n\nfunction applyFormat(value: any, axisOptions?: AxisOptionsQuantitative): string {\n\tif (typeof value === 'number') {\n\t\tif (axisOptions?.numberFormat) {\n\t\t\tif (axisOptions.numberFormat instanceof Intl.NumberFormat) {\n\t\t\t\treturn axisOptions.numberFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.numberFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else if (value instanceof Date) {\n\t\tif (axisOptions?.dateFormat) {\n\t\t\tif (axisOptions.dateFormat instanceof Intl.DateTimeFormat) {\n\t\t\t\treturn axisOptions.dateFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.dateFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else {\n\t\treturn '' + value;\n\t}\n}\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { BarChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderBars<GroupName extends string>(chartData: ChartData<GroupName>, options?: BarChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scale = new Scale(chartData, options, 'y');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<ul class=\"chart__bar-groups\">\n\t\t\t${labels.map((label, index) =>\n\t\t\t`<li class=\"chart__bar-group\">\n\t\t\t\t<ul class=\"chart__bar-group-bars${options?.stacked ? ` chart__bar-group-bars--stacked` : ''}\">\n\t\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\t\tconst colour = colours && colours[groupName];\n\t\t\t\t\t\tconst value = group[index];\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li\n\t\t\t\t\t\t\t\tclass=\"chart__bar\"\n\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t` style=\"flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t}%;\"` :\n\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclass=\"chart__bar__area\"\n\t\t\t\t\t\t\t\tstyle=\"\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\tcolour ?\n\t\t\t\t\t\t\t\t\t\t\t`background: ${colour}; ` :\n\t\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t\t'' :\n\t\t\t\t\t\t\t\t\t\t\t`flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t\t}%;`\n\t\t\t\t\t\t\t\t\t}\" data-value=\"${value}\"\n\t\t\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>`\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t</li>`).join('')}\n\t\t</ul>\n\t`;\n}\n\nexport function bar<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: BarChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst bars = renderBars(chartData, options);\n\n\tconst chart = renderChart(chartData, bars, options);\n\n\treturn chart;\n};\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { LineChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderLines<GroupName extends string>(chartData: ChartData<GroupName>, options?: LineChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scaleY = new Scale(chartData, options, 'y');\n\tconst scaleX = new Scale(chartData, options, 'x');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<svg class=\"chart__lines\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\">\n\t\t\t<g transform=\"translate(0, 100) scale(1, -1)\">\n\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\t\t\tconst points = labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\t\t\t\t\t\tconst str = `${leftPercent},${percentage}`;\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join(' ');\n\n\t\t\t\t\tconst str = `\n\t\t\t\t\t\t<polyline class=\"chart__line\" points=\"${points}\"${colour ? ` style=\"stroke: ${colour};\"` : ''}></polyline>\n\t\t\t\t\t`;\n\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</g>\n\t\t</svg>\n\n\t\t${groups.map((group, groupIndex) => {\n\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\tconst str = `\n\t\t\t\t<ul class=\"chart__line__points\">\n\t\t\t\t\t${labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li class=\"chart__line__point\" style=\"left: ${leftPercent}%; bottom: ${percentage}%\" tabindex=\"0\">\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t`;\n\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t`;\n\n\t\t\treturn str;\n\t\t}).join('')}\n\t`;\n}\n\nexport function line<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: LineChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst lines = renderLines(chartData, options);\n\n\tconst chart = renderChart(chartData, lines, options);\n\n\treturn chart;\n};\n","import * as codebook from '@cipscis/codebook';\n\nimport * as csv from '@cipscis/csv';\nimport * as analyser from '@cipscis/analyser';\n\nconst selectors = Object.freeze({\n\texample: '.js-docs__example',\n\trun: '.js-docs__run',\n\tlog: '.js-docs__log',\n\n\tcodebookSet: '.js-codebook__set',\n} as const);\n\nconst dataAttributes = Object.freeze({\n\tcodebookSet: 'data-codebook-set',\n} as const);\n\nconst classes = Object.freeze({\n\terror: 'docs-example__control--error',\n} as const);\n\nfunction init() {\n\t_initEvents();\n\n\t_runInitialSets();\n}\n\nfunction _initEvents() {\n\tconst $runSetButtons = document.querySelectorAll<HTMLElement>(selectors.run);\n\n\t$runSetButtons.forEach(($runSetButton) => {\n\t\t$runSetButton.addEventListener('click', _runSetEvent);\n\t});\n}\n\nfunction _runInitialSets() {\n\tcodebook.tidy();\n\n\tcodebook.runSet('example-data', { csv });\n}\n\nfunction _runSetEvent(this: HTMLElement, e: MouseEvent) {\n\tconst $runSetButton = this;\n\tconst $set = $runSetButton.closest(selectors.codebookSet);\n\tconst setName = $set?.getAttribute(dataAttributes.codebookSet);\n\n\t$runSetButton.setAttribute('aria-busy', 'true');\n\n\tconst args = { csv, analyser };\n\tconst promise = setName ? codebook.runSet(setName, args) : codebook.runSet(args);\n\n\tpromise\n\t\t.then(() => {\n\t\t\t$runSetButton.classList.remove(classes.error);\n\t\t})\n\t\t.catch((reason) => {\n\t\t\t$runSetButton.classList.add(classes.error);\n\t\t\tconst $example = $runSetButton.closest(selectors.example);\n\t\t\tconst $log = $example?.querySelector(selectors.log);\n\n\t\t\tif ($log) {\n\t\t\t\t$log.innerHTML = reason.toString();\n\t\t\t} else {\n\t\t\t\tconsole.error(reason);\n\t\t\t}\n\t\t})\n\t\t.finally(() => {\n\t\t\t$runSetButton.setAttribute('aria-busy', 'false');\n\t\t});\n}\n\ninit();\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","selectors","freeze","block","set","inert","dataAttributes","index","log","html","defaultSetName","$textarea","document","createElement","async","runSet","setNameOrArgs","argsParam","setName","args","sets","$blocks","querySelectorAll","setNames","$block","_getSetName","includes","push","_createNewSet","blocks","_gatherSetBlocks","_sortCodeBlocks","_createCodeSets","code","reduce","_combineCode","logId","getAttribute","$log","getElementById","innerHTML","_clearLogs","argNames","argValues","keys","values","_spreadArgs","Error","Function","apply","concat","_logOutput","_htmlOutput","fn","_runSet","RangeError","sort","$blockA","$blockB","iA","iB","assign","allCode","$newCode","newCode","htmlString","textContent","htmlId","$parent","closest","output","forEach","outputEl","outputString","Date","padZeroes","num","minLength","numStr","toString","length","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","JSON","stringify","$html","data","options","transpose","sanitise","rows","rowStrings","i","join","_join","row","j","_escapeCell","_escape","maxLength","Math","max","iMax","jMax","iRow","iCol","cellValue","_shape","cell","cellString","match","replace","parse","csvString","mapper","stringRows","tokens","inQuote","wasQuote","tokenStart","char","comma","quote","newline","eof","SyntaxError","token","substring","_tokenise","rowLength","_validate","map","fileConfig","AnalyserRows","Array","constructor","source","isArray","super","this","getCol","colNum","TypeError","col","addCol","creator","colIndex","entries","getColNumber","colName","Number","isInteger","alphabet","rowNumber","upperColName","toUpperCase","charIndex","indexOf","pow","getColNumbers","colsConfig","newCols","colNumber","defaultSummarisers","Count","AnalyserGroup","Map","discrete","summarise","summarisersArg","summarisers","summaryHeaderRow","summaryValueRows","groupName","summaryRow","summariser","rowSummary","summaryValuesSorted","a","b","createFilterFn","aliases","_extendFilterFn","arr","_applyFilter","filterResolver","extendedFilterResolver","andBy","orBy","cellValues","_matchAlias","aliasList","cleanNumberLike","appearsNumber","cleanValue","parseFloat","array","separator","limit","split","booleanCustom","truthy","falsey","locationIdentifier","cleanedValue","trim","toLowerCase","test","console","warn","number","appearsPercentage","numValue","precision","toFixed","appearsTrue","appearsFalse","appearsBoolean","enumValue","enums","recodeMap","enumValues","val","loadFile","response","fetch","path","ok","headerRows","splice","footerRows","by","group","splitting","right","Set","add","isNonCanonical","isCanonical","has","delete","matchingRows","filter","setLimits","enumArr","every","x","min","setSize","setMin","setMax","splitValues","Infinity","filterFn","createGroupFn","dataConfig","cols","addedCols","transform","transformFn","_processData","text","status","getNumArray","sum","mean","numbers","getChartData","summary","groupNames","valueRows","labels","label","emptyData","fill","rowA","rowB","labelA","indexA","labelB","valueGroups","numberValueGroups","numberValueGroupNames","chartData","groups","stacked","Scale","chartOptions","type","numberLabels","isNaN","getMinMaxFromChartDataLabels","allValues","el","getMinMaxFromChartData","getMinMaxFromScaleOptions","axisOptions","allowAuto","gridlines","maxPower","floor","log10","abs","widthRoundTo","ceil","valuePower","valueRoundTo","round","iterations","getMinMaxFromAxisOptions","getMinMax","getProportion","width","getValue","proportion","getSeries","stepSize","series","contents","title","legend","colour","colours","scale","y","getAxisGridlines","yGridlines","xGridlines","dates","getAxisValues","applyFormat","yAxis","xAxisQualitative","xAxisQuantitative","xAxisMinimal","xAxis","tooltip","groupIndex","labelIndex","axisValues","getAxisValuesBase","numValues","numberFormat","Intl","NumberFormat","format","dateFormat","DateTimeFormat","bar","renderBars","line","scaleY","scaleX","leftPercent","renderLines","example","run","codebookSet","classes","error","_runSetEvent","e","$runSetButton","setAttribute","csv","analyser","then","classList","remove","catch","reason","querySelector","finally","addEventListener","level","pattern","RegExp"],"sourceRoot":""}