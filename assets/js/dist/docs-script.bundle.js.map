{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/analyser/./dist/statistics.js","webpack://@cipscis/analyser/./src/AnalyserRows.ts","webpack://@cipscis/analyser/./src/helpers.ts","webpack://@cipscis/analyser/./src/AnalyserGroup.ts","webpack://@cipscis/analyser/./src/filtering.ts","webpack://@cipscis/analyser/./src/transformers.ts","webpack://@cipscis/analyser/./src/file-processing.ts","webpack://@cipscis/analyser/./src/grouping.ts","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/parse.js","webpack://@cipscis/analyser/./src/charts/ChartData.ts","webpack://@cipscis/analyser/./src/charts/Scale.ts","webpack://@cipscis/analyser/./src/charts/chart.ts","webpack://@cipscis/analyser/./docs/assets/js/src/docs-script.ts","webpack://@cipscis/analyser/./src/charts/bar.ts","webpack://@cipscis/analyser/./src/charts/line.ts"],"sourcesContent":["function getNumArray(val) {\n    if (((value) => {\n        return value.length === 1 && Array.isArray(value[0]);\n    })(val)) {\n        return val[0];\n    }\n    else {\n        return val;\n    }\n}\n/**\n * Return the sum of an array of numbers.\n */\nexport function sum(...arr) {\n    const numbers = getNumArray(arr);\n    return numbers.reduce(function (sum, val) {\n        return sum + val;\n    }, 0);\n}\n/**\n * Returns the mean of an array of numbers.\n */\nexport function mean(...arr) {\n    const numbers = getNumArray(arr);\n    return sum(numbers) / numbers.length;\n}\n//# sourceMappingURL=statistics.js.map","interface AnalyserRows {\n\tfilter(...args: Parameters<typeof Array.prototype.filter>): this;\n}\n\nclass AnalyserRows extends Array<unknown[]> {\n\tconstructor(source?: unknown[][] | number) {\n\t\tif (Array.isArray(source)) {\n\t\t\tsuper(source.length);\n\t\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\t\tthis[i] = source[i];\n\t\t\t}\n\t\t} else if (typeof source === 'number') {\n\t\t\tsuper(source);\n\t\t} else {\n\t\t\tsuper();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the specified column.\n\t */\n\tgetCol(colNum: number): unknown[] {\n\t\tif (typeof colNum !== 'number') {\n\t\t\tthrow new TypeError(`colNum must be a number.`);\n\t\t} else if (colNum < 0 || colNum >= this[0]?.length) {\n\t\t\tthrow new RangeError(`colNum out of range.`);\n\t\t}\n\n\t\tconst col: unknown[] = [];\n\t\tfor (let row of this) {\n\t\t\tcol.push(row[colNum]);\n\t\t}\n\n\t\treturn col;\n\t}\n\n\t/**\n\t * Adds a new column to AnalyserRows, and returns its index.\n\t */\n\taddCol<T>(creator: (row: any[], index: number) => T): number\n\taddCol<T>(creator: T[]): number\n\taddCol<T>(creator: ((row: any[], index: number) => T) | T[]): number {\n\t\tconst colIndex = this[0].length;\n\n\t\tif (Array.isArray(creator)) {\n\t\t\tif (this.length !== creator.length) {\n\t\t\t\tthrow new Error(`New column of length ${creator.length} cannot be added. It must be of length ${this.length}.`);\n\t\t\t}\n\n\t\t\tfor (let [i, row] of this.entries()) {\n\t\t\t\trow.push(creator[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let [i, row] of this.entries()) {\n\t\t\t\trow.push(creator(row, i));\n\t\t\t}\n\t\t}\n\n\t\treturn colIndex;\n\t}\n}\n\nexport { AnalyserRows };\n","/**\n * Convert a column heading from spreadsheet software to its integer representation. For example, converts 'A' to 0, or 'ZE' to 680.\n *\n * If a non-negative integer is passed, it will be returned untransformed. Any other value, including an invalid string, will return null.\n */\nfunction getColNumber<T extends number>(colName: T): T | null\nfunction getColNumber<T extends string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null {\n\tif (typeof colName === 'number') {\n\t\tif (Number.isInteger(colName) && colName >= 0) {\n\t\t\treturn colName;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t} else if (colName === '') {\n\t\treturn null;\n\t} else if (typeof colName !== 'string') {\n\t\treturn null;\n\t}\n\n\tconst alphabet: readonly string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\tlet rowNumber = -1; // Adjust for 0-based counting\n\n\tconst upperColName = colName.toUpperCase();\n\tfor (let i = 0; i < upperColName.length; i++) {\n\t\tconst char = upperColName[i];\n\t\tconst charIndex = alphabet.indexOf(char);\n\n\t\tif (charIndex === -1) {\n\t\t\t// colName contains an invalid character\n\t\t\treturn null;\n\t\t}\n\n\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\n\t}\n\n\treturn rowNumber;\n}\n\n/**\n * Converts a map of column names to column identifiers using getColNumbers so all column identifiers are integers.\n *\n * Any columns with invalid identifiers will be removed from the result.\n */\nfunction getColNumbers<T extends string>(colsConfig: Record<T, number | string>): Record<T, number> {\n\tconst newCols: Partial<Record<T, number>> = {};\n\n\tfor (let key in colsConfig) {\n\t\tconst value = colsConfig[key];\n\t\tconst colNumber = getColNumber(value);\n\n\t\tif (typeof colNumber === 'number') {\n\t\t\tnewCols[key] = colNumber;\n\t\t}\n\t}\n\n\treturn newCols as Record<T, number>;\n}\n\nexport {\n\tgetColNumber,\n\tgetColNumbers,\n};\n","import { AnalyserRows } from './AnalyserRows.js';\n\n/**\n * A function for summarising a set of AnalyserRows\n */\ntype AnalyserSummariser<T = any, G = any> = (rows: AnalyserRows, groupName: G) => T;\n\n/**\n * A group of AnalyserSummariser functions\n */\ntype AnalyserSummarisers<SummaryName extends string> = Record<SummaryName, AnalyserSummariser>;\n\nconst defaultSummarisers = {\n\tCount: (rows: AnalyserRows) => rows.length\n} as const;\ntype DefaultSummaryName = keyof typeof defaultSummarisers;\n\n/**\n * A 2D array of the results of AnalyserSummariser functions applied to an AnalyserGroup of AnalyserRows,\n * able to be printed to the console using `console.table`.\n *\n * After the first header row, each row represents a set of AnalyserRows grouped by the value given in the first cell.\n * After the first column, each column represents a summary of a group of AnalyserRows. The name of the summary is given in the first cell.\n */\nexport type AnalyserSummary<SummaryName extends string> = [[unknown, ...SummaryName[]], ...[any, ...any[]][]];\n\ninterface AnalyserGroupOptions {\n\tdiscrete?: boolean,\n}\n\nexport class AnalyserGroup extends Map<any, AnalyserRows> {\n\t#discrete: boolean\n\n\tconstructor(options?: AnalyserGroupOptions) {\n\t\tsuper();\n\n\t\tif (typeof options?.discrete === 'boolean') {\n\t\t\tthis.#discrete = options.discrete;\n\t\t} else {\n\t\t\tthis.#discrete = true;\n\t\t}\n\t}\n\n\t/**\n\t * Create a 2D summary array that can be printed using console.table.\n\t */\n\tsummarise(): AnalyserSummary<DefaultSummaryName>\n\tsummarise<SummaryName extends string>(summarisers: AnalyserSummarisers<SummaryName>): AnalyserSummary<SummaryName>\n\tsummarise<SummaryName extends string>(summarisersArg?: AnalyserSummarisers<SummaryName>): AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName> {\n\t\t// If there was no argument, use a default value instead. This will affect the return type, as per the overloads\n\t\tconst summarisers = summarisersArg ?? defaultSummarisers;\n\n\t\tconst summaryNames = Object.keys(summarisers) as (DefaultSummaryName)[] | SummaryName[];\n\t\tconst summaryHeaderRow = ['Value', ...summaryNames] as const;\n\n\t\tlet summaryValueRows: [any, ...any[]][] = [];\n\t\tfor (let [groupName, rows] of this.entries()) {\n\t\t\tconst summaryRow: [any, ...any[]] = [groupName];\n\n\t\t\tfor (let [, summariser] of Object.entries<AnalyserSummariser>(summarisers)) {\n\t\t\t\tconst rowSummary = summariser(rows, groupName);\n\t\t\t\tsummaryRow.push(rowSummary);\n\t\t\t}\n\n\t\t\tsummaryValueRows.push(summaryRow);\n\t\t}\n\n\t\tif (this.#discrete) {\n\t\t\t// Sort summary based on its values\n\n\t\t\t// Use basic Array.prototype.sort to sort numbers or strings, to use as a reference when sorting the summary\n\t\t\tconst summaryValues = summaryValueRows.map((summaryRow) => summaryRow[0]);\n\t\t\tconst summaryValuesSorted = summaryValues.sort();\n\n\t\t\t// Sort summary value rows using the sorted values as a reference\n\t\t\tsummaryValueRows = summaryValueRows.sort((a, b) => summaryValuesSorted.indexOf(a[0]) - summaryValuesSorted.indexOf(b[0]));\n\t\t}\n\n\t\tconst summary = [summaryHeaderRow, ...summaryValueRows];\n\n\t\t// Let the overloads tell TypeScript which type the summary actually is.\n\t\t// If there was no `summarisersArg` argument, it will be AnalyserSummary<DefaultSummaryNames>,\n\t\t// otherwise the type T could be inferred so no default was necessary and it will be AnalyserSummary<SummaryName>\n\t\treturn summary as AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName>;\n\t}\n}\n","import { AnalyserRows } from './AnalyserRows.js';\n\ntype FilterInput = ((value: any) => boolean) | any[] | Exclude<any, []>\n\n/**\n * A function used by Array.prototype.filter\n */\ninterface FilterResolver {\n\t(val: any, index: number, arr: any[]): boolean,\n}\n\n/**\n * A FilterResolver that can be extended using FilterResolverExtender methods\n */\ninterface ExtensibleFilterResolver extends FilterResolver {\n\tandBy: FilterResolverExtender,\n\torBy: FilterResolverExtender,\n}\n\n/**\n * A function that either creates a new FilterResolver or extends and existing one, embedding information about the column to look at and the values to match.\n */\ninterface FilterResolverExtender {\n\t(colIndex: number, values: FilterInput): ExtensibleFilterResolver,\n}\n\n/**\n * Creates a function that remembers a set of aliases, and can be called\n * to create a function that can be used with Array.prototype.filter to\n * use that alias when filtering a set of data using _applyFilter.\n */\nfunction createFilterFn(aliases?: string[][]): FilterResolverExtender {\n\tconst by = function (colIndex: number, values: FilterInput) {\n\t\tconst applyFilterToRow: FilterResolver = function (row, index, arr) {\n\t\t\treturn _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst extendedApplyFilterToRow = _extendFilterFn(applyFilterToRow, aliases);\n\n\t\treturn extendedApplyFilterToRow;\n\t};\n\n\treturn by;\n}\n\n/**\n * Extend a FilterResolver into an ExtensibleFilterResolver, including embedding an optional set of aliases.\n */\nfunction _extendFilterFn(filterResolver: FilterResolver, aliases?: string[][]): ExtensibleFilterResolver {\n\tconst extendedFilterResolver = filterResolver as ExtensibleFilterResolver;\n\n\textendedFilterResolver.andBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) && _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\textendedFilterResolver.orBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) || _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\treturn extendedFilterResolver;\n}\n\n/**\n * Applies a filter to a specific row, looking at a specified column index\n * and checking its value against either a specific value, a set of values,\n * or a function.\n *\n * If the value or values being checked against are strings, a set of\n * aliases can be used as well.\n */\nfunction _applyFilter(row: any[], colIndex: number, values: FilterInput, aliases?: string[][]): boolean {\n\tif (typeof values === 'function') {\n\t\treturn values(row[colIndex]);\n\t}\n\n\tif (!Array.isArray(values)) {\n\t\tvalues = [values];\n\t}\n\n\tconst cell = row[colIndex];\n\tlet cellValues;\n\n\tif (Array.isArray(cell)) {\n\t\tcellValues = cell;\n\t} else {\n\t\tcellValues = [cell];\n\t}\n\n\tfor (let cellValue of cellValues) {\n\t\tfor (let value of values) {\n\t\t\tif (_matchAlias(value, cellValue, aliases)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Checks if the value of a cell matches the value passed,\n * optionally taking one or more sets of aliases to match.\n */\nfunction _matchAlias(cell: any, value: any, aliases?: string[][]): boolean {\n\tif (cell === value) {\n\t\treturn true;\n\t}\n\n\tif (aliases && typeof cell === 'string' && typeof value === 'string') {\n\t\tfor (let aliasList of aliases) {\n\t\t\tif (aliasList.includes(cell) && aliasList.includes(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport {\n\tcreateFilterFn,\n\n\tFilterResolverExtender,\n\tExtensibleFilterResolver,\n};\n","//////////////////////////\n// Appearance functions //\n//////////////////////////\n\nexport interface TransformerFn<T> {\n\t(value: string, locationIdentifier?: string): T extends any[] ? T : (T | null)\n}\n\n/**\n * Checks if a string appears like it represents true\n */\nfunction appearsTrue(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'true';\n}\n\n/**\n * Checks if a string appears like it represents false\n */\nfunction appearsFalse(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'false';\n}\n\n/**\n * Checks if a string appears like it represents a boolean vaue\n */\nfunction appearsBoolean(value: string): boolean {\n\treturn appearsTrue(value) || appearsFalse(value);\n}\n\ntype NoCommas<T extends string> = T extends `${infer U},${infer V}` ? NoCommas<`${U}${V}`> : T;\ntype NoPercent<T extends string> = T extends `${infer W}%` ? W : T;\ntype CleanNumberLike<T extends string> = NoCommas<NoPercent<T>>;\n\n/**\n * Removes any ',' characters, and any '%' at the end of\n * a string that may appear like it represents a number\n */\nfunction cleanNumberLike<T extends string>(value: T): CleanNumberLike<T> {\n\tconst cleanValue = value.replace(/,|%$/g, '') as CleanNumberLike<T>;\n\treturn cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a number\n */\nfunction appearsNumber(value: string): boolean {\n\tconst cleanValue = cleanNumberLike(value);\n\n\treturn parseFloat(cleanValue) === +cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a percentage\n */\nfunction appearsPercentage(value: string): boolean {\n\treturn appearsNumber(value) && !!value.match(/%$/);\n}\n\n///////////////////////////\n// Transformer functions //\n///////////////////////////\n\n/**\n * Splits a string into an array using String.prototype.split\n */\nexport function array(separator: string | RegExp, limit?: number): TransformerFn<string[]> {\n\treturn function (value: string): string[] {\n\t\treturn value.split(separator, limit);\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation using a custom definition.\n *\n *  If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport function booleanCustom(truthy: string | RegExp = 'true', falsey: string | RegExp = 'false'): TransformerFn<boolean> {\n\treturn function (value: string, locationIdentifier?: string): boolean | null {\n\t\tconst cleanedValue = value.trim().toLowerCase();\n\n\t\tif (typeof truthy === 'string') {\n\t\t\tif (cleanedValue === truthy.trim().toLowerCase()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (truthy.test(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof falsey === 'string') {\n\t\t\tif (cleanedValue === falsey.trim().toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (falsey.test(value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (value) {\n\t\t\tconsole.warn(`Boolean value not found in '${value}', checking for ${truthy} or ${falsey} (${locationIdentifier})`);\n\t\t}\n\t\treturn null;\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation, if it contains one.\n *\n * If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport const boolean = booleanCustom();\n\n/**\n * Extracts a number from a string representation, if it contains one.\n * Strings ending with '%' are treated as percentages and divided by 100.\n *\n * If the value doesn't appear like it represents a number, a warning will be generated.\n */\nexport const number: TransformerFn<number> = (value: string, locationIdentifier?: string): number | null => {\n\tif (appearsNumber(value)) {\n\t\t// Condition matches if the entire string represents a number\n\n\t\tlet cleanValue: string = cleanNumberLike(value);\n\n\t\tif (appearsPercentage(value)) {\n\t\t\t// If value is a percentage string, divide by 100\n\t\t\tconst numValue = +cleanValue / 100;\n\n\t\t\t// To prevent division causing rounding errors, like\n\t\t\t// 0.10800000000000001, use string representation to\n\t\t\t// determine how to round the number.\n\n\t\t\t// Remove everything up to (and including) a radix point\n\t\t\t// e.g. convert '82.643' to '643'\n\t\t\tconst truncatedValue = cleanValue.replace(/^[^.]+\\.?/, '');\n\n\t\t\tconst precision = truncatedValue.length;\n\n\t\t\t// Add 2 to precision to compensate for dividing by 100\n\t\t\tcleanValue = numValue.toFixed(precision + 2);\n\t\t}\n\n\t\treturn +cleanValue;\n\t} else {\n\t\tif (value) {\n\t\t\tconsole.warn(`Number value not found in '${value}' (${locationIdentifier})`);\n\t\t}\n\t\treturn null;\n\t}\n}\n\n/**\n * Extracts boolean or number values from string representations if appropriate.\n *\n * No warnings will be generated if the value doesn't appear like a boolean or number.\n */\nexport const value: TransformerFn<boolean | number> = (value: string, locationIdentifier?: string): boolean | number | null => {\n\tif (appearsBoolean(value)) {\n\t\treturn boolean(value);\n\t} else if (appearsNumber(value)) {\n\t\treturn number(value);\n\t} else {\n\t\tconsole.warn(`Boolean or number value not found in '${value}' (${locationIdentifier})`);\n\t\treturn null;\n\t}\n}\n\n/**\n * Checks that the value, if it exists, is a member of an enum.\n *\n * If the value does not exist, it is transformed to null.\n *\n * If a recoding map is passed, and it contains instructions for this value, it is recoded first.\n *\n * If the value exists but it is not a member of the enum and cannot be recoded,\n * a warning will be generated and null will be returned.\n */\nexport function enumValue<E extends string>(enums: Record<string, E>, recodeMap?: Record<string, E>): TransformerFn<E> {\n\tconst enumValues: E[] = Object.values(enums);\n\n\tfunction isEnumMember(val: unknown): val is E {\n\t\t// Use `as any[]` so TypeScript doesn't complain when using Array.prototype.includes\n\t\treturn (enumValues as any[]).includes(val);\n\t}\n\n\tconst transformer = ((value: string, locationIdentifier?: string) => {\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isEnumMember(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (recodeMap && value in recodeMap) {\n\t\t\tconst recodedValue = recodeMap[value];\n\t\t\treturn recodedValue;\n\t\t}\n\n\t\tconsole.warn(`Value '${value}' does not exist within ${enumValues.join(', ')} (${locationIdentifier})`);\n\t\treturn null;\n\t}) as TransformerFn<E>;\n\t// Need to use a type assertion here as TypeScript doesn't know how to use the generic constraint to resolve the conditional type\n\t// See https://stackoverflow.com/questions/70553130/typescript-generic-conditional-type-as-return-value-for-generic-function/70553240#70553240\n\n\treturn transformer;\n}\n","import { parse as parseCSV } from '@cipscis/csv';\n\nimport { AnalyserRows } from './AnalyserRows.js';\nimport { FileConfig } from './FileConfig.js';\nimport { DataConfig } from './DataConfig.js';\n\nimport { getColNumbers } from './helpers.js';\n\nimport { createGroupFn } from './grouping.js';\nimport { createFilterFn } from './filtering.js';\n\nimport * as transformers from './transformers.js';\n\n/**\n * Load a single CSV file and process its contents, then return them.\n */\nasync function loadFile<T extends string>(fileConfig: FileConfig<T>): Promise<DataConfig<T>> {\n\tconst response = await fetch(fileConfig.path);\n\n\tif (response.ok) {\n\t\tconst data = await response.text();\n\n\t\tconst rows = parseCSV(data);\n\t\tconst dataConfig = _processData(rows, fileConfig);\n\t\treturn dataConfig;\n\t} else {\n\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\n\t}\n}\n\n/**\n * Processes CSV data into a DataConfig object ready for analysis via code.\n */\nfunction _processData<T extends string>(rows: string[][], fileConfig: FileConfig<T>): DataConfig<T> {\n\t// Remove header rows\n\tif (fileConfig.headerRows) {\n\t\trows.splice(0, fileConfig.headerRows);\n\t}\n\n\t// Remove footer rows\n\tif (fileConfig.footerRows) {\n\t\trows.splice(-fileConfig.footerRows);\n\t}\n\n\tconst by = createFilterFn(fileConfig.aliases);\n\tconst group = createGroupFn(by, fileConfig.aliases);\n\n\tconst dataConfig: DataConfig<T> = {\n\t\trows: new AnalyserRows(rows),\n\t\traw: rows,\n\t\tcols: getColNumbers(fileConfig.cols),\n\t\taddedCols: {},\n\t\tby,\n\t\tgroup,\n\t};\n\n\tif (fileConfig.aliases) {\n\t\tdataConfig.aliases = fileConfig.aliases;\n\t}\n\n\tif (fileConfig.transform) {\n\t\tfor (let colName in fileConfig.transform) {\n\t\t\tif (!(colName in dataConfig.cols)) {\n\t\t\t\tconsole.warn(`Column '${colName}' specified in transform not found in cols.`);\n\t\t\t} else {\n\t\t\t\tconst colNum = dataConfig.cols[colName];\n\t\t\t\tconst transformFn = fileConfig.transform[colName];\n\n\t\t\t\t// Some of these conditions are ignored because they're intended to help when TypeScript isn't being used\n\t\t\t\tif (transformFn === transformers.array) {\n\t\t\t\t\tthrow new Error(`The 'array' transformer cannot be used directly. Please pass a 'separator' argument.`);\n\t\t\t\t} else if (transformFn === transformers.booleanCustom) {\n\t\t\t\t\tthrow new Error(`The 'booleanCustom' transformer cannot be used directly. Please invoke it to create a transformer function.`);\n\t\t\t\t// @ts-ignore\n\t\t\t\t} else if (transformFn === transformers.enumValue) {\n\t\t\t\t\tthrow new Error(`The 'enumValue' transformer cannot be used directly. Please pass an 'enums' argument.`);\n\t\t\t\t}\n\n\t\t\t\tfor (let row of rows) {\n\t\t\t\t\tif (transformFn) {\n\t\t\t\t\t\tconst locationIdentifier = `column ${colName}, row ${rows.indexOf(row)}`;\n\t\t\t\t\t\trow[colNum] = transformFn(row[colNum], locationIdentifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dataConfig;\n}\n\nexport { loadFile };\n","import { AnalyserRows } from './AnalyserRows.js';\nimport { FilterResolverExtender, ExtensibleFilterResolver } from './filtering.js';\n\nimport { AnalyserGroup } from './AnalyserGroup.js';\n\ninterface Grouper {\n\t(rows: AnalyserRows, colNum: number): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, numGroups: number, right?: boolean): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, splitPoints: number[], right?: boolean): AnalyserGroup\n}\n\n/**\n * Creates a function that uses a FilterResolverExtender with an embedded\n * set of aliases, to create a summarisable group of AnalyserRows split\n * based on the specified column.\n */\nfunction createGroupFn (by: FilterResolverExtender, aliases?: string[][]): Grouper {\n\tconst grouperFn: Grouper = function (rows: AnalyserRows, colNum: number, splitting?: number | number[], right: boolean = true): AnalyserGroup {\n\t\t// Ignore aliases for now, and don't worry about splitting\n\n\t\t// First, collect enums\n\t\tconst enums: Set<unknown> = new Set();\n\t\tfor (let row of rows) {\n\t\t\tconst cellValue = row[colNum];\n\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\tfor (let value of cellValue) {\n\t\t\t\t\tenums.add(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenums.add(cellValue);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof splitting === 'undefined') {\n\t\t\t// Treat data as discrete\n\n\t\t\tif (aliases) {\n\t\t\t\tfor (let val of enums) {\n\t\t\t\t\tif (typeof val === 'string') {\n\t\t\t\t\t\t// If the value is a string in one or more alias sets,\n\t\t\t\t\t\t// ensure those sets will be used for grouping and\n\t\t\t\t\t\t// ensure only canonical values will be checked directly.\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and is **not** the canonical value */\n\t\t\t\t\t\tlet isNonCanonical = false;\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and **is** the canonical value */\n\t\t\t\t\t\tlet isCanonical = false;\n\n\t\t\t\t\t\tfor (let aliasList of aliases) {\n\t\t\t\t\t\t\tif (aliasList.includes(val)) {\n\t\t\t\t\t\t\t\tif (aliasList[0] === val) {\n\t\t\t\t\t\t\t\t\tisCanonical = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tisNonCanonical = true;\n\n\t\t\t\t\t\t\t\t\t// Remember the canonical value\n\t\t\t\t\t\t\t\t\tif (enums.has(aliasList[0]) === false) {\n\t\t\t\t\t\t\t\t\t\tenums.add(aliasList[0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the value is one one or more alias sets, but is never the canonical value,\n\t\t\t\t\t\t// then remove it from the set of enums to use for grouping.\n\t\t\t\t\t\tif (isCanonical === false && isNonCanonical === true) {\n\t\t\t\t\t\t\tenums.delete(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Then, interate through each enum and filter rows into groups\n\t\t\tconst group = new AnalyserGroup();\n\t\t\tfor (let val of enums) {\n\t\t\t\tconst matchingRows = rows.filter(by(colNum, val));\n\t\t\t\tgroup.set(val, matchingRows);\n\t\t\t}\n\t\t\treturn group;\n\t\t} else {\n\t\t\t// Treat data as continuous\n\n\t\t\t// Create the limits for each set\n\t\t\tconst setLimits: [number, number][] = [];\n\t\t\tif (typeof splitting === 'number') {\n\t\t\t\t// Create splitting number of groups based on values retrieved\n\n\t\t\t\tif (Number.isInteger(splitting) === false || splitting < 2) {\n\t\t\t\t\tthrow new RangeError(`The 'numGroups' argument must be an integer greater than 1.`);\n\t\t\t\t}\n\n\t\t\t\t// Sets are unordered, so create and sort an array (ascending)\n\t\t\t\tconst enumArr = new Array(...enums);\n\n\t\t\t\tif (enumArr.every((x: any): x is number => typeof x === 'number')) {\n\t\t\t\t\tconst values = enumArr.sort((a, b) => a - b);\n\n\t\t\t\t\tconst [min, max] = [values[0], values[values.length-1]];\n\n\t\t\t\t\tconst setSize = (max - min) / splitting;\n\t\t\t\t\tfor (let i = 0; i < splitting; i++) {\n\t\t\t\t\t\tconst setMin = min + i * setSize;\n\t\t\t\t\t\tconst setMax = min + (i+1) * setSize;\n\n\t\t\t\t\t\tsetLimits.push([setMin, setMax]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError(`Cannot split values based on a number unless each of those values is a number.`);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(splitting)) {\n\t\t\t\tif (splitting.length === 0) {\n\t\t\t\t\tthrow new RangeError(`At least one number is required for the 'splitPoints' argument.`);\n\t\t\t\t} else if (splitting.every((val) => typeof val === 'number') === false) {\n\t\t\t\t\tthrow new TypeError(`All 'splitPoints' must be numbers.`);\n\t\t\t\t}\n\n\t\t\t\t// Ensure splitting values are ordered (ascending)\n\t\t\t\tconst splitValues = splitting.concat().sort((a, b) => a - b);\n\n\t\t\t\t// Outer bounds will be -Infinity and Infinity\n\t\t\t\tsetLimits.push([-Infinity, splitValues[0]]);\n\n\t\t\t\tfor (let i = 0; i < splitValues.length-1; i++) {\n\t\t\t\t\tsetLimits.push([splitValues[i], splitValues[i+1]]);\n\t\t\t\t}\n\n\t\t\t\tsetLimits.push([splitValues[splitValues.length-1], Infinity]);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError(`Invalid argument type: ${typeof splitting}`);\n\t\t\t}\n\n\t\t\t// Group rows based on set limits\n\t\t\tconst group = new AnalyserGroup({ discrete: false });\n\t\t\tfor (let row of rows) {\n\t\t\t\tfor (let set of setLimits) {\n\t\t\t\t\tlet setName = '';\n\t\t\t\t\tlet filterFn: ExtensibleFilterResolver;\n\n\t\t\t\t\tif (right) {\n\t\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\t\tsetName += `${set[0]} < `;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetName += `x`;\n\t\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\t\tsetName += ` <= ${set[1]}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] < val && val <= set[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\t\tsetName += `${set[0]} <= `;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetName += `x`;\n\t\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\t\tsetName += ` < ${set[1]}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] <= val && val < set[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst matchingRows = rows.filter(filterFn);\n\n\t\t\t\t\tgroup.set(setName, matchingRows);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\t};\n\n\treturn grouperFn;\n}\n\nexport {\n\tcreateGroupFn,\n\n\tGrouper,\n};","function parse(csvString, mapper) {\r\n    const stringRows = _tokenise(csvString);\r\n    _validate(stringRows);\r\n    if (typeof mapper !== 'undefined') {\r\n        const dataRows = stringRows.map((row) => row.map(mapper));\r\n        return dataRows;\r\n    }\r\n    else {\r\n        return stringRows;\r\n    }\r\n}\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString) {\r\n    // Walk through each character and produce an array of tokens\r\n    const tokens = [];\r\n    // Remove carriage returns\r\n    csvString = csvString.replace(/\\r/g, '');\r\n    let inQuote = false;\r\n    let wasQuote = false;\r\n    let tokenStart = 0;\r\n    let row = [];\r\n    for (let i = 0; i < csvString.length; i++) {\r\n        const char = csvString[i];\r\n        const comma = char === ',';\r\n        const quote = char === '\"';\r\n        const newline = char === '\\n';\r\n        const eof = i === csvString.length - 1; // eof - End Of File\r\n        if (inQuote) {\r\n            // Characters may be delimited\r\n            if (quote) {\r\n                // Check if the next character is another double quote, i.e. if it is escaped\r\n                const nextChar = csvString[i + 1];\r\n                if (nextChar === '\"') {\r\n                    // This and the next character combined make an escaped double quote,\r\n                    // so the quote has not ended and we should skip over the next character\r\n                    i++;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // The quote has ended\r\n                    inQuote = false;\r\n                    wasQuote = true;\r\n                    if (!eof) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            else if (eof) {\r\n                throw new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n            }\r\n        }\r\n        if (!inQuote && (comma || newline || eof)) {\r\n            // These are the characters that denote the end of a token\r\n            let token = csvString.substring(tokenStart, i + 1);\r\n            if (comma || newline) {\r\n                // Don't keep the separator\r\n                token = token.substring(0, token.length - 1);\r\n            }\r\n            if (wasQuote) {\r\n                wasQuote = false;\r\n                // Remove start and end quotes\r\n                token = token.substring(1, token.length - 1);\r\n                // Replace escaped quotes\r\n                token = token.replace(/\"\"/g, '\"');\r\n            }\r\n            row.push(token);\r\n            if (comma && eof) {\r\n                // It's the end of the last token, and the last cell is empty\r\n                row.push('');\r\n            }\r\n            if (newline || eof) {\r\n                tokens.push(row);\r\n                if (newline) {\r\n                    row = [];\r\n                }\r\n            }\r\n            tokenStart = i + 1;\r\n        }\r\n        else if (wasQuote) {\r\n            throw new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n        }\r\n        else if (quote) {\r\n            inQuote = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows) {\r\n    // Each row of a CSV should have the same length;\r\n    if (rows && rows.length > 1) {\r\n        let rowLength = rows[0].length;\r\n        for (let i = 1; i < rows.length; i++) {\r\n            let row = rows[i];\r\n            if (row.length !== rowLength) {\r\n                throw new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport { parse };\r\n//# sourceMappingURL=parse.js.map","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { ChartOptions } from './ChartOptions.js';\n\nexport type ChartData<GroupName extends string = string> = {\n\tlabels: any[],\n\tgroupNames: GroupName[],\n\tgroups: number[][],\n\n\tmin?: number,\n\tmax?: number,\n\n\tstacked?: boolean,\n};\n\nexport function getChartData<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: ChartOptions<GroupName>): ChartData<GroupName> {\n\tconst [[, ...groupNames]] = summary; // Ignore first 'Value' entry in first row\n\tlet [, ...valueRows] = summary; // Ignore first row of group names\n\n\t// Extract the labels\n\tlet labels = valueRows.map((row) => row[0]);\n\n\t// If the x axis is qualitative, and its labels were limited in its options\n\tif (options?.x && 'labels' in options.x && options.x.labels) {\n\t\t// Remove any labels not specified in the axis options\n\t\tfor (let i = 0; i < labels.length; i++) {\n\t\t\tconst label = labels[i];\n\t\t\tif (options.x.labels.includes(label) === false) {\n\t\t\t\tlabels.splice(i, 1);\n\t\t\t\tvalueRows.splice(i, 1);\n\t\t\t\ti -= i;\n\t\t\t}\n\t\t}\n\n\t\t// Go through specified labels, and if any weren't in the dataset then add empty data\n\t\tfor (let i = 0; i < options.x.labels.length; i++) {\n\t\t\tconst label = options.x.labels[i];\n\t\t\tif (labels.includes(label) === false) {\n\t\t\t\tconst emptyData: [string, ...0[]] = [label, ...(new Array(valueRows[0].length-1)).fill(0)];\n\t\t\t\tlabels.splice(i, 0, label);\n\t\t\t\tvalueRows.splice(i, 0, emptyData);\n\t\t\t}\n\t\t}\n\n\t\t// Also update order of labels and value rows to match specified label order\n\t\tlabels = options.x.labels;\n\t\tvalueRows = valueRows.sort((rowA, rowB) => {\n\t\t\tconst labelA = rowA[0];\n\t\t\tconst indexA = labels.indexOf(labelA);\n\n\t\t\tconst labelB = rowB[0];\n\t\t\tconst indexB = labels.indexOf(labelB);\n\n\t\t\treturn indexA - indexB;\n\t\t});\n\t}\n\n\t// Transpose valueRows to get groups\n\tconst valueGroups: any[][] = [];\n\tfor (let i = 0; i < valueRows.length; i++) {\n\t\t// Start at j = 1 to ignore labels\n\t\tfor (let j = 1; j < valueRows[i].length; j++) {\n\t\t\tif (typeof valueGroups[j] === 'undefined') {\n\t\t\t\tvalueGroups[j] = [];\n\t\t\t}\n\t\t\tvalueGroups[j][i] = valueRows[i][j]\n\t\t}\n\t}\n\t// This method has given us an empty element at index 0, so remove it\n\tvalueGroups.splice(0, 1);\n\n\t// We can only graph groups if all their values are numbers\n\tconst numberValueGroups = valueGroups.filter(\n\t\t(group): group is number[] => group.every(\n\t\t\t(value): value is number => typeof value === 'number'\n\t\t)\n\t);\n\n\t// Filter out the same non-number groups from the groupNames list\n\tconst numberValueGroupNames = groupNames.filter(\n\t\t(groupName, index) => numberValueGroups.includes(valueGroups[index])\n\t);\n\n\tconst chartData: ChartData<GroupName> = {\n\t\tlabels,\n\t\tgroupNames: numberValueGroupNames,\n\t\tgroups: numberValueGroups,\n\t};\n\n\tif (options && 'stacked' in options) {\n\t\tchartData.stacked = options.stacked;\n\t}\n\n\treturn chartData;\n}\n","import * as statistics from '../statistics.js';\nimport { ChartData } from './ChartData.js';\nimport { ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\n\nexport interface ScaleOptions {\n\tmin: number,\n\tmax: number,\n}\n\nexport class Scale {\n\tmin: number;\n\tmax: number;\n\n\tget width(): number {\n\t\treturn this.max - this.min;\n\t};\n\n\tconstructor(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x') {\n\t\t[this.min, this.max] = getMinMax(options, chartOptions, type);\n\t}\n\n\t/**\n\t * Standardises the scale to go from 0 to 1,\n\t * then finds the value's position within it.\n\t */\n\tgetProportion(value: number): number {\n\t\tconst proportion = (value - this.min) / this.width;\n\n\t\treturn proportion;\n\t}\n\n\t/**\n\t * Given a proportion value on a scale from 0 to 1,\n\t * find the equivalent value on this scale.\n\t */\n\tgetValue(proportion: number): number {\n\t\tconst value = this.width * proportion + this.min;\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * For a given length of at least 2, create an array\n\t * of numbers from the bottom of the scale to the top,\n\t * with an equal step between each number in the range.\n\t */\n\tgetSeries(length: number): number[] {\n\t\tif (length < 2) {\n\t\t\tlength = 2;\n\t\t}\n\n\t\tconst stepSize = this.width / (length-1);\n\n\t\t// Start with minimum value\n\t\tconst series: number[] = [this.min];\n\n\t\t// Add intermediate steps\n\t\tfor (let i = 0; i < length-2; i++) {\n\t\t\tseries.push(series[series.length-1] + stepSize);\n\t\t}\n\n\t\t// End with max value\n\t\tseries.push(this.max);\n\n\t\treturn series;\n\t}\n}\n\n/**\n * Determines the appropriate method for reading or calculating min and max values,\n * based on the available data and options, then reads or calculates them.\n */\nfunction getMinMax(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x'): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\t// First, get minMax from options\n\tif ('groups' in options) {\n\t\t// options is of type ChartData, so determine min and max based on\n\t\t// the labels or the data, depending on the type of scale being created\n\t\tif (type === 'x') {\n\t\t\t[min, max] = getMinMaxFromChartDataLabels(options);\n\t\t} else {\n\t\t\t[min, max] = getMinMaxFromChartData(options);\n\t\t}\n\t} else {\n\t\t// options is a ScaleOptions, so read min and max directly\n\t\t[min, max] = getMinMaxFromScaleOptions(options);\n\t}\n\n\t// If min is larger than max, swap them around\n\tif (min > max) {\n\t\t[min, max] = [max, min];\n\t}\n\n\t// Then, see if min and/or max are overridden by chartOptions\n\tif (type && chartOptions) {\n\t\tconst axisOptions = chartOptions[type];\n\t\tif (axisOptions && ('min' in axisOptions || 'max' in axisOptions || 'values' in axisOptions)) {\n\t\t\tconst allowAuto = type !== 'x';\n\t\t\t[min, max] = getMinMaxFromAxisOptions(axisOptions, min, max, allowAuto);\n\t\t}\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the values contained in a set of ChartData.\n */\nfunction getMinMaxFromChartData(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { groups } = options;\n\n\tif (!groups.length || !groups[0].length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tlet allValues: number[];\n\tif ('stacked' in options && options.stacked) {\n\t\tallValues = groups[0].map((el, i) => groups.reduce((sum, group) => sum + group[i], 0));\n\t} else {\n\t\t// Use `as number[]` here so TypeScript doesn't complain when using Array.prototype.concat\n\t\tallValues = ([] as number[]).concat(...groups);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...allValues);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...allValues);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the labels for a set of ChartData.\n * Assumes all labels can be converted to numbers, and will throw an error if this assumption is false.\n */\nfunction getMinMaxFromChartDataLabels(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { labels } = options;\n\n\tif (!labels.length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tconst numberLabels = labels.map((label) => typeof label === 'number' ? label : +label);\n\tif (!numberLabels.every((label) => isNaN(label) === false)) {\n\t\tthrow new TypeError(`Cannot extract minimum or maximum values from labels that aren't all numbers.`);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...numberLabels);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...numberLabels);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Reads min and max values directly from a ScaleOptions object.\n */\nfunction getMinMaxFromScaleOptions(options: ScaleOptions): [number, number] {\n\tconst { min, max } = options;\n\n\treturn [min, max];\n}\n\n/**\n * Determines min and max values from an AxisOptions object, either reading them\n * directly from the options or calculating them from the highest order of magnitude\n * and, if specified, the number of values that needs to display on an axis.\n */\nfunction getMinMaxFromAxisOptions(axisOptions: AxisOptionsQuantitative, min: number, max: number, allowAuto = true): [number, number] {\n\tif (\n\t\t(Array.isArray(axisOptions.values) && axisOptions.values.length) ||\n\t\t(Array.isArray(axisOptions.gridlines) && axisOptions.gridlines.length)\n\t) {\n\t\t// If all the axis values or gridlines are specified,\n\t\t// the values they determine can extend min and/or max\n\t\t// past the values already determined.\n\n\t\t// Axis options can specify values as dates, but Scale always works with numbers\n\t\tlet allValues: number[] = [];\n\t\tif (Array.isArray(axisOptions.values)) {\n\t\t\tallValues = allValues.concat(axisOptions.values.map((val) => +val));\n\t\t}\n\t\tif (Array.isArray(axisOptions.gridlines)) {\n\t\t\tallValues = allValues.concat(axisOptions.gridlines.map((val) => +val));\n\t\t}\n\t\tmin = Math.min(min, ...allValues);\n\t\tmax = Math.max(max, ...allValues);\n\t}\n\n\tif (typeof axisOptions.min === 'number') {\n\t\tmin = axisOptions.min;\n\t} else if (allowAuto && (axisOptions.min === 'auto' || typeof axisOptions.min === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Round down min to nearest multiple of that power of 10\n\t\tconst widthRoundTo = Math.pow(10, maxPower);\n\t\tmin = Math.floor(min / widthRoundTo) * widthRoundTo;\n\n\t\t// If the power was negative, fix any floating point issues that may have arisen\n\t\tif (maxPower < 0) {\n\t\t\tmin = +(min.toFixed(-maxPower));\n\t\t}\n\t}\n\n\tif (typeof axisOptions.max === 'number') {\n\t\tmax = axisOptions.max;\n\t} else if (allowAuto && (axisOptions.max === 'auto' || typeof axisOptions.max === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Subtract min so we're working directly with the width\n\t\tmax -= min;\n\n\t\t// Round up max to nearest multiple of that power of 10\n\t\tlet widthRoundTo = Math.pow(10, maxPower);\n\t\tmax = Math.ceil(max / widthRoundTo) * widthRoundTo;\n\n\t\t// If the number of values to be displayed has been set\n\t\tif (typeof axisOptions.values === 'number') {\n\t\t\t// Only integers are accepted\n\t\t\tif (Number.isInteger(axisOptions.values) === false) {\n\t\t\t\tthrow new TypeError(`axisOptions.values must be an integer.`);\n\t\t\t}\n\n\t\t\t// Continue to increase max until it is a multiple of the next\n\t\t\t// greatest power of 10 below the largest one beneath max.\n\t\t\t// Also, ensure max is greater than min\n\t\t\tconst valuePower = maxPower - 1;\n\t\t\tlet valueRoundTo = Math.pow(10, valuePower) * axisOptions.values;\n\n\t\t\t// If that power is negative, JavaScript can run into issues\n\t\t\t// to do with numbers like 0.1 being unable to be represented in binary.\n\t\t\t// So multiply everything by that power and round it, then divide and fix at the end\n\t\t\tif (valuePower < 0) {\n\t\t\t\tvalueRoundTo = Math.round(valueRoundTo / Math.pow(10, valuePower));\n\t\t\t\twidthRoundTo = Math.round(widthRoundTo / Math.pow(10, valuePower));\n\t\t\t\tmax = Math.round(max / Math.pow(10, valuePower));\n\t\t\t}\n\n\t\t\tfor (let iterations = 0; iterations < 1000; iterations++) {\n\t\t\t\tlet remainder = max % valueRoundTo;\n\n\t\t\t\tif (remainder === 0 && max > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tmax += widthRoundTo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we muliplied everything earlier, undo that now then fix any floating point issues\n\t\t\tif (valuePower < 0) {\n\t\t\t\tmax = +(max * Math.pow(10, valuePower)).toFixed(-valuePower);\n\t\t\t}\n\t\t}\n\n\t\t// Add min back to convert width back to max\n\t\tmax += min;\n\t}\n\n\treturn [min, max];\n}\n","import { ChartData } from './ChartData.js';\nimport { BaseChartOptions, ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\nimport { Scale } from './Scale.js';\n\nexport function chart<GroupName extends string>(chartData: ChartData<GroupName>, contents: string, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<figure class=\"chart\">\n\t\t\t${options?.title ? title(options) : ''}\n\n\t\t\t<div class=\"chart__area\">\n\t\t\t\t${options?.legend ? legend(chartData, options) : ''}\n\n\t\t\t\t${yGridlines(chartData, options)}\n\n\t\t\t\t${xGridlines(chartData, options)}\n\n\t\t\t\t${contents}\n\t\t\t</div>\n\n\t\t\t${yAxis(chartData, options)}\n\n\t\t\t${xAxis(chartData, options)}\n\t\t</figure>\n\t`;\n}\n\nfunction title<GroupName extends string>(options: ChartOptions<GroupName>): string {\n\treturn `<figcaption class=\"chart__title\">${options.title}</figcaption>`;\n}\n\nfunction legend<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<div class=\"chart__legend\">\n\t\t\t<span class=\"chart__legend__title\">Legend</span>\n\n\t\t\t<ul class=\"chart__legend__items\">\n\t\t\t\t${chartData.groupNames.map((groupName, index) => {\n\t\t\t\t\tconst colour = options?.colours && options.colours[groupName];\n\n\t\t\t\t\tconst str = `<li class=\"chart__legend__item\">\n\t\t\t\t\t\t<span class=\"chart__legend__item__swatch\"${colour ? ` style=\"background-color: ${colour};\"` : ''}></span>\n\t\t\t\t\t\t<span class=\"chart__legend__item__name\">${groupName}</span>\n\t\t\t\t\t</li>`;\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t</div>\n\t`;\n}\n\nfunction yAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.y;\n\n\tconst scale = new Scale(chartData, options, 'y');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\t// Render axis based on scale\n\treturn `\n\t<div class=\"chart__y-axis\">\n\t\t${axisOptions?.title ? `\n\t\t<span class=\"chart__y-axis__title\">${axisOptions.title}</span>\n\t\t` : ''}\n\n\t\t<ul class=\"chart__y-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__y-axis__value\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\tif (axisOptions) {\n\t\t// AxisOptions has no required values, so we can only be certain what axis type we're dealing with if labels or values is specified\n\t\tif ('labels' in axisOptions) {\n\t\t\treturn xAxisQualitative(chartData, options);\n\t\t} else if ('values' in axisOptions) {\n\t\t\treturn xAxisQuantitative(chartData, options);\n\t\t}\n\t}\n\n\treturn xAxisMinimal(chartData, options);\n}\n\nfunction xAxisQualitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst { labels } = chartData;\n\n\t// For each label, render that label\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__label-list\">\n\t\t\t${labels.map((label) => `<li class=\"chart__x-axis__label\">${applyFormat(label, axisOptions)}</li>`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisQuantitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst scale = new Scale(chartData, options, 'x');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__x-axis__value\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisMinimal<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t</div>`;\n}\n\nfunction yGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst scale = new Scale(chartData, options, 'y');\n\n\tconst axisOptions = options?.y;\n\tconst { values } = getAxisGridlines(scale, options?.y);\n\n\t// Render gridlines based on scale\n\treturn `\n\t\t<ul class=\"chart__y-gridlines\" role=\"presentation\">\n\t\t\t${values.map((val, index) => {\n\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t// since that line is already drawn by the x axis\n\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t<li class=\"chart__y-gridline\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t'';\n\n\t\t\t\treturn gridlines\n\t\t\t}).join('')}\n\t\t</ul>\n\t`;\n}\n\nfunction xGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\tif (axisOptions && ('values' in axisOptions || 'gridlines' in axisOptions)) {\n\t\tconst scale = new Scale(chartData, options, 'x');\n\t\tconst { values } = getAxisGridlines(scale, axisOptions);\n\n\t\t// Render gridlines based on scale\n\t\treturn `\n\t\t\t<ul class=\"chart__x-gridlines\" role=\"presentation\">\n\t\t\t\t${values.map((val, index) => {\n\t\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t\t// since that line is already drawn by the y axis\n\t\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t\t<li class=\"chart__x-gridline\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t\t'';\n\n\t\t\t\t\treturn gridlines\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t`;\n\t} else {\n\t\treturn '';\n\t}\n}\n\nexport function tooltip<GroupName extends string>(chartData: ChartData<GroupName>, group: number[], label: string, options?: ChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst groupIndex = groups.indexOf(group);\n\tif (groupIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised group`);\n\t}\n\n\tconst groupName = groupNames[groupIndex];\n\n\tconst labelIndex = labels.indexOf(label);\n\tif (labelIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised label`);\n\t}\n\n\tconst value = group[labelIndex];\n\n\tconst str = `\n\t<div class=\"chart__tooltip\">\n\t\t${groups.length > 1 ? groupName : ''} ${label}: ${applyFormat(value, options?.y)}\n\t</div>`;\n\n\treturn str;\n}\n\ninterface AxisValues {\n\tvalues: number[],\n\tdates: boolean,\n}\n\nfunction getAxisValues(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.values !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.values);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tvalues = scale.getSeries(2);\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\nfunction getAxisGridlines(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.gridlines !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.gridlines);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tconst axisValues = getAxisValues(scale, axisOptions);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\n/**\n * Both axis values and axis gridlines are retrieved in the same way, only with different fallbacks.\n * This base function contains that shared functionality, including the necessary conversion from\n * Date to number if the specified values are Dates, while remembering that they were Dates so they\n * can be converted back to Dates further down the line.\n */\nfunction getAxisValuesBase(scale: Scale, axisValues: Exclude<AxisOptionsQuantitative['values'], undefined>): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisValues === 'number') {\n\t\tconst numValues = axisValues + 1;\n\t\tvalues = scale.getSeries(numValues);\n\t} else if (axisValues.length > 0) {\n\t\t// TODO: I don't understand why the type assertions here are necessary\n\t\tif ((axisValues as unknown[]).every((val: unknown): val is number => typeof val === 'number')) {\n\t\t\tvalues = axisValues as number[];\n\t\t} else {\n\t\t\tdates = true;\n\t\t\tvalues = axisValues.map((val) => +val);\n\t\t}\n\t} else {\n\t\tvalues = axisValues as [];\n\t}\n\n\treturn { values, dates };\n}\n\nfunction applyFormat(value: any, axisOptions?: AxisOptionsQuantitative): string {\n\tif (typeof value === 'number') {\n\t\tif (axisOptions?.numberFormat) {\n\t\t\tif (axisOptions.numberFormat instanceof Intl.NumberFormat) {\n\t\t\t\treturn axisOptions.numberFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.numberFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else if (value instanceof Date) {\n\t\tif (axisOptions?.dateFormat) {\n\t\t\tif (axisOptions.dateFormat instanceof Intl.DateTimeFormat) {\n\t\t\t\treturn axisOptions.dateFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.dateFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else {\n\t\treturn '' + value;\n\t}\n}\n","// import * as analyser from '@cipscis/analyser';\nimport { sum } from '../../../../dist/statistics.js';\nimport * as analyser from '../../../../src/analyser.js';\n\nconst analyse = async function () {\n\tconst fileInfoA = analyser.fileConfig({\n\t\tpath: '/analyser/assets/data/city example.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tNAME: 'A',\n\t\t\tCOUNTRY: 'B',\n\t\t\tPOPULATION: 'C',\n\t\t\tCAPITAL: 'D',\n\t\t\tPUBLIC_TRANSPORT: 'E',\n\t\t\tMAYOR_2012: 'F',\n\t\t\tMAYOR_2018: 'G',\n\t\t},\n\t\ttransform: {\n\t\t\tPOPULATION: analyser.transformers.number,\n\t\t\tCAPITAL: analyser.transformers.booleanCustom('true', /^$|^'no'$/i),\n\t\t\tPUBLIC_TRANSPORT: analyser.transformers.array(','),\n\t\t\tMAYOR_2018: analyser.transformers.array(','),\n\t\t},\n\t\taliases: [\n\t\t\t['New Zealand', 'Aotearoa']\n\t\t],\n\t});\n\n\tconst fileInfoB = analyser.fileConfig({\n\t\tpath: '/analyser/assets/data/city example 2.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tNAME: 'A',\n\t\t\tCOUNTRY: 'B',\n\t\t\tPOPULATION: 'C',\n\t\t},\n\t});\n\tconst fileInfoC = analyser.fileConfig({\n\t\tpath: '/analyser/assets/data/city example 3.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tYEAR: 'A',\n\t\t\tPOPULATION: 'B',\n\t\t},\n\t});\n\n\tconst [cityData, cityData2, cityData3] = await Promise.all([\n\t\tanalyser.loadFile(fileInfoA),\n\t\tanalyser.loadFile(fileInfoB),\n\t\tanalyser.loadFile(fileInfoC),\n\t]);\n\n\tconst {\n\t\trows,\n\t\tcols,\n\t\taddedCols,\n\t\tby,\n\t\tgroup,\n\t} = cityData;\n\n\t// console.log(rows);\n\t// console.log(cols);\n\n\t// console.log(rows.filter(\n\t// \tby(cols.POPULATION, (pop: number) => pop > 1000)\n\t// \t.orBy(cols.POPULATION, (pop: number) => pop < 300)\n\t// \t.andBy(cols.MAYOR_2012, 'Len Brown')\n\t// ));\n\n\tconst getIndex = (row: any[], i: number): number => i;\n\n\taddedCols.INDEX = rows.addCol(getIndex);\n\t// console.log(addedCols.INDEX);\n\n\t// console.dir(group(rows, cols.COUNTRY));\n\n\t// console.table(group(rows, cols.COUNTRY).summarise({\n\t// \tnumber: (rows) => rows.length,\n\t// }));\n\n\t// console.table(group(rows, cols.PUBLIC_TRANSPORT).summarise({\n\t// \tnumber: (rows) => rows.length,\n\t// }));\n\n\tconst nameGroup = group(rows, cols.NAME);\n\tconst nameGroupSummary = nameGroup.summarise({\n\t\tpopulation: (rows) => sum(rows.getCol(cols.POPULATION) as number[]),\n\t\tpop_half: (rows) => sum(rows.getCol(cols.POPULATION) as number[]) / 2,\n\t});\n\tconst barChartHtml = analyser.bar(nameGroupSummary,\n\t{\n\t\ttitle: 'Bar Chart',\n\t\tlegend: true,\n\n\t\tcolours: {\n\t\t\tpopulation: 'blue',\n\t\t\tpop_half: 'red',\n\t\t},\n\n\t\ty: {\n\t\t\ttitle: 'population',\n\t\t\tvalues: 8,\n\t\t\t// values: [0, 1000, 6000],\n\t\t\t// gridlines: [0, 1000, 6000],\n\t\t\t// gridlines: [],\n\t\t\tgridlines: 4,\n\n\t\t\tnumberFormat: new Intl.NumberFormat('en-NZ', {\n\t\t\t\tuseGrouping: true,\n\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t}),\n\t\t\t// numberFormat: (value: number) => value.toFixed(2),\n\n\t\t\t// max: 'auto',\n\t\t\t// min: 'auto',\n\t\t\t// max: 6500,\n\t\t\t// min: -1000,\n\t\t},\n\t\tx: {\n\t\t\ttitle: 'City',\n\t\t\tlabels: ['Sydney', 'Hamburg', 'Auckland', 'Wellington', 'Christchurch', 'Hamilton', 'Nothing', 0],\n\t\t\tnumberFormat: (value: number) => value.toFixed(2),\n\t\t},\n\n\t\tstacked: true,\n\t});\n\n\tconst $barChart = document.getElementById('bar-chart');\n\tif ($barChart) {\n\t\t$barChart.innerHTML = barChartHtml;\n\t}\n\n\tconst lineChartHtml = analyser.line(\n\t\t[\n\t\t\t[, 'Line 1', 'Line 2'],\n\t\t\t[new Date(2022, 2, 1), 0, 50],\n\t\t\t[new Date(2022, 2, 2), 10, 40],\n\t\t\t[new Date(2022, 2, 4), 25, 20],\n\t\t\t[new Date(2022, 2, 5), 50, 15],\n\t\t\t[new Date(2022, 2, 6), 30, 30],\n\n\t\t\t// [1, 0, 50],\n\t\t\t// [2, 10, 40],\n\t\t\t// [3, 25, 20],\n\t\t\t// [4, 50, 15],\n\t\t\t// [5, 30, 30],\n\t\t],\n\t\t{\n\t\t\ttitle: 'Line Chart',\n\t\t\tlegend: true,\n\n\t\t\tcolours: {\n\t\t\t\t'Line 1': 'blue',\n\t\t\t\t// 'Line 2': 'red',\n\t\t\t},\n\n\t\t\ty: {\n\t\t\t\ttitle: 'y axis',\n\t\t\t\tvalues: 5,\n\n\t\t\t\tnumberFormat: new Intl.NumberFormat('en-NZ', {\n\t\t\t\t\tuseGrouping: true,\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t}),\n\t\t\t},\n\n\t\t\tx: {\n\t\t\t\ttitle: 'x axis',\n\t\t\t\t// values: 5,\n\t\t\t\tvalues: [\n\t\t\t\t\tnew Date(2022, 2, 1),\n\t\t\t\t\tnew Date(2022, 2, 2),\n\t\t\t\t\tnew Date(2022, 2, 4),\n\t\t\t\t\tnew Date(2022, 2, 5),\n\t\t\t\t\tnew Date(2022, 2, 6),\n\t\t\t\t],\n\t\t\t\t// values: [0, 2, 4, 6],\n\n\t\t\t\tgridlines: 5,\n\t\t\t\t// gridlines: [\n\t\t\t\t// \tnew Date(2022, 2, 1),\n\t\t\t\t// \tnew Date(2022, 2, 2),\n\t\t\t\t// \tnew Date(2022, 2, 3),\n\t\t\t\t// \tnew Date(2022, 2, 4),\n\t\t\t\t// \tnew Date(2022, 2, 5),\n\t\t\t\t// \tnew Date(2022, 2, 6),\n\t\t\t\t// ],\n\t\t\t\t// gridlines: [1, 4],\n\n\t\t\t\t// numberFormat: (value: number) => value.toFixed(1),\n\t\t\t\tnumberFormat: (value: number) => {\n\t\t\t\t\tconst date = new Date(value);\n\t\t\t\t\tconst dateString = new Intl.DateTimeFormat('en-NZ', {\n\t\t\t\t\t\tdateStyle: 'short',\n\t\t\t\t\t}).format(date);\n\t\t\t\t\tconst timeString = new Intl.DateTimeFormat('en-NZ', {\n\t\t\t\t\t\ttimeStyle: 'short',\n\t\t\t\t\t}).format(date);\n\n\t\t\t\t\tconst dateTimeString = `${dateString} ${timeString}`;\n\n\t\t\t\t\treturn dateTimeString;\n\t\t\t\t},\n\t\t\t\tdateFormat: new Intl.DateTimeFormat('en-NZ'),\n\t\t\t},\n\t\t}\n\t);\n\n\tconst $lineChart = document.getElementById('line-chart');\n\tif ($lineChart) {\n\t\t$lineChart.innerHTML = lineChartHtml;\n\t}\n};\n\nanalyse();\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { BarChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderBars<GroupName extends string>(chartData: ChartData<GroupName>, options?: BarChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scale = new Scale(chartData, options, 'y');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<ul class=\"chart__bar-groups\">\n\t\t\t${labels.map((label, index) =>\n\t\t\t`<li class=\"chart__bar-group\">\n\t\t\t\t<ul class=\"chart__bar-group-bars${options?.stacked ? ` chart__bar-group-bars--stacked` : ''}\">\n\t\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\t\tconst colour = colours && colours[groupName];\n\t\t\t\t\t\tconst value = group[index];\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li\n\t\t\t\t\t\t\t\tclass=\"chart__bar\"\n\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t` style=\"flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t}%;\"` :\n\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclass=\"chart__bar__area\"\n\t\t\t\t\t\t\t\tstyle=\"\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\tcolour ?\n\t\t\t\t\t\t\t\t\t\t\t`background: ${colour}; ` :\n\t\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t\t'' :\n\t\t\t\t\t\t\t\t\t\t\t`flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t\t}%;`\n\t\t\t\t\t\t\t\t\t}\" data-value=\"${value}\"\n\t\t\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>`\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t</li>`).join('')}\n\t\t</ul>\n\t`;\n}\n\nexport function bar<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: BarChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst bars = renderBars(chartData, options);\n\n\tconst chart = renderChart(chartData, bars, options);\n\n\treturn chart;\n};\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { LineChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderLines<GroupName extends string>(chartData: ChartData<GroupName>, options?: LineChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scaleY = new Scale(chartData, options, 'y');\n\tconst scaleX = new Scale(chartData, options, 'x');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<svg class=\"chart__lines\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\">\n\t\t\t<g transform=\"translate(0, 100) scale(1, -1)\">\n\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\t\t\tconst points = labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\t\t\t\t\t\tconst str = `${leftPercent},${percentage}`;\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join(' ');\n\n\t\t\t\t\tconst str = `\n\t\t\t\t\t\t<polyline class=\"chart__line\" points=\"${points}\"${colour ? ` style=\"stroke: ${colour};\"` : ''}></polyline>\n\t\t\t\t\t`;\n\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</g>\n\t\t</svg>\n\n\t\t${groups.map((group, groupIndex) => {\n\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\tconst str = `\n\t\t\t\t<ul class=\"chart__line__points\">\n\t\t\t\t\t${labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li class=\"chart__line__point\" style=\"left: ${leftPercent}%; bottom: ${percentage}%\" tabindex=\"0\">\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t`;\n\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t`;\n\n\t\t\treturn str;\n\t\t}).join('')}\n\t`;\n}\n\nexport function line<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: LineChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst lines = renderLines(chartData, options);\n\n\tconst chart = renderChart(chartData, lines, options);\n\n\treturn chart;\n};\n"],"names":["sum","arr","val","value","length","Array","isArray","reduce","AnalyserRows","constructor","source","super","i","this","getCol","colNum","TypeError","RangeError","col","row","push","addCol","creator","colIndex","Error","entries","getColNumber","colName","Number","isInteger","alphabet","rowNumber","upperColName","toUpperCase","char","charIndex","indexOf","Math","pow","getColNumbers","colsConfig","newCols","key","colNumber","defaultSummarisers","Count","rows","AnalyserGroup","Map","options","discrete","summarise","summarisersArg","summarisers","summaryHeaderRow","Object","keys","summaryValueRows","groupName","summaryRow","summariser","rowSummary","summaryValuesSorted","map","sort","a","b","createFilterFn","aliases","values","_extendFilterFn","index","_applyFilter","filterResolver","extendedFilterResolver","andBy","orBy","cell","cellValues","cellValue","_matchAlias","aliasList","includes","cleanNumberLike","replace","appearsNumber","cleanValue","parseFloat","array","separator","limit","split","booleanCustom","truthy","falsey","locationIdentifier","cleanedValue","trim","toLowerCase","test","console","warn","number","match","appearsPercentage","numValue","precision","toFixed","enumValue","enums","recodeMap","enumValues","join","async","loadFile","fileConfig","response","fetch","path","ok","headerRows","splice","footerRows","by","group","splitting","right","Set","add","isNonCanonical","isCanonical","has","delete","matchingRows","filter","set","setLimits","enumArr","every","x","min","max","setSize","setMin","setMax","splitValues","concat","Infinity","filterFn","setName","createGroupFn","dataConfig","raw","cols","addedCols","transform","transformFn","_processData","csvString","mapper","stringRows","tokens","inQuote","wasQuote","tokenStart","comma","quote","newline","eof","SyntaxError","token","substring","_tokenise","rowLength","_validate","parse","text","status","getChartData","summary","groupNames","valueRows","labels","label","emptyData","fill","rowA","rowB","labelA","indexA","labelB","valueGroups","j","numberValueGroups","numberValueGroupNames","chartData","groups","stacked","Scale","chartOptions","type","numberLabels","isNaN","getMinMaxFromChartDataLabels","allValues","el","getMinMaxFromChartData","getMinMaxFromScaleOptions","axisOptions","allowAuto","gridlines","maxPower","floor","log10","abs","widthRoundTo","ceil","valuePower","valueRoundTo","round","iterations","getMinMaxFromAxisOptions","getMinMax","getProportion","width","getValue","proportion","getSeries","stepSize","series","contents","title","legend","colour","colours","scale","y","getAxisGridlines","yGridlines","xGridlines","dates","getAxisValues","applyFormat","Date","yAxis","xAxisQualitative","xAxisQuantitative","xAxisMinimal","xAxis","tooltip","groupIndex","labelIndex","axisValues","getAxisValuesBase","numValues","numberFormat","Intl","NumberFormat","format","toString","dateFormat","DateTimeFormat","fileInfoA","NAME","COUNTRY","POPULATION","CAPITAL","PUBLIC_TRANSPORT","MAYOR_2012","MAYOR_2018","cityData","cityData2","cityData3","Promise","all","YEAR","INDEX","barChartHtml","renderBars","population","pop_half","useGrouping","maximumFractionDigits","$barChart","document","getElementById","innerHTML","lineChartHtml","scaleY","scaleX","leftPercent","renderLines","date","dateStyle","timeStyle","$lineChart","analyse"],"sourceRoot":""}