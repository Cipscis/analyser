{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/analyser/webpack/bootstrap","webpack://@cipscis/analyser/webpack/runtime/define property getters","webpack://@cipscis/analyser/webpack/runtime/hasOwnProperty shorthand","webpack://@cipscis/analyser/webpack/runtime/make namespace object","webpack://@cipscis/analyser/./node_modules/@cipscis/codebook/dist/codebook.js","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/stringify.js","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/parse.js","webpack://@cipscis/analyser/./src/DataGroup.ts","webpack://@cipscis/analyser/./src/Data.ts","webpack://@cipscis/analyser/./src/types/string.ts","webpack://@cipscis/analyser/./src/types/number.ts","webpack://@cipscis/analyser/./src/types/boolean.ts","webpack://@cipscis/analyser/./src/types/value.ts","webpack://@cipscis/analyser/./src/types/array.ts","webpack://@cipscis/analyser/./src/types/enumValue.ts","webpack://@cipscis/analyser/./src/util.ts","webpack://@cipscis/analyser/./src/file-processing.ts","webpack://@cipscis/analyser/./src/statistics.ts","webpack://@cipscis/analyser/./src/FileConfig.ts","webpack://@cipscis/analyser/./src/charts/ChartData.ts","webpack://@cipscis/analyser/./src/charts/Scale.ts","webpack://@cipscis/analyser/./src/charts/chart.ts","webpack://@cipscis/analyser/./src/charts/bar.ts","webpack://@cipscis/analyser/./src/charts/line.ts","webpack://@cipscis/analyser/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const selectors = Object.freeze({\r\n    block: '.js-codebook__block',\r\n    set: '.js-codebook__set',\r\n    inert: '.js-codebook__inert',\r\n});\r\nconst dataAttributes = Object.freeze({\r\n    set: 'data-codebook-set',\r\n    index: 'data-codebook-index',\r\n    log: 'data-codebook-log',\r\n    html: 'data-codebook-html',\r\n});\r\nconst defaultSetName = 'default';\r\n// Create a single textarea element for decoding HTML\r\nconst $textarea = document.createElement('textarea');\r\n/**\r\n * Run all Codebook blocks in all Codebook sets in order, with any specified external arguments made available.\r\n */\r\nexport function run(args) {\r\n    return new Promise((resolve, reject) => {\r\n        const sets = _createCodeSets(args);\r\n        const promises = [];\r\n        for (let setName in sets) {\r\n            const set = sets[setName];\r\n            promises.push(_runSet(set));\r\n        }\r\n        Promise.all(promises)\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n}\r\nexport async function runSet(setNameOrArgs, argsParam) {\r\n    let setName;\r\n    let args = undefined;\r\n    // Figure out which arguments were passed.\r\n    if (typeof setNameOrArgs === 'string') {\r\n        setName = setNameOrArgs;\r\n        if (argsParam) {\r\n            args = argsParam;\r\n        }\r\n    }\r\n    else {\r\n        // If no set name was specified, use the default set name.\r\n        setName = defaultSetName;\r\n        if (setNameOrArgs) {\r\n            args = setNameOrArgs;\r\n        }\r\n    }\r\n    const sets = _createCodeSets(args);\r\n    if (setName in sets) {\r\n        const set = sets[setName];\r\n        return _runSet(set);\r\n    }\r\n    else {\r\n        throw new RangeError(`Codebook: Cannot run unrecognised set '${setName}'`);\r\n    }\r\n}\r\n/**\r\n * Adjust the indentation of Codebook sets so it appears correctly when viewed on a page.\r\n */\r\nexport function tidy() {\r\n    const $blocks = document.querySelectorAll(`${selectors.block}, ${selectors.inert}`);\r\n    for (let $block of $blocks) {\r\n        const code = $block.innerHTML;\r\n        // Look for tab indentation only\r\n        const match = code.match(/^(\\t*)\\S/m);\r\n        if (match) {\r\n            const indentation = match[1];\r\n            const level = indentation.length;\r\n            const pattern = new RegExp(`^\\\\t{${level}}`, 'gm');\r\n            $block.innerHTML = code.replace(pattern, '').trim();\r\n        }\r\n    }\r\n    ;\r\n}\r\n/**\r\n * Gathers all Codebook sets, and sorts blocks within their sets according to their index where applicable.\r\n */\r\nfunction _createCodeSets(args) {\r\n    const sets = _gatherSetBlocks(args);\r\n    // Loop through created sets and sort their blocks by index\r\n    for (let setName in sets) {\r\n        const set = sets[setName];\r\n        _sortCodeBlocks(set);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Gathers all Codebook blocks according to the order in which they appear in the markup,\r\n * and adds them to the set they belong to.\r\n */\r\nfunction _gatherSetBlocks(args) {\r\n    const $blocks = document.querySelectorAll(selectors.block);\r\n    const setNames = [];\r\n    const sets = {};\r\n    // Loop through all elements and add them to the right set\r\n    for (let $block of $blocks) {\r\n        const setName = _getSetName($block);\r\n        let set;\r\n        if (setNames.includes(setName)) {\r\n            set = sets[setName];\r\n        }\r\n        else {\r\n            setNames.push(setName);\r\n            set = _createNewSet(args);\r\n            sets[setName] = set;\r\n        }\r\n        set.blocks.push($block);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Sorts Codebook blocks according to their index data attribute, if they have one.\r\n */\r\nfunction _sortCodeBlocks(set) {\r\n    // If any blocks have an explicit index, sort them\r\n    set.blocks.sort(($blockA, $blockB) => {\r\n        const iA = $blockA.getAttribute(dataAttributes.index);\r\n        const iB = $blockB.getAttribute(dataAttributes.index);\r\n        if (iA === iB) {\r\n            return 0; // Leave the order unchanged\r\n        }\r\n        else if (iA !== null && iB === null) {\r\n            return -1; // Put $blockA first\r\n        }\r\n        else if (iA === null && iB !== null) {\r\n            return +1; // Put $blockB first\r\n        }\r\n        else {\r\n            // Neither index is null\r\n            return (+iA) - (+iB); // Put the code with the lower index first\r\n        }\r\n    });\r\n}\r\n/**\r\n * Creates a new Codebook set.\r\n */\r\nfunction _createNewSet(args) {\r\n    args = args || {};\r\n    return {\r\n        blocks: [],\r\n        args: Object.assign({}, args),\r\n    };\r\n}\r\n/**\r\n * Clears a set's logs, then runs each block within it with the `log` and `html` utility functions available.\r\n */\r\nfunction _runSet(set) {\r\n    const code = set.blocks.reduce(_combineCode, '');\r\n    _clearLogs(set);\r\n    const args = set.args;\r\n    const [argNames, argValues] = _spreadArgs(args);\r\n    if (argNames.includes('_log') ||\r\n        argNames.includes('_$log') ||\r\n        argNames.includes('log') ||\r\n        argNames.includes('_html') ||\r\n        argNames.includes('_$html') ||\r\n        argNames.includes('html')) {\r\n        throw new Error(`Codebook: The following argument names are reserved and cannot be used:\\n'_log', '_$log', 'log', '_html', '_$html', 'html'`);\r\n    }\r\n    const fnFactory = Function.apply(null, argNames.concat(['_log', '_html', `\r\n\t\treturn async () => {\r\n\t\t\t'use strict';\r\n\r\n\t\t\tlet _$log = null;\r\n\t\t\tlet log = function () {};\r\n\r\n\t\t\tlet _$html = null;\r\n\t\t\tlet html = function () {};\r\n\r\n\t\t\t${code}\r\n\t\t};\r\n\t`]));\r\n    const fn = fnFactory.apply(null, argValues.concat([_logOutput, _htmlOutput]));\r\n    return fn();\r\n}\r\n/**\r\n * Clears the contents of all log elements for each block in a given Codebook set.\r\n */\r\nfunction _clearLogs(set) {\r\n    for (let $block of set.blocks) {\r\n        const logId = $block.getAttribute(dataAttributes.log);\r\n        if (logId) {\r\n            const $log = document.getElementById(`${logId}`);\r\n            if ($log) {\r\n                $log.innerHTML = '';\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Converts a CodebookSetArgs object into separate arrays of its arguments' names and values.\r\n */\r\nfunction _spreadArgs(args) {\r\n    const names = Object.keys(args);\r\n    const values = Object.values(args);\r\n    return [\r\n        names,\r\n        values,\r\n    ];\r\n}\r\n/**\r\n * To be used with `Array.prototype.reduce`, combines the code for all blocks within\r\n * a Codebook set and ensures the special `log` and `html` functions always have correct values.\r\n */\r\nfunction _combineCode(allCode, $newCode) {\r\n    let newCode = _decodeHtml($newCode.textContent || '');\r\n    const logId = $newCode.getAttribute(dataAttributes.log);\r\n    if (logId) {\r\n        newCode = `\r\n\t\t\t_$log = document.getElementById('${logId}');\r\n\t\t\tlog = function (...output) {\r\n\t\t\t\t_log(_$log, ...output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\tlog = function () {};\r\n\t\t`;\r\n    }\r\n    const htmlId = $newCode.getAttribute(dataAttributes.html);\r\n    if (htmlId) {\r\n        newCode = `\r\n\t\t\t_$html = document.getElementById('${htmlId}');\r\n\t\t\thtml = function (output) {\r\n\t\t\t\t_html(_$html, output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\thtml = function () {};\r\n\t\t`;\r\n    }\r\n    const combinedCode = `${allCode}\\n${newCode}`;\r\n    return combinedCode;\r\n}\r\n/**\r\n * Read the name of a Codebook block's set.\r\n */\r\nfunction _getSetName($block) {\r\n    let setName = $block.getAttribute(dataAttributes.set);\r\n    if (!setName) {\r\n        const $parent = $block.closest(selectors.set);\r\n        if ($parent) {\r\n            setName = $parent.getAttribute(dataAttributes.set);\r\n        }\r\n        if (!setName) {\r\n            setName = defaultSetName;\r\n        }\r\n    }\r\n    return setName;\r\n}\r\n/**\r\n * A helper function used to create the special `log` function, allowing values inside\r\n * Codebook blocks to be logged to that block's log element.\r\n */\r\nfunction _logOutput($log, ...output) {\r\n    if ($log) {\r\n        output.forEach((outputEl) => {\r\n            let outputString;\r\n            if (outputEl instanceof Date) {\r\n                function padZeroes(num, minLength = 2) {\r\n                    let numStr = num.toString();\r\n                    while (numStr.length < minLength) {\r\n                        numStr = `0${numStr}`;\r\n                    }\r\n                    return numStr;\r\n                }\r\n                const year = outputEl.getFullYear();\r\n                const month = padZeroes(outputEl.getMonth() + 1);\r\n                const day = padZeroes(outputEl.getDate());\r\n                outputString = `${year}-${month}-${day}`;\r\n                if (outputEl.getHours() || outputEl.getMinutes() || outputEl.getSeconds()) {\r\n                    const hours = padZeroes(outputEl.getHours());\r\n                    const minutes = padZeroes(outputEl.getMinutes());\r\n                    const seconds = padZeroes(outputEl.getSeconds());\r\n                    outputString += ` ${hours}:${minutes}:${seconds}`;\r\n                }\r\n            }\r\n            else if (typeof outputEl === 'object') {\r\n                outputString = JSON.stringify(outputEl, null, '\\t');\r\n            }\r\n            else if (typeof outputEl === 'string') {\r\n                outputString = outputEl;\r\n            }\r\n            else {\r\n                // Can't rely on everything having a `toString` method, so use type coercion.\r\n                outputString = '' + outputEl;\r\n            }\r\n            $log.innerHTML += `${outputString}\\n`;\r\n        });\r\n    }\r\n}\r\n/**\r\n * A helper function used to create the special `html` function, allowing values inside\r\n * Codebook blocks to be logged to that block's html element.\r\n */\r\nfunction _htmlOutput($html, output) {\r\n    if ($html) {\r\n        $html.innerHTML = output;\r\n    }\r\n}\r\n/**\r\n * Decode HTML entities in a string by applying it as the value\r\n * of an HTMLTextAreaElement then reading it back again.\r\n */\r\nfunction _decodeHtml(htmlString) {\r\n    // We don't want to see things like =&gt; in code when we really mean =>\r\n    $textarea.innerHTML = htmlString;\r\n    const decodedString = $textarea.value;\r\n    return decodedString;\r\n}\r\n//# sourceMappingURL=codebook.js.map","/**\r\n * Converts a 2D Array into a CSV string.\r\n *\r\n * `stringify` converts most falsey values into empty cells. `undefined`, `''`, and `[]` are all treated this way. `null` and `false`, however, are converted into string representations when stringifying CSV data.\r\n *\r\n * If you need to maintain a value of `undefined`, `''`, or `[]` when stringifying your CSV data, convert it to a string first (e.g. `'undefined'`)\r\n *\r\n * @param {any[][]} data - A 2D Array to convert into a CSV string.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} CSV string\r\n */\r\nfunction stringify(data, options) {\r\n    options = options || {};\r\n    options.transpose = options.transpose || false;\r\n    options.sanitise = options.sanitise || false;\r\n    // Enforce square data and apply CSV escaping, then convert to string\r\n    const rows = data;\r\n    const shapedRows = _shape(data, options);\r\n    const escapedRows = _escape(shapedRows, options);\r\n    const joinedRows = _join(escapedRows);\r\n    return joinedRows;\r\n}\r\n/**\r\n * Pad missing cells with empty strings and, if necessary, transpose the data\r\n *\r\n * @param {any[][]} data - A 2D Array to pad and potentially transpose.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {any[][]} Shaped CSV data\r\n */\r\nfunction _shape(data, options) {\r\n    const transpose = options?.transpose ?? false;\r\n    const maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\r\n    // Flip rows and columns if transposing data\r\n    const iMax = transpose ? maxLength : data.length;\r\n    const jMax = transpose ? data.length : maxLength;\r\n    const rows = [];\r\n    for (let i = 0; i < iMax; i++) {\r\n        const row = [];\r\n        for (let j = 0; j < jMax; j++) {\r\n            const iRow = transpose ? j : i;\r\n            const iCol = transpose ? i : j;\r\n            let cellValue = data[iRow][iCol];\r\n            if (iCol >= data[iRow].length) {\r\n                cellValue = '';\r\n            }\r\n            row.push(cellValue);\r\n        }\r\n        rows.push(row);\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any[][]} rows - A 2D Array with values to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string[][]} Escaped CSV data\r\n */\r\nfunction _escape(rows, options) {\r\n    for (const row of rows) {\r\n        for (let j = 0; j < row.length; j++) {\r\n            row[j] = _escapeCell(row[j], options);\r\n        }\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any} cell - A single value to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} Escaped value\r\n */\r\nfunction _escapeCell(cell, options) {\r\n    const sanitise = options?.sanitise ?? false;\r\n    // Convert to string\r\n    let cellString;\r\n    if (typeof cell === 'undefined') {\r\n        // Replace undefined with ''\r\n        cellString = '';\r\n    }\r\n    else if (typeof cell !== 'string') {\r\n        // Convert to string\r\n        cellString = '' + cell;\r\n    }\r\n    else {\r\n        cellString = cell;\r\n    }\r\n    // Sanitise\r\n    if (sanitise) {\r\n        // Prevent spreadsheet software like\r\n        // Excel from trying to execute code\r\n        if (cellString.match(/^[=\\-+@]/)) {\r\n            cellString = '\\t' + cell;\r\n        }\r\n    }\r\n    // Escape\r\n    if (cellString.match(/,|\"|\\n|\\r/)) {\r\n        // Turn any double quotes into escaped double quotes\r\n        cellString = cellString.replace(/\"/g, '\"\"');\r\n        // Wrap cell in double quotes\r\n        cellString = '\"' + cellString + '\"';\r\n    }\r\n    return cellString;\r\n}\r\n/**\r\n * Join escaped CSV data into a single string.\r\n *\r\n * @param  {string[][]} rows - A 2D Array containing escaped CSV data\r\n *\r\n * @return {string} A CSV string\r\n */\r\nfunction _join(rows) {\r\n    const rowStrings = [];\r\n    for (let i = 0; i < rows.length; i++) {\r\n        rowStrings.push(rows[i].join(','));\r\n    }\r\n    const rowsString = rowStrings.join('\\n');\r\n    return rowsString;\r\n}\r\nexport { stringify };\r\n//# sourceMappingURL=stringify.js.map","function parse(csvString, mapper) {\r\n    const stringRows = _tokenise(csvString);\r\n    _validate(stringRows);\r\n    if (typeof mapper !== 'undefined') {\r\n        const dataRows = stringRows.map((row) => row.map(mapper));\r\n        return dataRows;\r\n    }\r\n    else {\r\n        return stringRows;\r\n    }\r\n}\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString) {\r\n    // Walk through each character and produce an array of tokens\r\n    const tokens = [];\r\n    // Remove carriage returns\r\n    csvString = csvString.replace(/\\r/g, '');\r\n    let inQuote = false;\r\n    let wasQuote = false;\r\n    let tokenStart = 0;\r\n    let row = [];\r\n    for (let i = 0; i < csvString.length; i++) {\r\n        const char = csvString[i];\r\n        const comma = char === ',';\r\n        const quote = char === '\"';\r\n        const newline = char === '\\n';\r\n        const eof = i === csvString.length - 1; // eof - End Of File\r\n        if (inQuote) {\r\n            // Characters may be delimited\r\n            if (quote) {\r\n                // Check if the next character is another double quote, i.e. if it is escaped\r\n                const nextChar = csvString[i + 1];\r\n                if (nextChar === '\"') {\r\n                    // This and the next character combined make an escaped double quote,\r\n                    // so the quote has not ended and we should skip over the next character\r\n                    i++;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // The quote has ended\r\n                    inQuote = false;\r\n                    wasQuote = true;\r\n                    if (!eof) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            else if (eof) {\r\n                throw new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n            }\r\n        }\r\n        if (!inQuote && (comma || newline || eof)) {\r\n            // These are the characters that denote the end of a token\r\n            let token = csvString.substring(tokenStart, i + 1);\r\n            if (comma || newline) {\r\n                // Don't keep the separator\r\n                token = token.substring(0, token.length - 1);\r\n            }\r\n            if (wasQuote) {\r\n                wasQuote = false;\r\n                // Remove start and end quotes\r\n                token = token.substring(1, token.length - 1);\r\n                // Replace escaped quotes\r\n                token = token.replace(/\"\"/g, '\"');\r\n            }\r\n            row.push(token);\r\n            if (comma && eof) {\r\n                // It's the end of the last token, and the last cell is empty\r\n                row.push('');\r\n            }\r\n            if (newline || eof) {\r\n                tokens.push(row);\r\n                if (newline) {\r\n                    row = [];\r\n                }\r\n            }\r\n            tokenStart = i + 1;\r\n        }\r\n        else if (wasQuote) {\r\n            throw new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n        }\r\n        else if (quote) {\r\n            inQuote = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows) {\r\n    // Each row of a CSV should have the same length;\r\n    if (rows && rows.length > 1) {\r\n        let rowLength = rows[0].length;\r\n        for (let i = 1; i < rows.length; i++) {\r\n            let row = rows[i];\r\n            if (row.length !== rowLength) {\r\n                throw new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport { parse };\r\n//# sourceMappingURL=parse.js.map","import { Data } from './Data.js';\r\n\r\nimport { InnerType } from './util.js';\r\n\r\n/**\r\n * A function for summarising a set of `Data`\r\n */\r\n// TODO: Should we know more information about `G` and `T` now that we have `RowShape`?\r\n type Summariser<RowShape extends Record<string, unknown>, G = unknown, T = unknown> = (rows: Data<RowShape>, groupName: G) => T;\r\n\r\n/**\r\n  * A group of `Summariser` functions\r\n  */\r\ntype Summarisers<SummaryName extends string, RowShape extends Record<string, unknown>> = Record<SummaryName, Summariser<RowShape>>;\r\n\r\n// TODO: Should satisfy `Summarisers<string, Record<string, unknown>>`\r\nconst defaultSummarisers = {\r\n\tCount: ((rows: unknown[]) => rows.length),\r\n} as const;\r\ntype DefaultSummaryName = keyof typeof defaultSummarisers;\r\n\r\n/**\r\n* A 2D array of the results of Summariser functions applied to an AnalyserGroup of Data,\r\n* able to be printed to the console using `console.table`.\r\n*\r\n* After the first header row, each row represents a set of Data grouped by the value given in the first cell.\r\n* After the first column, each column represents a summary of a group of Data. The name of the summary is given in the first cell.\r\n*/\r\nexport type Summary<SummaryName extends string> = [[unknown, ...SummaryName[]], ...[unknown, ...unknown[]][]];\r\n\r\ninterface DataGroupOptions {\r\n\tdiscrete?: boolean,\r\n}\r\n\r\n/**\r\n * This class extends the native {@linkcode Map} class to add an additional method. It is primarily intended\r\n * to be interacted with only through this {@linkcode DataGroup.summarise summarise} method.\r\n */\r\nexport class DataGroup<RowShape extends Record<string, unknown>, ColName extends keyof RowShape> extends Map<InnerType<RowShape[ColName]>, Data<RowShape>> {\r\n\t#discrete: boolean;\r\n\r\n\tconstructor(options?: DataGroupOptions) {\r\n\t\tsuper();\r\n\r\n\t\tif (typeof options?.discrete === 'boolean') {\r\n\t\t\tthis.#discrete = options.discrete;\r\n\t\t} else {\r\n\t\t\tthis.#discrete = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method converts a {@linkcode DataGroup} into a specially formatted 2D array made for easy viewing.\r\n\t * The first row is a header row, giving the name of each summary, and the first column gives the name of\r\n\t * each group from the {@linkcode DataGroup} used to create it. The other cells each contain a particular\r\n\t * summary of that group.\r\n\t *\r\n\t * By default, if not passed a `summarisers` argument, the default \"Count\" summary will be used. This summary\r\n\t * counts the number of rows in each group.\r\n\t *\r\n\t * More complex summaries can be passed as an object where each property is a function that takes a {@linkcode Data}\r\n\t * object and the name of its group, and produces some result.\r\n\t *\r\n\t * Summaries that produce numeric results can then be used to create graphs.\r\n\t *\r\n\t * @example\r\n\t * ```typescript\r\n\t * const fileConfig = analyser.fileConfig({\r\n\t *     path: '/analyser/assets/data/city example.csv',\r\n\t *     cols: {\r\n\t *         country: ['B', analyser.types.string],\r\n\t *         population: ['C', analyser.types.number],\r\n\t *     },\r\n\t *     headerRows: 1,\r\n\t *     footerRows: 1,\r\n\t *     aliases: [\r\n\t *         ['Aotearoa', 'New Zealand'],\r\n\t *     ],\r\n\t * });\r\n\t *\r\n\t * const rows = await analyser.loadFile(fileConfig);\r\n\t *\r\n\t * const countryGroup = rows.groupBy('country');\r\n\t *\r\n\t * const countSummary = countryGroup.summarise();\r\n\t * log('Count of cities by country:', countSummary);\r\n\t *\r\n\t * const meanPopulationSummary = countryGroup.summarise({\r\n\t *     mean: (rows, groupName) => analyser.statistics.mean(rows.map(({ population }) => population)),\r\n\t * });\r\n\t * log('Mean city population by country:', meanPopulationSummary);\r\n\t * ```\r\n\t */\r\n\tsummarise(): Summary<DefaultSummaryName>\r\n\tsummarise<SummaryName extends string>(summarisers: Summarisers<SummaryName, RowShape>): Summary<SummaryName>\r\n\tsummarise<SummaryName extends string>(summarisersArg?: Summarisers<SummaryName, RowShape>): Summary<DefaultSummaryName> | Summary<SummaryName> {\r\n\t\t// If there was no argument, use a default value instead. This will affect the return type, as per the overloads\r\n\t\tconst summarisers = summarisersArg ?? defaultSummarisers;\r\n\r\n\t\tconst summaryNames = Object.keys(summarisers) as (DefaultSummaryName)[] | SummaryName[];\r\n\t\tconst summaryHeaderRow = ['Value', ...summaryNames] as const;\r\n\r\n\t\tlet summaryValueRows: [unknown, ...unknown[]][] = [];\r\n\t\tfor (const [groupName, rows] of this.entries()) {\r\n\t\t\tconst summaryRow: [unknown, ...unknown[]] = [groupName];\r\n\r\n\t\t\tfor (const [, summariser] of Object.entries<Summariser<RowShape>>(summarisers)) {\r\n\t\t\t\tconst rowSummary = summariser(rows, groupName);\r\n\t\t\t\tsummaryRow.push(rowSummary);\r\n\t\t\t}\r\n\r\n\t\t\tsummaryValueRows.push(summaryRow);\r\n\t\t}\r\n\r\n\t\tif (this.#discrete) {\r\n\t\t\t// Sort summary based on its values\r\n\r\n\t\t\t// Use basic Array.prototype.sort to sort numbers or strings, to use as a reference when sorting the summary\r\n\t\t\tconst summaryValues = summaryValueRows.map((summaryRow) => summaryRow[0]);\r\n\t\t\tconst summaryValuesSorted = summaryValues.sort();\r\n\r\n\t\t\t// Sort summary value rows using the sorted values as a reference\r\n\t\t\tsummaryValueRows = summaryValueRows.sort((a, b) => summaryValuesSorted.indexOf(a[0]) - summaryValuesSorted.indexOf(b[0]));\r\n\t\t}\r\n\r\n\t\tconst summary = [summaryHeaderRow, ...summaryValueRows];\r\n\r\n\t\t// Let the overloads tell TypeScript which type the summary actually is.\r\n\t\t// If there was no `summarisersArg` argument, it will be Summary<DefaultSummaryNames>,\r\n\t\t// otherwise the type T could be inferred so no default was necessary and it will be Summary<SummaryName>\r\n\t\treturn summary as Summary<DefaultSummaryName> | Summary<SummaryName>;\r\n\t}\r\n}\r\n","import { matchWithAlias } from './file-processing.js';\r\n\r\nimport { DataGroup } from './DataGroup.js';\r\n\r\nimport { InnerType } from './util.js';\r\n\r\n// Type-only imports to make symbols available to JSDoc.\r\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\nimport type { FileConfig } from './FileConfig.js';\r\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\nimport type { loadFile } from './file-processing.js';\r\n\r\nexport interface Data<RowShape extends Record<string, unknown>> {\r\n\tfilter(...args: Parameters<Array<RowShape>['filter']>): Data<RowShape>;\r\n}\r\n\r\n/**\r\n * This class extends the native {@linkcode Array} class. For most purposes, it can be treated\r\n * the same as any regular `Array`, for example by calling methods such as {@linkcode Array.prototype.filter}.\r\n *\r\n * The key difference between `Data` and a native `Array` is that, if the data was processed with a set\r\n * of {@link FileConfig.aliases aliases}, these aliases will be preserved in the {@linkcode Data.aliases aliases}\r\n * property.\r\n *\r\n * @see {@linkcode loadFile} for how to create `Data` objects.\r\n * @see {@linkcode matchWithAlias} for how to filter string data in a way that respects aliases\r\n */\r\nexport class Data<RowShape extends Record<string, unknown>> extends Array<RowShape> {\r\n\t/**\r\n\t * If {@linkcode loadFile} was called with a {@linkcode FileConfig} that contained an\r\n\t * {@linkcode FileConfig.aliases aliases} property, those aliases are preserved here.\r\n\t * This makes them available to be used with the {@linkcode matchWithAlias} method.\r\n\t */\r\n\taliases?: string[][];\r\n\r\n\tconstructor(source?: number | Array<RowShape>, aliases?: string[][]) {\r\n\t\tif (Array.isArray(source)) {\r\n\t\t\tsuper(source.length);\r\n\t\t\tfor (let i = 0; i < source.length; i++) {\r\n\t\t\t\tthis[i] = source[i];\r\n\t\t\t}\r\n\t\t} else if (typeof source === 'number') {\r\n\t\t\tsuper(source);\r\n\t\t} else {\r\n\t\t\tsuper();\r\n\t\t}\r\n\r\n\t\tif (aliases) {\r\n\t\t\tthis.aliases = aliases;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method is used to add a new row to a `Data` object.\r\n\t *\r\n\t * To ensure proper type inference when working with TypeScript, this returns a new `Data`\r\n\t * object that contains the new column.\r\n\t *\r\n\t * There are two overloads available. The primary overload relies on a `creator` function,\r\n\t * which works similarly to a function passed to {@linkcode Array.prototype.map}. This\r\n\t * `creator` function takes a single row object and that row's index, and creates the valueu\r\n\t * that row should have in the new column.\r\n\t *\r\n\t * The second overload simply passes a newly constructed column in its entirety, as an array.\r\n\t * This array must be of the same length as the `Data` object being added to.\r\n\t */\r\n\taddCol<ColName extends string, T>(colName: ColName, creator: (row: RowShape, index: number, data: RowShape[]) => T): Data<RowShape & Record<ColName, T>>\r\n\taddCol<ColName extends string, T>(colName: ColName, newRow: T[]): Data<RowShape & Record<ColName, T>>\r\n\taddCol<ColName extends string, T>(colName: ColName, creator: ((row: RowShape, index: number, data: RowShape[]) => T) | T[]) {\r\n\t\tif (Array.isArray(creator)) {\r\n\t\t\tconst newRow = creator;\r\n\t\t\tif (this.length !== newRow.length) {\r\n\t\t\t\tthrow new Error(`New column of length ${newRow.length} cannot be added. It must be of length ${this.length}.`);\r\n\t\t\t}\r\n\r\n\t\t\tconst newRows = this.map((row, i, data) => {\r\n\t\t\t\treturn Object.assign(\r\n\t\t\t\t\t{},\r\n\t\t\t\t\trow,\r\n\t\t\t\t\t{ [colName]: newRow[i] },\r\n\t\t\t\t);\r\n\t\t\t});\r\n\r\n\t\t\treturn new Data(newRows);\r\n\t\t}\r\n\r\n\t\tconst newRows = this.map((row, i, data) => {\r\n\t\t\treturn Object.assign(\r\n\t\t\t\t{},\r\n\t\t\t\trow,\r\n\t\t\t\t{ [colName]: creator(row, i, data) },\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\treturn new Data(newRows);\r\n\t}\r\n\r\n\t/**\r\n\t * This method is used for grouping rows in a {@linkcode Data} object.\r\n\t *\r\n\t * These groups can then be used to produce summaries of the data, which in turn can be used to create graphs.\r\n\t *\r\n\t * This method effectively has any {@linkcode FileConfig.aliases aliases} baked in, with any values\r\n\t * in a set of aliases treated as though they were the first value in that set. That first value does not need\r\n\t * to appear in the data, but it will always be used in any {@linkcode DataGroup} created by this method.\r\n\t *\r\n\t * `groupBy` has three overrides.\r\n\t *\r\n\t * When grouping by discrete data, thie first override that only specifies a `colName` should always be used.\r\n\t * The other two overrides provide different methods for dividing continuous data into groups.\r\n\t *\r\n\t * If the `numGroups` argument is provided with a number, continuous data will be split into that many groups\r\n\t * of the same range. For example, if the data ranges from `0` to `100` and the `numGroups` argument is `5`,\r\n\t * the first group would contain data from `0` to `20`.\r\n\t *\r\n\t * Otherwise, the `splitPoints` argument can be provided with an array of numbers, which will be used as the\r\n\t * points where the groups will be split.\r\n\t *\r\n\t * For both of the continuous data overloads, there is an optional `right` argument that determines which end\r\n\t * of a group is open. If `right` is `true` (its default value), then values equal to the upper limit of a group\r\n\t * will be included. Otherwise, values equal to a group's lower limit will be included instead.\r\n\t *\r\n\t * However, the first and last groups will always include values at their outer boundaries, since they will be\r\n\t * determined based on the minimum and maximum values in the data set.\r\n\t */\r\n\tgroupBy<ColName extends keyof RowShape>(colName: ColName): DataGroup<RowShape, ColName>\r\n\tgroupBy<ColName extends keyof RowShape>(colName: ColName, numGroups: number, right?: boolean): DataGroup<RowShape, ColName>\r\n\tgroupBy<ColName extends keyof RowShape>(colName: ColName, splitPoints: number[], right?: boolean): DataGroup<RowShape, ColName>\r\n\tgroupBy<ColName extends keyof RowShape>(colName: ColName, splitting?: number | number[], right: boolean = true): DataGroup<RowShape, ColName> {\r\n\t\tif (typeof splitting === 'undefined') {\r\n\t\t\t// Treat data without any splitting instructions as discrete\r\n\t\t\treturn groupDiscreteData(this, colName);\r\n\t\t} else {\r\n\t\t\treturn groupContinuousData(this, colName, splitting, right);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Collects all values of a discrete column in a {@linkcode Data} object, including the inner values of array types\r\n */\r\nfunction collectEnums<RowShape extends Record<string, unknown>, ColName extends keyof RowShape>(data: Data<RowShape>, colName: ColName): Set<InnerType<RowShape[ColName]>> {\r\n\tconst enums = new Set<InnerType<RowShape[ColName]>>();\r\n\r\n\t// First, collect all values\r\n\tfor (const row of data) {\r\n\t\tconst cellValue = row[colName];\r\n\r\n\t\tif (Array.isArray(cellValue)) {\r\n\t\t\tfor (const value of cellValue) {\r\n\t\t\t\t// Type assertion is safe here since `InnerType<T>` resolves to the type of an array's elements' values if `T` is an array\r\n\t\t\t\tenums.add(value as InnerType<typeof cellValue>);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Type assertion is safe here since `InnerType<T>` resolves to `T` if it's not an array\r\n\t\t\tenums.add(cellValue as InnerType<typeof cellValue>);\r\n\t\t}\r\n\t}\r\n\r\n\t// Then, if there are aliases, remove any values that are non-canonical members of alias groups\r\n\tif (data.aliases) {\r\n\t\tfor (const val of enums) {\r\n\t\t\tif (typeof val === 'string') {\r\n\t\t\t\t// If the value is a string in one or more alias sets,\r\n\t\t\t\t// ensure those sets will be used for grouping and\r\n\t\t\t\t// ensure only canonical values will be checked directly.\r\n\r\n\t\t\t\t/** If the value appears in at least one alias list and is **not** the canonical value */\r\n\t\t\t\tlet isNonCanonical = false;\r\n\r\n\t\t\t\t/** If the value appears in at least one alias list and **is** the canonical value */\r\n\t\t\t\tlet isCanonical = false;\r\n\r\n\t\t\t\tfor (const aliasGroup of data.aliases) {\r\n\t\t\t\t\t// This type assertion is safe since, if we've reached this point, `string` extends `InnerType<RowShape[ColName]>`\r\n\t\t\t\t\tconst canonicalAliasMember = aliasGroup[0] as InnerType<RowShape[ColName]>;\r\n\t\t\t\t\tif (aliasGroup.includes(val)) {\r\n\t\t\t\t\t\tif (val === canonicalAliasMember) {\r\n\t\t\t\t\t\t\tisCanonical = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tisNonCanonical = true;\r\n\r\n\t\t\t\t\t\t\t// Remember the canonical value\r\n\t\t\t\t\t\t\tif (enums.has(canonicalAliasMember) === false) {\r\n\t\t\t\t\t\t\t\tenums.add(canonicalAliasMember);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If the value is one one or more alias sets, but is never the canonical value,\r\n\t\t\t\t// then remove it from the set of enums to use for grouping.\r\n\t\t\t\tif (isCanonical === false && isNonCanonical === true) {\r\n\t\t\t\t\tenums.delete(val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn enums;\r\n}\r\n\r\n/**\r\n * Create a {@linkcode DataGroup} for a discrete column of a {@linkcode Data} object\r\n */\r\nfunction groupDiscreteData<RowShape extends Record<string, unknown>, ColName extends keyof RowShape>(data: Data<RowShape>, colName: ColName): DataGroup<RowShape, ColName> {\r\n\t// First, collect enums\r\n\tconst enums = collectEnums(data, colName);\r\n\r\n\tconst group = new DataGroup<RowShape, ColName>();\r\n\r\n\t// Then, interate through each enum and filter rows into groups\r\n\tfor (const val of enums) {\r\n\t\tconst matchingRows = data.filter((row) => matchWithAlias(row[colName], val, data.aliases));\r\n\t\tgroup.set(val, matchingRows);\r\n\t}\r\n\r\n\treturn group;\r\n}\r\n\r\n/**\r\n * Create a {@linkcode DataGroup} for a continuous column of a {@linkcode Data} object\r\n */\r\nfunction groupContinuousData<RowShape extends Record<string, unknown>, ColName extends keyof RowShape>(data: Data<RowShape>, colName: ColName, splitting: number | number[], right?: boolean): DataGroup<RowShape, ColName> {\r\n\tconst enums = collectEnums(data, colName);\r\n\r\n\t// Create the limits for each set\r\n\tconst setLimits: [number, number][] = [];\r\n\tif (typeof splitting === 'number') {\r\n\t\t// Create splitting number of groups based on values retrieved\r\n\r\n\t\tif (Number.isInteger(splitting) === false || splitting < 2) {\r\n\t\t\tthrow new RangeError(`The 'numGroups' argument must be an integer greater than 1.`);\r\n\t\t}\r\n\r\n\t\t// Sets are unordered, so create and sort an array (ascending)\r\n\t\tconst enumArr = [...enums];\r\n\t\tconst isNumber = (x: unknown): x is number => typeof x === 'number';\r\n\t\tconst isNumArr = (arr: unknown[]): arr is number[] => arr.every(isNumber);\r\n\r\n\t\tif (isNumArr(enumArr)) {\r\n\t\t\tconst values = enumArr.sort((a: number, b: number) => a - b);\r\n\r\n\t\t\tconst [min, max] = [values[0], values[values.length-1]];\r\n\r\n\t\t\tconst setSize = (max - min) / splitting;\r\n\t\t\tfor (let i = 0; i < splitting; i++) {\r\n\t\t\t\tconst setMin = min + i * setSize;\r\n\t\t\t\tconst setMax = min + (i+1) * setSize;\r\n\r\n\t\t\t\tsetLimits.push([setMin, setMax]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthrow new TypeError(`Cannot split values based on a number unless each of those values is a number.`);\r\n\t\t}\r\n\r\n\t\t// The first and last sets should be unbounded\r\n\t\tsetLimits[0][0] = -Infinity;\r\n\t\tsetLimits[setLimits.length - 1][1] = Infinity;\r\n\t} else if (Array.isArray(splitting)) {\r\n\t\tif (splitting.length === 0) {\r\n\t\t\tthrow new RangeError(`At least one number is required for the 'splitPoints' argument.`);\r\n\t\t} else if (splitting.every((val) => typeof val === 'number') === false) {\r\n\t\t\tthrow new TypeError(`All 'splitPoints' must be numbers.`);\r\n\t\t}\r\n\r\n\t\t// Ensure splitting values are ordered (ascending)\r\n\t\tconst splitValues = splitting.concat().sort((a, b) => a - b);\r\n\r\n\t\t// Outer bounds will be -Infinity and Infinity\r\n\t\tsetLimits.push([-Infinity, splitValues[0]]);\r\n\r\n\t\tfor (let i = 0; i < splitValues.length-1; i++) {\r\n\t\t\tsetLimits.push([splitValues[i], splitValues[i+1]]);\r\n\t\t}\r\n\r\n\t\tsetLimits.push([splitValues[splitValues.length-1], Infinity]);\r\n\t} else {\r\n\t\tthrow new TypeError(`Invalid argument type: ${typeof splitting}`);\r\n\t}\r\n\r\n\t// Group rows based on set limits\r\n\tconst group = new DataGroup<RowShape, ColName>();\r\n\tfor (const set of setLimits) {\r\n\t\tlet setName = '';\r\n\t\tlet filterFn: (row: RowShape) => boolean;\r\n\r\n\t\tif (right) {\r\n\t\t\tif (set[0] !== -Infinity) {\r\n\t\t\t\tsetName += `${set[0]} < `;\r\n\t\t\t}\r\n\t\t\tsetName += `x`;\r\n\t\t\tif (set[1] !== Infinity) {\r\n\t\t\t\tsetName += ` <= ${set[1]}`;\r\n\t\t\t}\r\n\r\n\t\t\tfilterFn = (row) => {\r\n\t\t\t\tconst cellValue = row[colName];\r\n\t\t\t\treturn typeof cellValue === 'number' &&\r\n\t\t\t\t\tset[0] < cellValue &&\r\n\t\t\t\t\tcellValue <= set[1];\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tif (set[0] !== -Infinity) {\r\n\t\t\t\tsetName += `${set[0]} <= `;\r\n\t\t\t}\r\n\t\t\tsetName += `x`;\r\n\t\t\tif (set[1] !== Infinity) {\r\n\t\t\t\tsetName += ` < ${set[1]}`;\r\n\t\t\t}\r\n\r\n\t\t\tfilterFn = (row) => {\r\n\t\t\t\tconst cellValue = row[colName];\r\n\t\t\t\treturn typeof cellValue === 'number' &&\r\n\t\t\t\t\tset[0] <= cellValue\r\n\t\t\t\t\t&& cellValue < set[1];\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tconst matchingRows = data.filter(filterFn);\r\n\r\n\t\t// TODO: Need to determine how to tell TypeScript when a group will be indexed by a string\r\n\t\t// @ts-expect-error This is temporary\r\n\t\tgroup.set(setName, matchingRows);\r\n\t}\r\n\r\n\treturn group;\r\n}\r\n","import { TypeFn } from './TypeFn.js';\r\n\r\n/**\r\n * Leaves a string value unchanged\r\n */\r\nexport const string: TypeFn<string> = function string(value) { return value; };\r\n","import { TypeFn } from './TypeFn.js';\r\n\r\n/**\r\n * Removes any ',' characters, and any '%' at the end of a string that may appear like it represents a number\r\n */\r\nfunction cleanNumberLike(value: string): string {\r\n\tconst cleanValue = value.replace(/,|%$/g, '');\r\n\treturn cleanValue;\r\n}\r\n\r\n/**\r\n * Check if a string appears like it represents a number\r\n */\r\nfunction appearsNumber(value: string): boolean {\r\n\tconst cleanValue = cleanNumberLike(value);\r\n\r\n\treturn parseFloat(cleanValue) === Number(cleanValue);\r\n}\r\n\r\n/**\r\n * Checks if a string appears like it represents a percentage\r\n */\r\nfunction appearsPercentage(value: string): boolean {\r\n\treturn appearsNumber(value) && Boolean(value.match(/%$/));\r\n}\r\n\r\n/**\r\n * If a value looks like a number, it will be converted to a number.\r\n * String representations of numbers are expected to usue the `'.'` character for a\r\n * decimal point, and optionally the `','` character for separators within the number.\r\n *\r\n * If a string looks like a number and also ends with a `'%'` character, it will be\r\n * divided by `100` to convert it into a percentage.\r\n */\r\nexport const number: TypeFn<number> = function number(value) {\r\n\tif (appearsNumber(value)) {\r\n\t\tlet cleanValue = cleanNumberLike(value);\r\n\r\n\t\tif (appearsPercentage(value)) {\r\n\t\t\t// If value is a percentage string, divide by 100\r\n\t\t\tconst numValue = Number(cleanValue) / 100;\r\n\r\n\t\t\t// To prevent division causing rounding errors, like 0.10800000000000001, use string representation to, use string representation to determine how to round the number.\r\n\r\n\t\t\t// Remove everything up to (and including) a radix point, e.g. convert '82.643' to '643'\r\n\t\t\tconst truncatedValue = cleanValue.replace(/^[^.]+\\.?/, '');\r\n\t\t\tconst precision = truncatedValue.length;\r\n\r\n\t\t\t// Add 2 to precision to compensate for dividing by 100\r\n\t\t\tcleanValue = numValue.toFixed(precision + 2);\r\n\t\t}\r\n\r\n\t\treturn Number(cleanValue);\r\n\t} else {\r\n\t\tthrow new Error(`Number value not found in '${value}'`);\r\n\t}\r\n};\r\n","import { TypeFn } from './TypeFn.js';\r\n\r\n/**\r\n * Used to create a custom {@linkcode TypeFn type function} for converting a string into boolean values.\r\n *\r\n * If a value matches the string or regular expression in the `truthy` argument, it will be converted to `true`.\r\n * Otherwise, if it matches the string or regular expression in the `falsey` argument, it will be converted to `false`.\r\n *\r\n * If strings are specified, the matching will be exact using `===`. If you need your match to be case-insensitive,\r\n * or to ignore leading or trailing whitespace, then use a regular expression instead.\r\n */\r\nexport function booleanCustom(truthy: string | RegExp, falsey: string | RegExp): TypeFn<boolean> {\r\n\tconst boolean: TypeFn<boolean> = function boolean(value) {\r\n\t\tif (typeof truthy === 'string') {\r\n\t\t\tif (value === truthy) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (truthy.test(value)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (typeof falsey === 'string') {\r\n\t\t\tif (value === falsey) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (falsey.test(value)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow new Error(`Boolean value not found in '${value}', checking for ${truthy} or ${falsey}`);\r\n\t};\r\n\r\n\treturn boolean;\r\n}\r\n\r\n/**\r\n * If a value is `'true'` or `'false'`, ignoring case and any leading or trailing whitespace,\r\n * then it is converted to the relevant boolean value.\r\n */\r\nexport const boolean = booleanCustom(/^\\s*true\\s*$/i, /^\\s*false\\s*$/i);\r\n","import { TypeFn } from './TypeFn.js';\r\n\r\nimport { boolean } from './boolean.js';\r\nimport { number } from './number.js';\r\n\r\n/**\r\n * Combines the {@linkcode boolean} and {@linkcode number} {@linkcode TypeFn type functions}.\r\n *\r\n * If a value looks like it contains a boolean, it will be converted to a boolean.\r\n * Otherwise, if it looks like it contains a number, it will be convered to a number.\r\n */\r\nexport const value: TypeFn<boolean | number> = function value(value) {\r\n\ttry {\r\n\t\treturn boolean(value);\r\n\t} catch (e) {\r\n\t\ttry {\r\n\t\t\treturn number(value);\r\n\t\t} catch (e) {\r\n\t\t\tthrow new Error(`Boolean or number value not found in '${value}'`);\r\n\t\t}\r\n\t}\r\n};\r\n","import { TypeFn } from './TypeFn.js';\r\n\r\n/**\r\n * Used to create a {@linkcode TypeFn type function} that converts a string into an array of strings.\r\n *\r\n * The arguments are the same as those used by {@linkcode String.prototype.split}.\r\n */\r\nexport function array(separator: string | RegExp, limit?: number): TypeFn<string[]> {\r\n\treturn (value) => {\r\n\t\tconst result = value.split(separator, limit);\r\n\r\n\t\tif (result.length === 1 && result[0] === '') {\r\n\t\t\t// Return `[]` instead of `['']`\r\n\t\t\treturn [];\r\n\t\t} else {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t};\r\n}\r\n","import { TypeFn } from './TypeFn.js';\r\nimport { isIterable } from '../util.js';\r\n\r\n/**\r\n * Used to create a custom {@linkcode TypeFn type function} that ensures that a value exists within\r\n * an object like a string {@link https://www.typescriptlang.org/docs/handbook/enums.html TypeScript enum}.\r\n *\r\n * @param [recodeMap]\r\n * By default, this function doesn't transform the values passed into it. Instead, it acts as a check that they\r\n * exist within the passed `enum`.\r\n *\r\n * However, this optional parameter can be used to transform strings that don't exist within the `enum` into\r\n * strings that are members. These transformations are applied *before* the value's membership is checked.\r\n * This can be particularly useful for data cleaning.\r\n *\r\n * If this argument is an `Iterable<[string, E]>`, such as a {@linkcode Map}, only the first matching entry will be used.\r\n */\r\nexport function enumValue<E extends string>(enums: Record<string, E>, recodeMap?: Record<string, E> | Iterable<[string, E]>): TypeFn<E> {\r\n\tconst enumValues = Object.values(enums);\r\n\r\n\tfunction isEnumMember(val: unknown): val is E {\r\n\t\t// Use `as unknown[]` so TypeScript doesn't complain when using Array.prototype.includes\r\n\t\treturn (enumValues as unknown[]).includes(val);\r\n\t}\r\n\r\n\tconst enumValue: TypeFn<E> = function enumValue(value) {\r\n\t\tif (!value) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (isEnumMember(value)) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tif (recodeMap) {\r\n\t\t\tif (isIterable(recodeMap)) {\r\n\t\t\t\tfor (const [testValue, recodedValue] of recodeMap) {\r\n\t\t\t\t\tif (testValue === value) {\r\n\t\t\t\t\t\treturn recodedValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst recodedValue = recodeMap[value];\r\n\t\t\t\treturn recodedValue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow new Error(`Value '${value}' does not exist within ${enumValues.join(', ')}`);\r\n\t} as TypeFn<E>;\r\n\t// Need to use a type assertion here as TypeScript doesn't know how to use the generic constraint to resolve the conditional type\r\n\t// See https://stackoverflow.com/questions/70553130/typescript-generic-conditional-type-as-return-value-for-generic-function/70553240#70553240\r\n\r\n\treturn enumValue;\r\n}\r\n","export type InnerType<T> = T extends Array<infer E> ? E : T;\r\n\r\n/**\r\n * Check if an object is iterable\r\n */\r\nexport function isIterable<T = unknown>(testObj: unknown): testObj is Iterable<T> {\r\n\tconst obj = testObj as Iterable<T>;\r\n\r\n\tif (typeof obj[Symbol.iterator] !== 'function') {\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n","import { parse as parseCSV } from '@cipscis/csv';\r\n\r\nimport { FileConfig } from './FileConfig.js';\r\nimport { Data } from './Data.js';\r\nimport * as types from './types/index.js';\r\n\r\n// Type-only import to make symbol available to JSDoc.\r\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\nimport type { TypeFn } from './types/TypeFn.js';\r\n\r\n/**\r\n * Used to configure the behaviour of {@linkcode loadFile}\r\n */\r\ninterface LoadFileOptions {\r\n\t/**\r\n\t * This property controls how {@linkcode loadFile} deals with errors\r\n\t * being thrown by {@linkcode TypeFn type functions}.\r\n\t *\r\n\t * By default, these errors will not be caught, so they will output an\r\n\t * error to the console detailing where the value that caused the error\r\n\t * exists in your ddata.\r\n\t *\r\n\t * However, if {@linkcode LoadFileOptions.strict} is set to `false`, then\r\n\t * instead these errors will result in a warning being output to the console,\r\n\t * and the value that caused the error will be converted to `null`.\r\n\t *\r\n\t * This non-strict mode should only be used when initially determining how\r\n\t * a data set should be processed, as the conversion of data to `null` is not\r\n\t * type-safe.\r\n\t */\r\n\tstrict?: boolean;\r\n}\r\n\r\nconst defaultOptions: LoadFileOptions = {\r\n\tstrict: true,\r\n};\r\n\r\n/**\r\n * Loads a single CSV file configured with a {@linkcode FileConfig} object.\r\n *\r\n * If the file is loaded and processed successfully, the `Promise` returned\r\n * will resolve to a {@linkcode Data} object.\r\n *\r\n * @see {@linkcode LoadFileOptions}\r\n */\r\nexport async function loadFile<\r\n\tRowShape extends Record<string, unknown>,\r\n>(fileConfig: FileConfig<keyof RowShape & string, RowShape>, options?: LoadFileOptions): Promise<Data<RowShape>> {\r\n\tconst optionsWithDefaults: LoadFileOptions = Object.assign({}, defaultOptions, options ?? {});\r\n\r\n\tconst response = await fetch(fileConfig.path);\r\n\r\n\tif (response.ok) {\r\n\t\tconst data = await response.text();\r\n\r\n\t\tconst rows = parseCSV(data);\r\n\t\tconst processedData = processData(rows, fileConfig, optionsWithDefaults);\r\n\t\treturn processedData;\r\n\t}  else {\r\n\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status} ${response.statusText}`);\r\n\t}\r\n}\r\n\r\n/**\r\n * Processes CSV data into usable, typed data.\r\n */\r\nfunction processData<\r\n\tColName extends string,\r\n\tRowShape extends Record<ColName, unknown>,\r\n>(rows: readonly string[][], fileConfig: FileConfig<ColName, RowShape>, options: LoadFileOptions): Data<RowShape> {\r\n\tconst dataRows = rows.map((row) => row.concat());\r\n\r\n\t// Remove header rows\r\n\tif (fileConfig.headerRows) {\r\n\t\tdataRows.splice(0, fileConfig.headerRows);\r\n\t}\r\n\r\n\t// Remove footer rows\r\n\tif (fileConfig.footerRows) {\r\n\t\tdataRows.splice(-fileConfig.footerRows);\r\n\t}\r\n\r\n\t// Convert rows from index-based to name-based\r\n\tconst cols = getColNumbers<ColName>(fileConfig.cols);\r\n\tconst namedRows: Record<ColName, string>[] = dataRows.map((row) => {\r\n\t\tconst namedRow: Partial<Record<ColName, string>> = {};\r\n\r\n\t\tfor (const colName in cols) {\r\n\t\t\tnamedRow[colName] = row[cols[colName]];\r\n\t\t}\r\n\r\n\t\treturn namedRow as Record<ColName, string>;\r\n\t});\r\n\r\n\t// Transform each column into its configured type\r\n\tconst typedRows: RowShape[] = namedRows.map((row, i) => {\r\n\t\tconst typedRow: Partial<RowShape> = {};\r\n\r\n\t\tfor (const colName in row) {\r\n\t\t\tconst transformFn = fileConfig.cols[colName][1];\r\n\r\n\t\t\t// These conditions are intended to help when TypeScript isn't being used\r\n\t\t\tif (transformFn === types.array) {\r\n\t\t\t\tthrow new Error(`The 'array' type function cannot be used directly. Please pass a 'separator' argument.`);\r\n\t\t\t} else if (transformFn === types.booleanCustom) {\r\n\t\t\t\tthrow new Error(`The 'booleanCustom' type function cannot be used directly. Please pass 'truthy' and 'falsey' arguments.`);\r\n\t\t\t// @ts-expect-error This check is only intended to catch errors if an incorrectly typed value is passed\r\n\t\t\t} else if (transformFn === types.enumValue) {\r\n\t\t\t\tthrow new Error(`The 'enumValue' type function cannot be used directly. Please pass an 'enums' argument.`);\r\n\t\t\t}\r\n\r\n\t\t\t// Type functions will throw an error if their assumptions are violated\r\n\t\t\ttry {\r\n\t\t\t\ttypedRow[colName as ColName] = transformFn(row[colName]);\r\n\t\t\t} catch (e) {\r\n\t\t\t\tif (e instanceof Error) {\r\n\t\t\t\t\tconst locationIdentifier = `File: ${fileConfig.path}, Row: ${i}, Column: ${colName}`;\r\n\t\t\t\t\tconst message = `${e.message} (${locationIdentifier})`;\r\n\r\n\t\t\t\t\tif (options.strict) {\r\n\t\t\t\t\t\tconsole.error(message);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.warn(message);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (options.strict) {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn typedRow as RowShape;\r\n\t});\r\n\r\n\t// Remove any specified rows to ignore\r\n\tconst { ignoreRows } = fileConfig;\r\n\tif (ignoreRows) {\r\n\t\t// Find all rows that match the `ignoreRows` function\r\n\t\tconst rowsToIgnore = typedRows.filter((row) => ignoreRows(row));\r\n\r\n\t\t// If we found any rows to ignore, remove them\r\n\t\tif (rowsToIgnore.length > 0) {\r\n\t\t\t// Count backwards so we don't need to update our cursor after splicing\r\n\t\t\tfor (let i = typedRows.length - 1; i >= 0; i--) {\r\n\t\t\t\tconst row = typedRows[i];\r\n\t\t\t\tif (rowsToIgnore.includes(row)) {\r\n\t\t\t\t\ttypedRows.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst data = new Data(typedRows, fileConfig.aliases);\r\n\r\n\treturn data;\r\n}\r\n\r\n/**\r\n * Converts a map of column names like the one that can be provided as part of a {@linkcode FileConfig} object,\r\n * transforming each property according to the same rules as {@linkcode getColNumber}.\r\n *\r\n * If any of those transformations results in `null`, the property will be removed from the result.\r\n *\r\n * @param colsConfig - A map of column names to their indices\r\n */\r\nexport function getColNumbers<ColName extends string>(colsConfig: Record<ColName, readonly [string | number, ...unknown[]]>): Record<ColName, number> {\r\n\tconst entries = Object.entries<typeof colsConfig[keyof typeof colsConfig]>(colsConfig);\r\n\r\n\tconst mappedEntries = entries.map(([name, [index]]) => {\r\n\t\tconst colNumber = getColNumber(index);\r\n\r\n\t\tif (colNumber !== null) {\r\n\t\t\treturn [name, colNumber] as const;\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}).filter((el): el is NonNullable<typeof el> => Boolean(el));\r\n\r\n\tconst cols = Object.fromEntries(mappedEntries) as Record<ColName, number>;\r\n\treturn cols;\r\n}\r\n\r\n/**\r\n * Convert a string of the format used as column headings by spreadsheet software like\r\n * Microsoft Excel into 0-indexed numbers.\r\n *\r\n * For example `'A'` would be converted to `0`, whereas `'ZE'` would be converted to `680`.\r\n * This is case insensitive.\r\n *\r\n * If a positive integer is passed, it will be returned unchanged.\r\n *\r\n * Any other number, or any string containing an invalid character, will instead be converted to `null`.\r\n */\r\nexport function getColNumber(index: number | string): number | null {\r\n\tif (typeof index === 'number') {\r\n\t\tif (Number.isInteger(index) && index >= 0) {\r\n\t\t\treturn index;\r\n\t\t} else {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t} else if (index === '') {\r\n\t\treturn null;\r\n\t} else if (typeof index !== 'string') {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tconst alphabet: readonly string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\r\n\tlet colNumber = -1; // Adjust for 0-based counting\r\n\r\n\tconst upperIndex = index.toUpperCase();\r\n\tfor (let i = 0; i < upperIndex.length; i++) {\r\n\t\tconst char = upperIndex[i];\r\n\t\tconst charIndex = alphabet.indexOf(char);\r\n\r\n\t\tif (charIndex === -1) {\r\n\t\t\t// `index` contains an invalid character\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tcolNumber += (charIndex + 1) * Math.pow(alphabet.length, index.length - (i+1));\r\n\t}\r\n\r\n\treturn colNumber;\r\n}\r\n\r\n/**\r\n * This function allows {@linkcode Array.prototype.filter} to be used on a {@linkcode Data} object\r\n * while respecting a data set's aliases.\r\n *\r\n * It takes two arguments, which can each be either a single value or an array of values.\r\n * If any value in both of these arguments is either a direct match or are aliases of one another,\r\n * then the result will be `true`. Otherwise, the result will be `false`.\r\n *\r\n * Filtering can also be done without this function, when working with data that has no aliases, or\r\n * filtering by columns that don't contain string values.\r\n */\r\nexport function matchWithAlias(testValue: unknown, matchValue: unknown, aliases?: readonly string[][]): boolean {\r\n\t// Convert single values to arrays of length 1 to make them easier to work with consistently\r\n\tconst testValues: unknown[] = Array.isArray(testValue) ? testValue : [testValue];\r\n\tconst matchValues: unknown[] = Array.isArray(matchValue) ? matchValue : [matchValue];\r\n\r\n\treturn testValues.some(\r\n\t\t(testValue) => matchValues.some(\r\n\t\t\t(matchValue) => matchWithAliasSingle(testValue, matchValue, aliases)\r\n\t\t)\r\n\t);\r\n}\r\n\r\n/**\r\n * Checks if two values match, optionally taking a set of aliases where groups of strings are treated as equal.\r\n */\r\nfunction matchWithAliasSingle(valueA: unknown, valueB: unknown, aliases?: readonly string[][]): boolean {\r\n\tif (valueA === valueB) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif (\r\n\t\taliases &&\r\n\t\ttypeof valueA === 'string' &&\r\n\t\ttypeof valueB === 'string'\r\n\t) {\r\n\t\tfor (const aliasGroup of aliases) {\r\n\t\t\tif (aliasGroup.includes(valueA) && aliasGroup.includes(valueB)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n","function getNumArray(val: number[] | [number[]]): number[] {\n\tif (\n\t\t((value: unknown[]): value is [number[]] => {\n\t\t\treturn value.length === 1 && Array.isArray(value[0]);\n\t\t})(val)\n\t) {\n\t\treturn val[0];\n\t} else {\n\t\treturn val;\n\t}\n}\n\n/**\n * Return the sum of an array of numbers.\n */\nexport function sum(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn numbers.reduce(function (sum: number, val: number) {\n\t\treturn sum + val;\n\t}, 0);\n}\n\n/**\n * Returns the mean of an array of numbers.\n */\nexport function mean(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn sum(numbers) / numbers.length;\n}\n","import { TypeFn } from './types/TypeFn.js';\r\n\r\n// Type-only imports to make symbols available to JSDoc\r\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\nimport type { getColNumber, matchWithAlias } from './file-processing.js';\r\n/* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\nimport type { Data } from './Data.js';\r\n\r\ntype ColConfig<RowShape extends Record<string, unknown>> = {\r\n\t[Col in keyof RowShape]: [string | number, TypeFn<RowShape[Col]>]\r\n}\r\n\r\n/**\r\n * This type describes how to process a file, including where it is and how it is structured.\r\n *\r\n * It is possible to create an object of this type directly, but because of how TypeScript's generic\r\n * type inference is limited to functions it is recommended to use the {@linkcode fileConfig} method\r\n * when working with TypeScript in order to improve both type checking when creating the object and\r\n * autocompletion prompts for column names after the file has been processed.\r\n */\r\nexport type FileConfig<\r\n\tColName extends string,\r\n\tRowShape extends Record<ColName, unknown>,\r\n> = {\r\n\t/** This string is used to {@linkcode fetch} the CSV file to be processed. */\r\n\tpath: string;\r\n\t/**\r\n\t * Specifies the names and locations of each column to be processed, as\r\n\t * well as what type it should have. Not every column present in the file needs to be\r\n\t * specified, but you should specify each column that you wish to access.\r\n\t *\r\n\t * If the column's location is specified as a string, it will be passed through {@linkcode getColNumber}\r\n\t * to convert it into a number.\r\n\t */\r\n\tcols: ColConfig<RowShape>;\r\n\r\n\t/** The number of empty rows at the start of the CSV file which should be ignored, such as label rows. */\r\n\theaderRows?: number;\r\n\t/** The number of rows at the end of the CSV file which should be ignored, such as total rows. */\r\n\tfooterRows?: number;\r\n\t/**\r\n\t * A function that determines whether or not a row should be ignored.\r\n\t * If the function returns `true` for a row, then that row will be ignored.\r\n\t */\r\n\tignoreRows?: (row: RowShape) => boolean;\r\n\r\n\t/**\r\n\t * When {@link matchWithAlias filtering} and {@link Data.groupBy grouping} data, it can be useful to treat different valueus as if they were the\r\n\t * same, particularly if the source data is inconsistent.\r\n\t *\r\n\t * Each element in this array is an array of strings, where each string is treated as being equaul to\r\n\t * each other string in the array when filtering the data.\r\n\t *\r\n\t * @example\r\n\t * ```typescript\r\n\t * [\r\n\t *     ['New Zealand', 'NZ'],\r\n\t *     ['Australia', 'AU'],\r\n\t * ]\r\n\t * ```\r\n\t */\r\n\taliases?: string[][];\r\n};\r\n\r\n/**\r\n * This function doesn't do anything itself, it just returns the object passed to it. However,\r\n * when working with TypeScript using a function in this way is necessary in order for the\r\n * TypeScript compiler to correctly infer the generic type based on the specified column names\r\n * for the data.\r\n *\r\n * @see {@link https://stackoverflow.com/a/70211076/1710523}\r\n */\r\nexport function fileConfig<\r\n\tRowShape extends Record<string, unknown>,\r\n>(fileConfig: FileConfig<keyof RowShape & string, RowShape>) {\r\n\treturn fileConfig;\r\n}\r\n","import { AnalyserSummary } from '../AnalyserGroup.js';\r\nimport { ChartOptions } from './ChartOptions.js';\r\n\r\n/**\r\n * Types that can be coerced to `number`\r\n */\r\ntype NumberLike = number | string | Date;\r\n\r\nexport type ChartData<GroupName extends string = string> = {\r\n\tlabels: NumberLike[],\r\n\tgroupNames: GroupName[],\r\n\tgroups: number[][],\r\n\r\n\tmin?: number,\r\n\tmax?: number,\r\n\r\n\tstacked?: boolean,\r\n};\r\n\r\nexport function getChartData<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: ChartOptions<GroupName>): ChartData<GroupName> {\r\n\tconst [[, ...groupNames]] = summary; // Ignore first 'Value' entry in first row\r\n\tlet [, ...valueRows] = summary; // Ignore first row of group names\r\n\r\n\t// If all the values are dates or numbers, sort valueRows based on label then re-extract\r\n\tif (valueRows.every((row): row is [Date | number, ...unknown[]] => row[0] instanceof Date || typeof row[0] === 'number')) {\r\n\t\tvalueRows = valueRows.sort((a, b) => +a[0] - +b[0]);\r\n\t}\r\n\r\n\t// `valueRows` can contain any sort of values, but only values that can be converted to numbers can be used to create a chart\r\n\tif (!valueRows.every((row): row is [NumberLike, ...unknown[]] => typeof row[0] === 'number' || typeof row[0] === 'string' || row[0] instanceof Date)) {\r\n\t\tthrow new TypeError(`Charts can only be created from data that can be converted to numbers.`);\r\n\t}\r\n\r\n\t// Extract the labels\r\n\tlet labels = valueRows.map((row) => row[0]);\r\n\r\n\t// If the x axis is qualitative, and its labels were limited in its options\r\n\tif (options?.x && 'labels' in options.x && options.x.labels) {\r\n\t\t// Remove any labels not specified in the axis options\r\n\t\tfor (let i = 0; i < labels.length; i++) {\r\n\t\t\tconst label = labels[i];\r\n\t\t\t// Use `as unknown[]` so TypeScript doesn't complain when using Array.prototype.includes\r\n\t\t\tif ((options.x.labels as unknown[]).includes(label) === false) {\r\n\t\t\t\tlabels.splice(i, 1);\r\n\t\t\t\tvalueRows.splice(i, 1);\r\n\t\t\t\ti -= i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Go through specified labels, and if any weren't in the dataset then add empty data\r\n\t\tfor (let i = 0; i < options.x.labels.length; i++) {\r\n\t\t\tconst label = options.x.labels[i];\r\n\t\t\tif (labels.includes(label) === false) {\r\n\t\t\t\tconst emptyData: [NumberLike, ...0[]] = [label, ...(new Array<0>(valueRows[0].length-1)).fill(0)];\r\n\t\t\t\tlabels.splice(i, 0, label);\r\n\t\t\t\tvalueRows.splice(i, 0, emptyData);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Also update order of labels and value rows to match specified label order\r\n\t\tlabels = options.x.labels;\r\n\t\tvalueRows = valueRows.sort((rowA, rowB) => {\r\n\t\t\tconst labelA = rowA[0];\r\n\t\t\tconst indexA = labels.indexOf(labelA);\r\n\r\n\t\t\tconst labelB = rowB[0];\r\n\t\t\tconst indexB = labels.indexOf(labelB);\r\n\r\n\t\t\treturn indexA - indexB;\r\n\t\t});\r\n\t}\r\n\r\n\t// Transpose valueRows to get groups\r\n\tconst valueGroups: unknown[][] = [];\r\n\tfor (let i = 0; i < valueRows.length; i++) {\r\n\t\t// Start at j = 1 to ignore labels\r\n\t\tfor (let j = 1; j < valueRows[i].length; j++) {\r\n\t\t\tif (typeof valueGroups[j] === 'undefined') {\r\n\t\t\t\tvalueGroups[j] = [];\r\n\t\t\t}\r\n\t\t\tvalueGroups[j][i] = valueRows[i][j];\r\n\t\t}\r\n\t}\r\n\t// This method has given us an empty element at index 0, so remove it\r\n\tvalueGroups.splice(0, 1);\r\n\r\n\t// We can only graph groups if all their values are numbers\r\n\tconst numberValueGroups = valueGroups.filter(\r\n\t\t(group): group is number[] => group.every(\r\n\t\t\t(value): value is number => typeof value === 'number'\r\n\t\t)\r\n\t);\r\n\r\n\t// Filter out the same non-number groups from the groupNames list\r\n\tconst numberValueGroupNames = groupNames.filter(\r\n\t\t// Using a type assertion here is safe because we're just checking for inclusion\r\n\t\t(groupName, index) => (numberValueGroups as unknown[]).includes(valueGroups[index])\r\n\t);\r\n\r\n\tconst chartData: ChartData<GroupName> = {\r\n\t\tlabels,\r\n\t\tgroupNames: numberValueGroupNames,\r\n\t\tgroups: numberValueGroups,\r\n\t};\r\n\r\n\tif (options && 'stacked' in options) {\r\n\t\tchartData.stacked = options.stacked;\r\n\t}\r\n\r\n\treturn chartData;\r\n}\r\n","import { ChartData } from './ChartData.js';\nimport { ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\n\nexport interface ScaleOptions {\n\tmin: number,\n\tmax: number,\n}\n\nexport class Scale {\n\tmin: number;\n\tmax: number;\n\n\tget width(): number {\n\t\treturn this.max - this.min;\n\t}\n\n\tconstructor(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x') {\n\t\t[this.min, this.max] = getMinMax(options, chartOptions, type);\n\t}\n\n\t/**\n\t * Standardises the scale to go from 0 to 1,\n\t * then finds the value's position within it.\n\t */\n\tgetProportion(value: number): number {\n\t\tconst proportion = (value - this.min) / this.width;\n\n\t\treturn proportion;\n\t}\n\n\t/**\n\t * Given a proportion value on a scale from 0 to 1,\n\t * find the equivalent value on this scale.\n\t */\n\tgetValue(proportion: number): number {\n\t\tconst value = this.width * proportion + this.min;\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * For a given length of at least 2, create an array\n\t * of numbers from the bottom of the scale to the top,\n\t * with an equal step between each number in the range.\n\t */\n\tgetSeries(length: number): number[] {\n\t\tif (length < 2) {\n\t\t\tlength = 2;\n\t\t}\n\n\t\tconst stepSize = this.width / (length-1);\n\n\t\t// Start with minimum value\n\t\tconst series: number[] = [this.min];\n\n\t\t// Add intermediate steps\n\t\tfor (let i = 0; i < length-2; i++) {\n\t\t\tseries.push(series[series.length-1] + stepSize);\n\t\t}\n\n\t\t// End with max value\n\t\tseries.push(this.max);\n\n\t\treturn series;\n\t}\n}\n\n/**\n * Determines the appropriate method for reading or calculating min and max values,\n * based on the available data and options, then reads or calculates them.\n */\nfunction getMinMax(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x'): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\t// First, get minMax from options\n\tif ('groups' in options) {\n\t\t// options is of type ChartData, so determine min and max based on\n\t\t// the labels or the data, depending on the type of scale being created\n\t\tif (type === 'x') {\n\t\t\t[min, max] = getMinMaxFromChartDataLabels(options);\n\t\t} else {\n\t\t\t[min, max] = getMinMaxFromChartData(options);\n\t\t}\n\t} else {\n\t\t// options is a ScaleOptions, so read min and max directly\n\t\t[min, max] = getMinMaxFromScaleOptions(options);\n\t}\n\n\t// If min is larger than max, swap them around\n\tif (min > max) {\n\t\t[min, max] = [max, min];\n\t}\n\n\t// Then, see if min and/or max are overridden by chartOptions\n\tif (type && chartOptions) {\n\t\tconst axisOptions = chartOptions[type];\n\t\tif (axisOptions && ('min' in axisOptions || 'max' in axisOptions || 'values' in axisOptions)) {\n\t\t\tconst allowAuto = type !== 'x';\n\t\t\t[min, max] = getMinMaxFromAxisOptions(axisOptions, min, max, allowAuto);\n\t\t}\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the values contained in a set of ChartData.\n */\nfunction getMinMaxFromChartData(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { groups } = options;\n\n\tif (!groups.length || !groups[0].length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tlet allValues: number[];\n\tif ('stacked' in options && options.stacked) {\n\t\tallValues = groups[0].map((el, i) => groups.reduce((sum, group) => sum + group[i], 0));\n\t} else {\n\t\t// Use `as number[]` here so TypeScript doesn't complain when using Array.prototype.concat\n\t\tallValues = ([] as number[]).concat(...groups);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...allValues);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...allValues);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the labels for a set of ChartData.\n * Assumes all labels can be converted to numbers, and will throw an error if this assumption is false.\n */\nfunction getMinMaxFromChartDataLabels(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { labels } = options;\n\n\tif (!labels.length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tconst numberLabels = labels.map((label) => typeof label === 'number' ? label : +label);\n\tif (!numberLabels.every((label) => isNaN(label) === false)) {\n\t\tthrow new TypeError(`Cannot extract minimum or maximum values from labels that aren't all numbers.`);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...numberLabels);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...numberLabels);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Reads min and max values directly from a ScaleOptions object.\n */\nfunction getMinMaxFromScaleOptions(options: ScaleOptions): [number, number] {\n\tconst { min, max } = options;\n\n\treturn [min, max];\n}\n\n/**\n * Determines min and max values from an AxisOptions object, either reading them\n * directly from the options or calculating them from the highest order of magnitude\n * and, if specified, the number of values that needs to display on an axis.\n */\nfunction getMinMaxFromAxisOptions(axisOptions: AxisOptionsQuantitative, min: number, max: number, allowAuto = true): [number, number] {\n\tif (\n\t\t(Array.isArray(axisOptions.values) && axisOptions.values.length) ||\n\t\t(Array.isArray(axisOptions.gridlines) && axisOptions.gridlines.length)\n\t) {\n\t\t// If all the axis values or gridlines are specified,\n\t\t// the values they determine can extend min and/or max\n\t\t// past the values already determined.\n\n\t\t// Axis options can specify values as dates, but Scale always works with numbers\n\t\tlet allValues: number[] = [];\n\t\tif (Array.isArray(axisOptions.values)) {\n\t\t\tallValues = allValues.concat(axisOptions.values.map((val) => +val));\n\t\t}\n\t\tif (Array.isArray(axisOptions.gridlines)) {\n\t\t\tallValues = allValues.concat(axisOptions.gridlines.map((val) => +val));\n\t\t}\n\t\tmin = Math.min(min, ...allValues);\n\t\tmax = Math.max(max, ...allValues);\n\t}\n\n\tif (typeof axisOptions.min === 'number') {\n\t\tmin = axisOptions.min;\n\t} else if (allowAuto && (axisOptions.min === 'auto' || typeof axisOptions.min === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Round down min to nearest multiple of that power of 10\n\t\tconst widthRoundTo = Math.pow(10, maxPower);\n\t\tmin = Math.floor(min / widthRoundTo) * widthRoundTo;\n\n\t\t// If the power was negative, fix any floating point issues that may have arisen\n\t\tif (maxPower < 0) {\n\t\t\tmin = +(min.toFixed(-maxPower));\n\t\t}\n\t}\n\n\tif (typeof axisOptions.max === 'number') {\n\t\tmax = axisOptions.max;\n\t} else if (allowAuto && (axisOptions.max === 'auto' || typeof axisOptions.max === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Subtract min so we're working directly with the width\n\t\tmax -= min;\n\n\t\t// Round up max to nearest multiple of that power of 10\n\t\tlet widthRoundTo = Math.pow(10, maxPower);\n\t\tmax = Math.ceil(max / widthRoundTo) * widthRoundTo;\n\n\t\t// If the number of values to be displayed has been set\n\t\tif (typeof axisOptions.values === 'number') {\n\t\t\t// Only integers are accepted\n\t\t\tif (Number.isInteger(axisOptions.values) === false) {\n\t\t\t\tthrow new TypeError(`axisOptions.values must be an integer.`);\n\t\t\t}\n\n\t\t\t// Continue to increase max until it is a multiple of the next\n\t\t\t// greatest power of 10 below the largest one beneath max.\n\t\t\t// Also, ensure max is greater than min\n\t\t\tconst valuePower = maxPower - 1;\n\t\t\tlet valueRoundTo = Math.pow(10, valuePower) * axisOptions.values;\n\n\t\t\t// If that power is negative, JavaScript can run into issues\n\t\t\t// to do with numbers like 0.1 being unable to be represented in binary.\n\t\t\t// So multiply everything by that power and round it, then divide and fix at the end\n\t\t\tif (valuePower < 0) {\n\t\t\t\tvalueRoundTo = Math.round(valueRoundTo / Math.pow(10, valuePower));\n\t\t\t\twidthRoundTo = Math.round(widthRoundTo / Math.pow(10, valuePower));\n\t\t\t\tmax = Math.round(max / Math.pow(10, valuePower));\n\t\t\t}\n\n\t\t\tfor (let iterations = 0; iterations < 1000; iterations++) {\n\t\t\t\tconst remainder = max % valueRoundTo;\n\n\t\t\t\tif (remainder === 0 && max > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tmax += widthRoundTo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we muliplied everything earlier, undo that now then fix any floating point issues\n\t\t\tif (valuePower < 0) {\n\t\t\t\tmax = +(max * Math.pow(10, valuePower)).toFixed(-valuePower);\n\t\t\t}\n\t\t}\n\n\t\t// Add min back to convert width back to max\n\t\tmax += min;\n\t}\n\n\treturn [min, max];\n}\n","import { ChartData } from './ChartData.js';\nimport { BaseChartOptions, ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\nimport { Scale } from './Scale.js';\n\nexport function chart<GroupName extends string>(chartData: ChartData<GroupName>, contents: string, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<figure class=\"chart\">\n\t\t\t${options?.title ? title(options) : ''}\n\n\t\t\t<div class=\"chart__area\">\n\t\t\t\t${options?.legend ? legend(chartData, options) : ''}\n\n\t\t\t\t${yGridlines(chartData, options)}\n\n\t\t\t\t${xGridlines(chartData, options)}\n\n\t\t\t\t${contents}\n\t\t\t</div>\n\n\t\t\t${yAxis(chartData, options)}\n\n\t\t\t${xAxis(chartData, options)}\n\t\t</figure>\n\t`;\n}\n\nfunction title<GroupName extends string>(options: ChartOptions<GroupName>): string {\n\treturn options.title ? `<figcaption class=\"chart__title\">${options.title}</figcaption>` : '';\n}\n\nfunction legend<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<div class=\"chart__legend\">\n\t\t\t<span class=\"chart__legend__title\">Legend</span>\n\n\t\t\t<ul class=\"chart__legend__items\">\n\t\t\t\t${chartData.groupNames.map((groupName, index) => {\n\t\t\t\t\tconst colour: string | undefined = options?.colours && options.colours[groupName];\n\n\t\t\t\t\tconst str = `<li class=\"chart__legend__item\">\n\t\t\t\t\t\t<span class=\"chart__legend__item__swatch\"${colour ? ` style=\"background-color: ${colour};\"` : ''}></span>\n\t\t\t\t\t\t<span class=\"chart__legend__item__name\">${groupName}</span>\n\t\t\t\t\t</li>`;\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t</div>\n\t`;\n}\n\nfunction yAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.y;\n\n\tconst scale = new Scale(chartData, options, 'y');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\t// Render axis based on scale\n\treturn `\n\t<div class=\"chart__y-axis\">\n\t\t${axisOptions?.title ? `\n\t\t<span class=\"chart__y-axis__title\">${axisOptions.title}</span>\n\t\t` : ''}\n\n\t\t<ul class=\"chart__y-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__y-axis__value\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\tif (axisOptions) {\n\t\t// AxisOptions has no required values, so we can only be certain what axis type we're dealing with if labels or values is specified\n\t\tif ('labels' in axisOptions) {\n\t\t\treturn xAxisQualitative(chartData, options);\n\t\t} else if ('values' in axisOptions) {\n\t\t\treturn xAxisQuantitative(chartData, options);\n\t\t}\n\t}\n\n\treturn xAxisMinimal(chartData, options);\n}\n\nfunction xAxisQualitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst { labels } = chartData;\n\n\t// For each label, render that label\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__label-list\">\n\t\t\t${labels.map((label) => `<li class=\"chart__x-axis__label\">${applyFormat(label, axisOptions)}</li>`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisQuantitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst scale = new Scale(chartData, options, 'x');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__x-axis__value\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisMinimal<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t</div>`;\n}\n\nfunction yGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst scale = new Scale(chartData, options, 'y');\n\n\tconst { values } = getAxisGridlines(scale, options?.y);\n\n\t// Render gridlines based on scale\n\treturn `\n\t\t<ul class=\"chart__y-gridlines\" role=\"presentation\">\n\t\t\t${values.map((val, index) => {\n\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t// since that line is already drawn by the x axis\n\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t<li class=\"chart__y-gridline\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t'';\n\n\t\t\t\treturn gridlines;\n\t\t\t}).join('')}\n\t\t</ul>\n\t`;\n}\n\nfunction xGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\tif (axisOptions && ('values' in axisOptions || 'gridlines' in axisOptions)) {\n\t\tconst scale = new Scale(chartData, options, 'x');\n\t\tconst { values } = getAxisGridlines(scale, axisOptions);\n\n\t\t// Render gridlines based on scale\n\t\treturn `\n\t\t\t<ul class=\"chart__x-gridlines\" role=\"presentation\">\n\t\t\t\t${values.map((val, index) => {\n\t\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t\t// since that line is already drawn by the y axis\n\t\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t\t<li class=\"chart__x-gridline\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t\t'';\n\n\t\t\t\t\treturn gridlines;\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t`;\n\t} else {\n\t\treturn '';\n\t}\n}\n\nexport function tooltip<GroupName extends string>(chartData: ChartData<GroupName>, group: number[], label: unknown, options?: ChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst groupIndex = groups.indexOf(group);\n\tif (groupIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised group`);\n\t}\n\n\tconst groupName = groupNames[groupIndex];\n\n\t// Use `as unknown[]` so TypeScript doesn't complain when using Array.prototype.includes\n\tconst labelIndex = (labels as unknown[]).indexOf(label);\n\tif (labelIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised label`);\n\t}\n\n\tconst value = group[labelIndex];\n\n\tconst str = `\n\t<div class=\"chart__tooltip\">\n\t\t${groups.length > 1 ? groupName : ''} ${label}: ${applyFormat(value, options?.y)}\n\t</div>`;\n\n\treturn str;\n}\n\ninterface AxisValues {\n\tvalues: number[],\n\tdates: boolean,\n}\n\nfunction getAxisValues(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.values !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.values);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tvalues = scale.getSeries(2);\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\nfunction getAxisGridlines(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.gridlines !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.gridlines);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tconst axisValues = getAxisValues(scale, axisOptions);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\n/**\n * Both axis values and axis gridlines are retrieved in the same way, only with different fallbacks.\n * This base function contains that shared functionality, including the necessary conversion from\n * Date to number if the specified values are Dates, while remembering that they were Dates so they\n * can be converted back to Dates further down the line.\n */\nfunction getAxisValuesBase(scale: Scale, axisValues: Exclude<AxisOptionsQuantitative['values'], undefined>): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisValues === 'number') {\n\t\tconst numValues = axisValues + 1;\n\t\tvalues = scale.getSeries(numValues);\n\t} else if (axisValues.length > 0) {\n\t\t// These type assertions are necessary because of how `Array.prototype.every` has been typed\n\t\t// https://stackoverflow.com/questions/71012370/narrowing-a-union-of-array-types-using-array-every\n\t\tif ((axisValues as unknown[]).every((val: unknown): val is number => typeof val === 'number')) {\n\t\t\tvalues = axisValues as number[];\n\t\t} else {\n\t\t\tdates = true;\n\t\t\tvalues = axisValues.map((val) => +val);\n\t\t}\n\t} else {\n\t\tvalues = axisValues as [];\n\t}\n\n\treturn { values, dates };\n}\n\nfunction applyFormat(value: unknown, axisOptions?: AxisOptionsQuantitative): string {\n\tif (typeof value === 'number') {\n\t\tif (axisOptions?.numberFormat) {\n\t\t\tif (axisOptions.numberFormat instanceof Intl.NumberFormat) {\n\t\t\t\treturn axisOptions.numberFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.numberFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else if (value instanceof Date) {\n\t\tif (axisOptions?.dateFormat) {\n\t\t\tif (axisOptions.dateFormat instanceof Intl.DateTimeFormat) {\n\t\t\t\treturn axisOptions.dateFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.dateFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else {\n\t\treturn '' + value;\n\t}\n}\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { BarChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderBars<GroupName extends string>(chartData: ChartData<GroupName>, options?: BarChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scale = new Scale(chartData, options, 'y');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<ul class=\"chart__bar-groups\">\n\t\t\t${labels.map((label, index) =>\n\t\t\t`<li class=\"chart__bar-group\">\n\t\t\t\t<ul class=\"chart__bar-group-bars${options?.stacked ? ` chart__bar-group-bars--stacked` : ''}\">\n\t\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\t\tconst colour = colours && colours[groupName];\n\t\t\t\t\t\tconst value = group[index];\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li\n\t\t\t\t\t\t\t\tclass=\"chart__bar\"\n\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t` style=\"flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t}%;\"` :\n\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclass=\"chart__bar__area\"\n\t\t\t\t\t\t\t\tstyle=\"\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\tcolour ?\n\t\t\t\t\t\t\t\t\t\t\t`background: ${colour}; ` :\n\t\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t\t'' :\n\t\t\t\t\t\t\t\t\t\t\t`flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t\t}%;`\n\t\t\t\t\t\t\t\t\t}\" data-value=\"${value}\"\n\t\t\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>`;\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t</li>`).join('')}\n\t\t</ul>\n\t`;\n}\n\nexport function bar<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: BarChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst bars = renderBars(chartData, options);\n\n\tconst chart = renderChart(chartData, bars, options);\n\n\treturn chart;\n}\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { LineChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderLines<GroupName extends string>(chartData: ChartData<GroupName>, options?: LineChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scaleY = new Scale(chartData, options, 'y');\n\tconst scaleX = new Scale(chartData, options, 'x');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<svg class=\"chart__lines\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\">\n\t\t\t<g transform=\"translate(0, 100) scale(1, -1)\">\n\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\t\t\tconst points = labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\t\t\t\t\t\tconst str = `${leftPercent},${percentage}`;\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join(' ');\n\n\t\t\t\t\tconst str = `\n\t\t\t\t\t\t<polyline class=\"chart__line\" points=\"${points}\"${colour ? ` style=\"stroke: ${colour};\"` : ''}></polyline>\n\t\t\t\t\t`;\n\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</g>\n\t\t</svg>\n\n\t\t${groups.map((group, groupIndex) => {\n\t\t\tconst str = `\n\t\t\t\t<ul class=\"chart__line__points\">\n\t\t\t\t\t${labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li class=\"chart__line__point\" style=\"left: ${leftPercent}%; bottom: ${percentage}%\" tabindex=\"0\">\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t`;\n\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t`;\n\n\t\t\treturn str;\n\t\t}).join('')}\n\t`;\n}\n\nexport function line<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: LineChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst lines = renderLines(chartData, options);\n\n\tconst chart = renderChart(chartData, lines, options);\n\n\treturn chart;\n}\n","import * as codebook from '@cipscis/codebook';\r\n\r\nimport * as csv from '@cipscis/csv';\r\nimport * as analyser from '@cipscis/analyser';\r\n\r\nconst selectors = Object.freeze({\r\n\texample: '.js-docs__example',\r\n\tblock: '.js-docs__example .js-codebook__block[contenteditable]',\r\n\trun: '.js-docs__run',\r\n\tlog: '.js-docs__log',\r\n\r\n\tcodebookSet: '.js-codebook__set',\r\n} as const);\r\n\r\nconst dataAttributes = Object.freeze({\r\n\tcodebookSet: 'data-codebook-set',\r\n} as const);\r\n\r\nconst classes = Object.freeze({\r\n\terror: 'docs-example__control--error',\r\n} as const);\r\n\r\nlet $currentBlock: HTMLElement | null = null;\r\n\r\nfunction init() {\r\n\t_initEvents();\r\n\r\n\t_runInitialSets();\r\n}\r\n\r\nfunction _initEvents() {\r\n\tconst $runSetButtons = document.querySelectorAll<HTMLElement>(selectors.run);\r\n\t$runSetButtons.forEach(($runSetButton) => {\r\n\t\t$runSetButton.addEventListener('click', _runSetEvent);\r\n\t});\r\n\r\n\tconst $blocks = document.querySelectorAll<HTMLElement>(selectors.block);\r\n\t$blocks.forEach(($block) => {\r\n\t\t$block.addEventListener('blur', _clearCurrentBlock);\r\n\t\t$block.addEventListener('input', _markAsCurrentBlock);\r\n\t\t$block.addEventListener('keydown', _markAsCurrentBlockOnArrowDown);\r\n\t});\r\n\tdocument.addEventListener('keydown', _handleTabInsertion);\r\n}\r\n\r\nfunction _runInitialSets() {\r\n\tcodebook.tidy();\r\n\r\n\tcodebook.runSet('example-data', { csv });\r\n}\r\n\r\nfunction _runSetEvent(this: HTMLElement, e: MouseEvent) {\r\n\tconst $runSetButton = this;\r\n\tconst $set = $runSetButton.closest(selectors.codebookSet);\r\n\tconst setName = $set?.getAttribute(dataAttributes.codebookSet);\r\n\r\n\t$runSetButton.setAttribute('aria-busy', 'true');\r\n\r\n\tconst args = { csv, analyser };\r\n\tconst promise = setName ? codebook.runSet(setName, args) : codebook.runSet(args);\r\n\r\n\tpromise\r\n\t\t.then(() => {\r\n\t\t\t$runSetButton.classList.remove(classes.error);\r\n\t\t})\r\n\t\t.catch((reason) => {\r\n\t\t\t$runSetButton.classList.add(classes.error);\r\n\t\t\tconst $example = $runSetButton.closest(selectors.example);\r\n\t\t\tconst $log = $example?.querySelector(selectors.log);\r\n\r\n\t\t\tif ($log) {\r\n\t\t\t\tconsole.error(reason);\r\n\t\t\t\t$log.innerHTML = String(reason);\r\n\t\t\t}\r\n\t\t})\r\n\t\t.finally(() => {\r\n\t\t\t$runSetButton.setAttribute('aria-busy', 'false');\r\n\t\t});\r\n}\r\n\r\nfunction _markAsCurrentBlock(this: HTMLElement, e: Event) {\r\n\t$currentBlock = this;\r\n}\r\n\r\nfunction _markAsCurrentBlockOnArrowDown(this: HTMLElement, e: KeyboardEvent) {\r\n\tif (\r\n\t\te.key === 'ArrowUp' ||\r\n\t\te.key === 'ArrowRight' ||\r\n\t\te.key === 'ArrowDown' ||\r\n\t\te.key === 'ArrowLeft'\r\n\t) {\r\n\t\t_markAsCurrentBlock.call(this, e);\r\n\t}\r\n}\r\n\r\nfunction _clearCurrentBlock(this: HTMLElement, e: FocusEvent) {\r\n\t$currentBlock = null;\r\n}\r\n\r\nfunction _handleTabInsertion(this: Document, e: KeyboardEvent) {\r\n\tif (e.key !== 'Tab') {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ($currentBlock === null) {\r\n\t\treturn;\r\n\t}\r\n\r\n\te.preventDefault();\r\n\r\n\tconst selection = this.getSelection();\r\n\tconst range = selection?.getRangeAt(0);\r\n\tif (range) {\r\n\t\trange.deleteContents();\r\n\t\trange.insertNode(document.createTextNode('\\t'));\r\n\t\trange.collapse(false);\r\n\t}\r\n}\r\n\r\ninit();\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","selectors","freeze","block","set","inert","dataAttributes","index","log","html","defaultSetName","$textarea","document","createElement","async","runSet","setNameOrArgs","argsParam","setName","args","sets","$blocks","querySelectorAll","setNames","$block","_getSetName","includes","push","_createNewSet","blocks","_gatherSetBlocks","_sortCodeBlocks","_createCodeSets","code","reduce","_combineCode","logId","getAttribute","$log","getElementById","innerHTML","_clearLogs","argNames","argValues","keys","values","_spreadArgs","Error","Function","apply","concat","_logOutput","_htmlOutput","fn","_runSet","RangeError","sort","$blockA","$blockB","iA","iB","assign","allCode","$newCode","newCode","htmlString","textContent","htmlId","$parent","closest","output","forEach","outputEl","outputString","Date","padZeroes","num","minLength","numStr","toString","length","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","JSON","stringify","$html","data","options","transpose","sanitise","shapedRows","maxLength","row","Math","max","iMax","jMax","rows","i","j","iRow","iCol","cellValue","_shape","escapedRows","_escapeCell","_escape","rowStrings","join","_join","cell","cellString","match","replace","parse","csvString","mapper","stringRows","tokens","inQuote","wasQuote","tokenStart","char","comma","quote","newline","eof","SyntaxError","token","substring","_tokenise","rowLength","_validate","map","defaultSummarisers","Count","DataGroup","Map","constructor","super","this","discrete","summarise","summarisersArg","summarisers","summaryHeaderRow","summaryValueRows","groupName","entries","summaryRow","summariser","rowSummary","summaryValuesSorted","a","b","indexOf","Data","Array","aliases","source","isArray","addCol","colName","creator","newRow","newRows","groupBy","splitting","right","enums","collectEnums","group","val","matchingRows","filter","matchWithAlias","groupDiscreteData","setLimits","Number","isInteger","enumArr","isNumber","x","every","TypeError","min","setSize","setMin","setMax","Infinity","splitValues","filterFn","groupContinuousData","Set","add","isNonCanonical","isCanonical","aliasGroup","canonicalAliasMember","has","delete","string","cleanNumberLike","appearsNumber","cleanValue","parseFloat","number","Boolean","appearsPercentage","numValue","precision","toFixed","booleanCustom","truthy","falsey","test","e","array","separator","limit","result","split","enumValue","recodeMap","enumValues","iterator","testValue","recodedValue","defaultOptions","strict","loadFile","fileConfig","optionsWithDefaults","response","fetch","path","ok","processedData","dataRows","headerRows","splice","footerRows","cols","getColNumbers","typedRows","namedRow","typedRow","transformFn","locationIdentifier","message","console","error","warn","ignoreRows","rowsToIgnore","processData","text","status","statusText","colsConfig","mappedEntries","name","colNumber","getColNumber","el","fromEntries","alphabet","upperIndex","toUpperCase","charIndex","pow","matchValue","testValues","matchValues","some","valueA","valueB","matchWithAliasSingle","getNumArray","sum","arr","mean","numbers","getChartData","summary","groupNames","valueRows","labels","label","emptyData","fill","rowA","rowB","labelA","indexA","labelB","valueGroups","numberValueGroups","numberValueGroupNames","chartData","groups","stacked","Scale","width","chartOptions","type","numberLabels","isNaN","getMinMaxFromChartDataLabels","allValues","getMinMaxFromChartData","getMinMaxFromScaleOptions","axisOptions","allowAuto","gridlines","maxPower","floor","log10","abs","widthRoundTo","ceil","valuePower","valueRoundTo","round","iterations","getMinMaxFromAxisOptions","getMinMax","getProportion","getValue","proportion","getSeries","stepSize","series","contents","title","legend","colour","colours","scale","getAxisGridlines","y","yGridlines","xGridlines","dates","getAxisValues","applyFormat","yAxis","xAxisQualitative","xAxisQuantitative","xAxisMinimal","xAxis","tooltip","groupIndex","labelIndex","axisValues","getAxisValuesBase","numValues","numberFormat","Intl","NumberFormat","format","dateFormat","DateTimeFormat","bar","bars","renderBars","line","lines","scaleY","scaleX","points","leftPercent","str","renderLines","example","run","codebookSet","classes","$currentBlock","_runSetEvent","$runSetButton","setAttribute","csv","analyser","then","classList","remove","catch","reason","querySelector","String","finally","_markAsCurrentBlock","_markAsCurrentBlockOnArrowDown","_clearCurrentBlock","addEventListener","preventDefault","range","getSelection","getRangeAt","deleteContents","insertNode","createTextNode","collapse","level","pattern","RegExp","trim"],"sourceRoot":""}