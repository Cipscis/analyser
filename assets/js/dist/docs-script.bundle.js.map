{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/analyser/webpack/bootstrap","webpack://@cipscis/analyser/webpack/runtime/define property getters","webpack://@cipscis/analyser/webpack/runtime/hasOwnProperty shorthand","webpack://@cipscis/analyser/webpack/runtime/make namespace object","webpack://@cipscis/analyser/./node_modules/@cipscis/codebook/dist/codebook.js","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/stringify.js","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/parse.js","webpack://@cipscis/analyser/./src/FileConfig.ts","webpack://@cipscis/analyser/./src/AnalyserRows.ts","webpack://@cipscis/analyser/./src/helpers.ts","webpack://@cipscis/analyser/./src/AnalyserGroup.ts","webpack://@cipscis/analyser/./src/filtering.ts","webpack://@cipscis/analyser/./src/transformers.ts","webpack://@cipscis/analyser/./src/file-processing.ts","webpack://@cipscis/analyser/./src/grouping.ts","webpack://@cipscis/analyser/./src/statistics.ts","webpack://@cipscis/analyser/./src/charts/ChartData.ts","webpack://@cipscis/analyser/./src/charts/Scale.ts","webpack://@cipscis/analyser/./src/charts/chart.ts","webpack://@cipscis/analyser/./src/charts/bar.ts","webpack://@cipscis/analyser/./src/charts/line.ts","webpack://@cipscis/analyser/./docs/assets/js/src/docs-script.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const selectors = Object.freeze({\r\n    block: '.js-codebook__block',\r\n    set: '.js-codebook__set',\r\n    inert: '.js-codebook__inert',\r\n});\r\nconst dataAttributes = Object.freeze({\r\n    set: 'data-codebook-set',\r\n    index: 'data-codebook-index',\r\n    log: 'data-codebook-log',\r\n    html: 'data-codebook-html',\r\n});\r\nconst defaultSetName = 'default';\r\n// Create a single textarea element for decoding HTML\r\nconst $textarea = document.createElement('textarea');\r\n/**\r\n * Run all Codebook blocks in all Codebook sets in order, with any specified external arguments made available.\r\n */\r\nexport function run(args) {\r\n    return new Promise((resolve, reject) => {\r\n        const sets = _createCodeSets(args);\r\n        const promises = [];\r\n        for (let setName in sets) {\r\n            const set = sets[setName];\r\n            promises.push(_runSet(set));\r\n        }\r\n        Promise.all(promises)\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n}\r\nexport async function runSet(setNameOrArgs, argsParam) {\r\n    let setName;\r\n    let args = undefined;\r\n    // Figure out which arguments were passed.\r\n    if (typeof setNameOrArgs === 'string') {\r\n        setName = setNameOrArgs;\r\n        if (argsParam) {\r\n            args = argsParam;\r\n        }\r\n    }\r\n    else {\r\n        // If no set name was specified, use the default set name.\r\n        setName = defaultSetName;\r\n        if (setNameOrArgs) {\r\n            args = setNameOrArgs;\r\n        }\r\n    }\r\n    const sets = _createCodeSets(args);\r\n    if (setName in sets) {\r\n        const set = sets[setName];\r\n        return _runSet(set);\r\n    }\r\n    else {\r\n        throw new RangeError(`Codebook: Cannot run unrecognised set '${setName}'`);\r\n    }\r\n}\r\n/**\r\n * Adjust the indentation of Codebook sets so it appears correctly when viewed on a page.\r\n */\r\nexport function tidy() {\r\n    const $blocks = document.querySelectorAll(`${selectors.block}, ${selectors.inert}`);\r\n    for (let $block of $blocks) {\r\n        const code = $block.innerHTML;\r\n        // Look for tab indentation only\r\n        const match = code.match(/^(\\t*)\\S/m);\r\n        if (match) {\r\n            const indentation = match[1];\r\n            const level = indentation.length;\r\n            const pattern = new RegExp(`^\\\\t{${level}}`, 'gm');\r\n            $block.innerHTML = code.replace(pattern, '').trim();\r\n        }\r\n    }\r\n    ;\r\n}\r\n/**\r\n * Gathers all Codebook sets, and sorts blocks within their sets according to their index where applicable.\r\n */\r\nfunction _createCodeSets(args) {\r\n    const sets = _gatherSetBlocks(args);\r\n    // Loop through created sets and sort their blocks by index\r\n    for (let setName in sets) {\r\n        const set = sets[setName];\r\n        _sortCodeBlocks(set);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Gathers all Codebook blocks according to the order in which they appear in the markup,\r\n * and adds them to the set they belong to.\r\n */\r\nfunction _gatherSetBlocks(args) {\r\n    const $blocks = document.querySelectorAll(selectors.block);\r\n    const setNames = [];\r\n    const sets = {};\r\n    // Loop through all elements and add them to the right set\r\n    for (let $block of $blocks) {\r\n        const setName = _getSetName($block);\r\n        let set;\r\n        if (setNames.includes(setName)) {\r\n            set = sets[setName];\r\n        }\r\n        else {\r\n            setNames.push(setName);\r\n            set = _createNewSet(args);\r\n            sets[setName] = set;\r\n        }\r\n        set.blocks.push($block);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Sorts Codebook blocks according to their index data attribute, if they have one.\r\n */\r\nfunction _sortCodeBlocks(set) {\r\n    // If any blocks have an explicit index, sort them\r\n    set.blocks.sort(($blockA, $blockB) => {\r\n        const iA = $blockA.getAttribute(dataAttributes.index);\r\n        const iB = $blockB.getAttribute(dataAttributes.index);\r\n        if (iA === iB) {\r\n            return 0; // Leave the order unchanged\r\n        }\r\n        else if (iA !== null && iB === null) {\r\n            return -1; // Put $blockA first\r\n        }\r\n        else if (iA === null && iB !== null) {\r\n            return +1; // Put $blockB first\r\n        }\r\n        else {\r\n            // Neither index is null\r\n            return (+iA) - (+iB); // Put the code with the lower index first\r\n        }\r\n    });\r\n}\r\n/**\r\n * Creates a new Codebook set.\r\n */\r\nfunction _createNewSet(args) {\r\n    args = args || {};\r\n    return {\r\n        blocks: [],\r\n        args: Object.assign({}, args),\r\n    };\r\n}\r\n/**\r\n * Clears a set's logs, then runs each block within it with the `log` and `html` utility functions available.\r\n */\r\nfunction _runSet(set) {\r\n    const code = set.blocks.reduce(_combineCode, '');\r\n    _clearLogs(set);\r\n    const args = set.args;\r\n    const [argNames, argValues] = _spreadArgs(args);\r\n    if (argNames.includes('_log') ||\r\n        argNames.includes('_$log') ||\r\n        argNames.includes('log') ||\r\n        argNames.includes('_html') ||\r\n        argNames.includes('_$html') ||\r\n        argNames.includes('html')) {\r\n        throw new Error(`Codebook: The following argument names are reserved and cannot be used:\\n'_log', '_$log', 'log', '_html', '_$html', 'html'`);\r\n    }\r\n    const fnFactory = Function.apply(null, argNames.concat(['_log', '_html', `\r\n\t\treturn async () => {\r\n\t\t\t'use strict';\r\n\r\n\t\t\tlet _$log = null;\r\n\t\t\tlet log = function () {};\r\n\r\n\t\t\tlet _$html = null;\r\n\t\t\tlet html = function () {};\r\n\r\n\t\t\t${code}\r\n\t\t};\r\n\t`]));\r\n    const fn = fnFactory.apply(null, argValues.concat([_logOutput, _htmlOutput]));\r\n    return fn();\r\n}\r\n/**\r\n * Clears the contents of all log elements for each block in a given Codebook set.\r\n */\r\nfunction _clearLogs(set) {\r\n    for (let $block of set.blocks) {\r\n        const logId = $block.getAttribute(dataAttributes.log);\r\n        if (logId) {\r\n            const $log = document.getElementById(`${logId}`);\r\n            if ($log) {\r\n                $log.innerHTML = '';\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Converts a CodebookSetArgs object into separate arrays of its arguments' names and values.\r\n */\r\nfunction _spreadArgs(args) {\r\n    const names = Object.keys(args);\r\n    const values = Object.values(args);\r\n    return [\r\n        names,\r\n        values,\r\n    ];\r\n}\r\n/**\r\n * To be used with `Array.prototype.reduce`, combines the code for all blocks within\r\n * a Codebook set and ensures the special `log` and `html` functions always have correct values.\r\n */\r\nfunction _combineCode(allCode, $newCode) {\r\n    let newCode = _decodeHtml($newCode.textContent || '');\r\n    const logId = $newCode.getAttribute(dataAttributes.log);\r\n    if (logId) {\r\n        newCode = `\r\n\t\t\t_$log = document.getElementById('${logId}');\r\n\t\t\tlog = function (...output) {\r\n\t\t\t\t_log(_$log, ...output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\tlog = function () {};\r\n\t\t`;\r\n    }\r\n    const htmlId = $newCode.getAttribute(dataAttributes.html);\r\n    if (htmlId) {\r\n        newCode = `\r\n\t\t\t_$html = document.getElementById('${htmlId}');\r\n\t\t\thtml = function (output) {\r\n\t\t\t\t_html(_$html, output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\thtml = function () {};\r\n\t\t`;\r\n    }\r\n    const combinedCode = `${allCode}\\n${newCode}`;\r\n    return combinedCode;\r\n}\r\n/**\r\n * Read the name of a Codebook block's set.\r\n */\r\nfunction _getSetName($block) {\r\n    let setName = $block.getAttribute(dataAttributes.set);\r\n    if (!setName) {\r\n        const $parent = $block.closest(selectors.set);\r\n        if ($parent) {\r\n            setName = $parent.getAttribute(dataAttributes.set);\r\n        }\r\n        if (!setName) {\r\n            setName = defaultSetName;\r\n        }\r\n    }\r\n    return setName;\r\n}\r\n/**\r\n * A helper function used to create the special `log` function, allowing values inside\r\n * Codebook blocks to be logged to that block's log element.\r\n */\r\nfunction _logOutput($log, ...output) {\r\n    if ($log) {\r\n        output.forEach((outputEl) => {\r\n            let outputString;\r\n            if (outputEl instanceof Date) {\r\n                function padZeroes(num, minLength = 2) {\r\n                    let numStr = num.toString();\r\n                    while (numStr.length < minLength) {\r\n                        numStr = `0${numStr}`;\r\n                    }\r\n                    return numStr;\r\n                }\r\n                const year = outputEl.getFullYear();\r\n                const month = padZeroes(outputEl.getMonth() + 1);\r\n                const day = padZeroes(outputEl.getDate());\r\n                outputString = `${year}-${month}-${day}`;\r\n                if (outputEl.getHours() || outputEl.getMinutes() || outputEl.getSeconds()) {\r\n                    const hours = padZeroes(outputEl.getHours());\r\n                    const minutes = padZeroes(outputEl.getMinutes());\r\n                    const seconds = padZeroes(outputEl.getSeconds());\r\n                    outputString += ` ${hours}:${minutes}:${seconds}`;\r\n                }\r\n            }\r\n            else if (typeof outputEl === 'object') {\r\n                outputString = JSON.stringify(outputEl, null, '\\t');\r\n            }\r\n            else if (typeof outputEl === 'string') {\r\n                outputString = outputEl;\r\n            }\r\n            else {\r\n                // Can't rely on everything having a `toString` method, so use type coercion.\r\n                outputString = '' + outputEl;\r\n            }\r\n            $log.innerHTML += `${outputString}\\n`;\r\n        });\r\n    }\r\n}\r\n/**\r\n * A helper function used to create the special `html` function, allowing values inside\r\n * Codebook blocks to be logged to that block's html element.\r\n */\r\nfunction _htmlOutput($html, output) {\r\n    if ($html) {\r\n        $html.innerHTML = output;\r\n    }\r\n}\r\n/**\r\n * Decode HTML entities in a string by applying it as the value\r\n * of an HTMLTextAreaElement then reading it back again.\r\n */\r\nfunction _decodeHtml(htmlString) {\r\n    // We don't want to see things like =&gt; in code when we really mean =>\r\n    $textarea.innerHTML = htmlString;\r\n    const decodedString = $textarea.value;\r\n    return decodedString;\r\n}\r\n//# sourceMappingURL=codebook.js.map","/**\r\n * Converts a 2D Array into a CSV string.\r\n *\r\n * `stringify` converts most falsey values into empty cells. `undefined`, `''`, and `[]` are all treated this way. `null` and `false`, however, are converted into string representations when stringifying CSV data.\r\n *\r\n * If you need to maintain a value of `undefined`, `''`, or `[]` when stringifying your CSV data, convert it to a string first (e.g. `'undefined'`)\r\n *\r\n * @param {any[][]} data - A 2D Array to convert into a CSV string.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} CSV string\r\n */\r\nfunction stringify(data, options) {\r\n    options = options || {};\r\n    options.transpose = options.transpose || false;\r\n    options.sanitise = options.sanitise || false;\r\n    // Enforce square data and apply CSV escaping, then convert to string\r\n    const rows = data;\r\n    const shapedRows = _shape(data, options);\r\n    const escapedRows = _escape(shapedRows, options);\r\n    const joinedRows = _join(escapedRows);\r\n    return joinedRows;\r\n}\r\n/**\r\n * Pad missing cells with empty strings and, if necessary, transpose the data\r\n *\r\n * @param {any[][]} data - A 2D Array to pad and potentially transpose.\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {any[][]} Shaped CSV data\r\n */\r\nfunction _shape(data, options) {\r\n    const transpose = options?.transpose ?? false;\r\n    const maxLength = data.reduce((maxLength, row) => Math.max(maxLength, row.length), 0);\r\n    // Flip rows and columns if transposing data\r\n    const iMax = transpose ? maxLength : data.length;\r\n    const jMax = transpose ? data.length : maxLength;\r\n    const rows = [];\r\n    for (let i = 0; i < iMax; i++) {\r\n        const row = [];\r\n        for (let j = 0; j < jMax; j++) {\r\n            const iRow = transpose ? j : i;\r\n            const iCol = transpose ? i : j;\r\n            let cellValue = data[iRow][iCol];\r\n            if (iCol >= data[iRow].length) {\r\n                cellValue = '';\r\n            }\r\n            row.push(cellValue);\r\n        }\r\n        rows.push(row);\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any[][]} rows - A 2D Array with values to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string[][]} Escaped CSV data\r\n */\r\nfunction _escape(rows, options) {\r\n    for (const row of rows) {\r\n        for (let j = 0; j < row.length; j++) {\r\n            row[j] = _escapeCell(row[j], options);\r\n        }\r\n    }\r\n    return rows;\r\n}\r\n/**\r\n * Make sure any cells containing \" or , or a newline are escaped appropriately\r\n *\r\n * @param {any} cell - A single value to escape\r\n * @param {StringifyOptions} [options] - An object containing stringify options.\r\n *\r\n * @return {string} Escaped value\r\n */\r\nfunction _escapeCell(cell, options) {\r\n    const sanitise = options?.sanitise ?? false;\r\n    // Convert to string\r\n    let cellString;\r\n    if (typeof cell === 'undefined') {\r\n        // Replace undefined with ''\r\n        cellString = '';\r\n    }\r\n    else if (typeof cell !== 'string') {\r\n        // Convert to string\r\n        cellString = '' + cell;\r\n    }\r\n    else {\r\n        cellString = cell;\r\n    }\r\n    // Sanitise\r\n    if (sanitise) {\r\n        // Prevent spreadsheet software like\r\n        // Excel from trying to execute code\r\n        if (cellString.match(/^[=\\-+@]/)) {\r\n            cellString = '\\t' + cell;\r\n        }\r\n    }\r\n    // Escape\r\n    if (cellString.match(/,|\"|\\n|\\r/)) {\r\n        // Turn any double quotes into escaped double quotes\r\n        cellString = cellString.replace(/\"/g, '\"\"');\r\n        // Wrap cell in double quotes\r\n        cellString = '\"' + cellString + '\"';\r\n    }\r\n    return cellString;\r\n}\r\n/**\r\n * Join escaped CSV data into a single string.\r\n *\r\n * @param  {string[][]} rows - A 2D Array containing escaped CSV data\r\n *\r\n * @return {string} A CSV string\r\n */\r\nfunction _join(rows) {\r\n    const rowStrings = [];\r\n    for (let i = 0; i < rows.length; i++) {\r\n        rowStrings.push(rows[i].join(','));\r\n    }\r\n    const rowsString = rowStrings.join('\\n');\r\n    return rowsString;\r\n}\r\nexport { stringify };\r\n//# sourceMappingURL=stringify.js.map","function parse(csvString, mapper) {\r\n    const stringRows = _tokenise(csvString);\r\n    _validate(stringRows);\r\n    if (typeof mapper !== 'undefined') {\r\n        const dataRows = stringRows.map((row) => row.map(mapper));\r\n        return dataRows;\r\n    }\r\n    else {\r\n        return stringRows;\r\n    }\r\n}\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString) {\r\n    // Walk through each character and produce an array of tokens\r\n    const tokens = [];\r\n    // Remove carriage returns\r\n    csvString = csvString.replace(/\\r/g, '');\r\n    let inQuote = false;\r\n    let wasQuote = false;\r\n    let tokenStart = 0;\r\n    let row = [];\r\n    for (let i = 0; i < csvString.length; i++) {\r\n        const char = csvString[i];\r\n        const comma = char === ',';\r\n        const quote = char === '\"';\r\n        const newline = char === '\\n';\r\n        const eof = i === csvString.length - 1; // eof - End Of File\r\n        if (inQuote) {\r\n            // Characters may be delimited\r\n            if (quote) {\r\n                // Check if the next character is another double quote, i.e. if it is escaped\r\n                const nextChar = csvString[i + 1];\r\n                if (nextChar === '\"') {\r\n                    // This and the next character combined make an escaped double quote,\r\n                    // so the quote has not ended and we should skip over the next character\r\n                    i++;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // The quote has ended\r\n                    inQuote = false;\r\n                    wasQuote = true;\r\n                    if (!eof) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            else if (eof) {\r\n                throw new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n            }\r\n        }\r\n        if (!inQuote && (comma || newline || eof)) {\r\n            // These are the characters that denote the end of a token\r\n            let token = csvString.substring(tokenStart, i + 1);\r\n            if (comma || newline) {\r\n                // Don't keep the separator\r\n                token = token.substring(0, token.length - 1);\r\n            }\r\n            if (wasQuote) {\r\n                wasQuote = false;\r\n                // Remove start and end quotes\r\n                token = token.substring(1, token.length - 1);\r\n                // Replace escaped quotes\r\n                token = token.replace(/\"\"/g, '\"');\r\n            }\r\n            row.push(token);\r\n            if (comma && eof) {\r\n                // It's the end of the last token, and the last cell is empty\r\n                row.push('');\r\n            }\r\n            if (newline || eof) {\r\n                tokens.push(row);\r\n                if (newline) {\r\n                    row = [];\r\n                }\r\n            }\r\n            tokenStart = i + 1;\r\n        }\r\n        else if (wasQuote) {\r\n            throw new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n        }\r\n        else if (quote) {\r\n            inQuote = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows) {\r\n    // Each row of a CSV should have the same length;\r\n    if (rows && rows.length > 1) {\r\n        let rowLength = rows[0].length;\r\n        for (let i = 1; i < rows.length; i++) {\r\n            let row = rows[i];\r\n            if (row.length !== rowLength) {\r\n                throw new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport { parse };\r\n//# sourceMappingURL=parse.js.map","import { TransformerFn } from './transformers.js';\n\ninterface FileConfig<T extends string> {\n\tpath: string,\n\tcols: Record<T, string | number>,\n\n\theaderRows?: number,\n\tfooterRows?: number,\n\tignoreRows?: (row: string[], cols: Record<T, number>) => boolean,\n\n\taliases?: string[][],\n\ttransform?: Partial<Record<T, TransformerFn<unknown>>>,\n}\n\n/**\n * Use this function when creating a FileConfig object.\n *\n * It is a noop function, but it's necessary to use a function here\n * in order for the TypeScript compiler to correctly infer the type of T\n */\nconst fileConfig = <T extends string>(fileConfig: FileConfig<T>) => fileConfig;\n\nexport { FileConfig, fileConfig };\n","interface AnalyserRows {\n\tfilter(...args: Parameters<typeof Array.prototype.filter>): this;\n}\n\nclass AnalyserRows extends Array<unknown[]> {\n\tconstructor(source?: unknown[][] | number) {\n\t\tif (Array.isArray(source)) {\n\t\t\tsuper(source.length);\n\t\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\t\tthis[i] = source[i];\n\t\t\t}\n\t\t} else if (typeof source === 'number') {\n\t\t\tsuper(source);\n\t\t} else {\n\t\t\tsuper();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the specified column.\n\t */\n\tgetCol(colNum: number): unknown[] {\n\t\tif (typeof colNum !== 'number') {\n\t\t\tthrow new TypeError(`colNum must be a number.`);\n\t\t} else if (colNum < 0 || colNum >= this[0]?.length) {\n\t\t\tthrow new RangeError(`colNum out of range.`);\n\t\t}\n\n\t\tconst col: unknown[] = [];\n\t\tfor (const row of this) {\n\t\t\tcol.push(row[colNum]);\n\t\t}\n\n\t\treturn col;\n\t}\n\n\t/**\n\t * Adds a new column to AnalyserRows, and returns its index.\n\t */\n\taddCol<T>(creator: (row: unknown[], index: number) => T): number\n\taddCol<T>(newRow: T[]): number\n\taddCol<T>(creator: ((row: unknown[], index: number) => T) | T[]): number {\n\t\tconst colIndex = this[0].length;\n\n\t\tif (Array.isArray(creator)) {\n\t\t\tif (this.length !== creator.length) {\n\t\t\t\tthrow new Error(`New column of length ${creator.length} cannot be added. It must be of length ${this.length}.`);\n\t\t\t}\n\n\t\t\tfor (const [i, row] of this.entries()) {\n\t\t\t\trow.push(creator[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [i, row] of this.entries()) {\n\t\t\t\trow.push(creator(row, i));\n\t\t\t}\n\t\t}\n\n\t\treturn colIndex;\n\t}\n}\n\nexport { AnalyserRows };\n","/**\n * Convert a column heading from spreadsheet software to its integer representation. For example, converts 'A' to 0, or 'ZE' to 680.\n *\n * If a non-negative integer is passed, it will be returned untransformed. Any other value, including an invalid string, will return null.\n */\nfunction getColNumber<T extends number>(colName: T): T | null\nfunction getColNumber<T extends string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null {\n\tif (typeof colName === 'number') {\n\t\tif (Number.isInteger(colName) && colName >= 0) {\n\t\t\treturn colName;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t} else if (colName === '') {\n\t\treturn null;\n\t} else if (typeof colName !== 'string') {\n\t\treturn null;\n\t}\n\n\tconst alphabet: readonly string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\tlet rowNumber = -1; // Adjust for 0-based counting\n\n\tconst upperColName = colName.toUpperCase();\n\tfor (let i = 0; i < upperColName.length; i++) {\n\t\tconst char = upperColName[i];\n\t\tconst charIndex = alphabet.indexOf(char);\n\n\t\tif (charIndex === -1) {\n\t\t\t// colName contains an invalid character\n\t\t\treturn null;\n\t\t}\n\n\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\n\t}\n\n\treturn rowNumber;\n}\n\n/**\n * Converts a map of column names to column identifiers using getColNumbers so all column identifiers are integers.\n *\n * Any columns with invalid identifiers will be removed from the result.\n */\nfunction getColNumbers<T extends string>(colsConfig: Record<T, number | string>): Record<T, number> {\n\tconst newCols: Partial<Record<T, number>> = {};\n\n\tfor (const key in colsConfig) {\n\t\tconst value = colsConfig[key];\n\t\tconst colNumber = getColNumber(value);\n\n\t\tif (typeof colNumber === 'number') {\n\t\t\tnewCols[key] = colNumber;\n\t\t}\n\t}\n\n\treturn newCols as Record<T, number>;\n}\n\nexport {\n\tgetColNumber,\n\tgetColNumbers,\n};\n","import { AnalyserRows } from './AnalyserRows.js';\n\n/**\n * A function for summarising a set of AnalyserRows\n */\ntype AnalyserSummariser<T = unknown, G = unknown> = (rows: AnalyserRows, groupName: G) => T;\n\n/**\n * A group of AnalyserSummariser functions\n */\ntype AnalyserSummarisers<SummaryName extends string> = Record<SummaryName, AnalyserSummariser>;\n\nconst defaultSummarisers = {\n\tCount: (rows: AnalyserRows) => rows.length,\n} as const;\ntype DefaultSummaryName = keyof typeof defaultSummarisers;\n\n/**\n * A 2D array of the results of AnalyserSummariser functions applied to an AnalyserGroup of AnalyserRows,\n * able to be printed to the console using `console.table`.\n *\n * After the first header row, each row represents a set of AnalyserRows grouped by the value given in the first cell.\n * After the first column, each column represents a summary of a group of AnalyserRows. The name of the summary is given in the first cell.\n */\nexport type AnalyserSummary<SummaryName extends string> = [[unknown, ...SummaryName[]], ...[unknown, ...unknown[]][]];\n\ninterface AnalyserGroupOptions {\n\tdiscrete?: boolean,\n}\n\nexport class AnalyserGroup extends Map<unknown, AnalyserRows> {\n\t#discrete: boolean;\n\n\tconstructor(options?: AnalyserGroupOptions) {\n\t\tsuper();\n\n\t\tif (typeof options?.discrete === 'boolean') {\n\t\t\tthis.#discrete = options.discrete;\n\t\t} else {\n\t\t\tthis.#discrete = true;\n\t\t}\n\t}\n\n\t/**\n\t * Create a 2D summary array that can be printed using console.table.\n\t */\n\tsummarise(): AnalyserSummary<DefaultSummaryName>\n\tsummarise<SummaryName extends string>(summarisers: AnalyserSummarisers<SummaryName>): AnalyserSummary<SummaryName>\n\tsummarise<SummaryName extends string>(summarisersArg?: AnalyserSummarisers<SummaryName>): AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName> {\n\t\t// If there was no argument, use a default value instead. This will affect the return type, as per the overloads\n\t\tconst summarisers = summarisersArg ?? defaultSummarisers;\n\n\t\tconst summaryNames = Object.keys(summarisers) as (DefaultSummaryName)[] | SummaryName[];\n\t\tconst summaryHeaderRow = ['Value', ...summaryNames] as const;\n\n\t\tlet summaryValueRows: [unknown, ...unknown[]][] = [];\n\t\tfor (const [groupName, rows] of this.entries()) {\n\t\t\tconst summaryRow: [unknown, ...unknown[]] = [groupName];\n\n\t\t\tfor (const [, summariser] of Object.entries<AnalyserSummariser>(summarisers)) {\n\t\t\t\tconst rowSummary = summariser(rows, groupName);\n\t\t\t\tsummaryRow.push(rowSummary);\n\t\t\t}\n\n\t\t\tsummaryValueRows.push(summaryRow);\n\t\t}\n\n\t\tif (this.#discrete) {\n\t\t\t// Sort summary based on its values\n\n\t\t\t// Use basic Array.prototype.sort to sort numbers or strings, to use as a reference when sorting the summary\n\t\t\tconst summaryValues = summaryValueRows.map((summaryRow) => summaryRow[0]);\n\t\t\tconst summaryValuesSorted = summaryValues.sort();\n\n\t\t\t// Sort summary value rows using the sorted values as a reference\n\t\t\tsummaryValueRows = summaryValueRows.sort((a, b) => summaryValuesSorted.indexOf(a[0]) - summaryValuesSorted.indexOf(b[0]));\n\t\t}\n\n\t\tconst summary = [summaryHeaderRow, ...summaryValueRows];\n\n\t\t// Let the overloads tell TypeScript which type the summary actually is.\n\t\t// If there was no `summarisersArg` argument, it will be AnalyserSummary<DefaultSummaryNames>,\n\t\t// otherwise the type T could be inferred so no default was necessary and it will be AnalyserSummary<SummaryName>\n\t\treturn summary as AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName>;\n\t}\n}\n","// This type actually just resolves to `unknown`, which isn't really correct.\n// It's intended to to only allow functions of the form (value: unknown) => boolean\n// and 1D arrays, but it needs to be able to accept values of type `unknown`.\n// This shortcoming is accounted for by a type check that potentially throws a TypeError\ntype FilterInput = ((value: unknown) => boolean) | unknown[] | Exclude<unknown, []>\n\n/**\n * A function used by Array.prototype.filter\n */\ninterface FilterResolver {\n\t(val: unknown[], index: number, arr: unknown[][]): boolean,\n}\n\n/**\n * A FilterResolver that can be extended using FilterResolverExtender methods\n */\ninterface ExtensibleFilterResolver extends FilterResolver {\n\tandBy: FilterResolverExtender,\n\torBy: FilterResolverExtender,\n}\n\n/**\n * A function that either creates a new FilterResolver or extends and existing one, embedding information about the column to look at and the values to match.\n */\ninterface FilterResolverExtender {\n\t(colIndex: number, values: FilterInput): ExtensibleFilterResolver,\n}\n\n/**\n * Creates a function that remembers a set of aliases, and can be called\n * to create a function that can be used with Array.prototype.filter to\n * use that alias when filtering a set of data using _applyFilter.\n */\nfunction createFilterFn(aliases?: string[][]): FilterResolverExtender {\n\tconst by = function (colIndex: number, values: FilterInput) {\n\t\tconst applyFilterToRow: FilterResolver = function (row, index, arr) {\n\t\t\treturn _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst extendedApplyFilterToRow = _extendFilterFn(applyFilterToRow, aliases);\n\n\t\treturn extendedApplyFilterToRow;\n\t};\n\n\treturn by;\n}\n\n/**\n * Extend a FilterResolver into an ExtensibleFilterResolver, including embedding an optional set of aliases.\n */\nfunction _extendFilterFn(filterResolver: FilterResolver, aliases?: string[][]): ExtensibleFilterResolver {\n\tconst extendedFilterResolver = filterResolver as ExtensibleFilterResolver;\n\n\textendedFilterResolver.andBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) && _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\textendedFilterResolver.orBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) || _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\treturn extendedFilterResolver;\n}\n\n/**\n * Applies a filter to a specific row, looking at a specified column index\n * and checking its value against either a specific value, a set of values,\n * or a function.\n *\n * If the value or values being checked against are strings, a set of\n * aliases can be used as well.\n */\nfunction _applyFilter(row: unknown[], colIndex: number, values: FilterInput, aliases?: string[][]): boolean {\n\tif (typeof values === 'function') {\n\t\tconst valueMatch: unknown = values(row[colIndex]);\n\n\t\tif (typeof valueMatch === 'boolean') {\n\t\t\treturn valueMatch;\n\t\t} else {\n\t\t\tthrow new TypeError(`The \\`by\\` filter method only accepts a function for its \\`values\\` argument if it returns a boolean value.`);\n\t\t}\n\t}\n\n\tconst valuesArr = Array.isArray(values) ? values as unknown[] : [values];\n\n\tconst cell = row[colIndex];\n\tconst cellValues = Array.isArray(cell) ? cell as unknown[] : [cell];\n\n\tfor (const cellValue of cellValues) {\n\t\tfor (const value of valuesArr) {\n\t\t\tif (_matchAlias(value, cellValue, aliases)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Checks if the value of a cell matches the value passed,\n * optionally taking one or more sets of aliases to match.\n */\nfunction _matchAlias(cell: unknown, value: unknown, aliases?: string[][]): boolean {\n\tif (cell === value) {\n\t\treturn true;\n\t}\n\n\tif (aliases && typeof cell === 'string' && typeof value === 'string') {\n\t\tfor (const aliasList of aliases) {\n\t\t\tif (aliasList.includes(cell) && aliasList.includes(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport {\n\tcreateFilterFn,\n\n\tFilterResolverExtender,\n\tExtensibleFilterResolver,\n};\n","//////////////////////////\n// Appearance functions //\n//////////////////////////\n\nexport interface TransformerFn<T> {\n\t(value: string, locationIdentifier?: string): T extends unknown[] ? T : (T | null)\n}\n\n/**\n * Checks if a string appears like it represents true\n */\nfunction appearsTrue(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'true';\n}\n\n/**\n * Checks if a string appears like it represents false\n */\nfunction appearsFalse(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'false';\n}\n\n/**\n * Checks if a string appears like it represents a boolean vaue\n */\nfunction appearsBoolean(value: string): boolean {\n\treturn appearsTrue(value) || appearsFalse(value);\n}\n\ntype NoCommas<T extends string> = T extends `${infer U},${infer V}` ? NoCommas<`${U}${V}`> : T;\ntype NoPercent<T extends string> = T extends `${infer W}%` ? W : T;\ntype CleanNumberLike<T extends string> = NoCommas<NoPercent<T>>;\n\n/**\n * Removes any ',' characters, and any '%' at the end of\n * a string that may appear like it represents a number\n */\nfunction cleanNumberLike<T extends string>(value: T): CleanNumberLike<T> {\n\tconst cleanValue = value.replace(/,|%$/g, '') as CleanNumberLike<T>;\n\treturn cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a number\n */\nfunction appearsNumber(value: string): boolean {\n\tconst cleanValue = cleanNumberLike(value);\n\n\treturn parseFloat(cleanValue) === +cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a percentage\n */\nfunction appearsPercentage(value: string): boolean {\n\treturn appearsNumber(value) && !!value.match(/%$/);\n}\n\n///////////////////////////\n// Transformer functions //\n///////////////////////////\n\n/**\n * Splits a string into an array using String.prototype.split\n */\nexport function array(separator: string | RegExp, limit?: number): TransformerFn<string[]> {\n\treturn function (value: string): string[] {\n\t\treturn value.split(separator, limit);\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation using a custom definition.\n *\n *  If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport function booleanCustom(truthy: string | RegExp = 'true', falsey: string | RegExp = 'false'): TransformerFn<boolean> {\n\treturn function (value: string, locationIdentifier?: string): boolean | null {\n\t\tconst cleanedValue = value.trim().toLowerCase();\n\n\t\tif (typeof truthy === 'string') {\n\t\t\tif (cleanedValue === truthy.trim().toLowerCase()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (truthy.test(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof falsey === 'string') {\n\t\t\tif (cleanedValue === falsey.trim().toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (falsey.test(value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (value) {\n\t\t\tconsole.warn(`Boolean value not found in '${value}', checking for ${truthy} or ${falsey}${locationIdentifier ? `(${locationIdentifier})` : ''}`);\n\t\t}\n\t\treturn null;\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation, if it contains one.\n *\n * If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport const boolean = booleanCustom();\n\n/**\n * Extracts a number from a string representation, if it contains one.\n * Strings ending with '%' are treated as percentages and divided by 100.\n *\n * If the value doesn't appear like it represents a number, a warning will be generated.\n */\nexport const number: TransformerFn<number> = (value: string, locationIdentifier?: string): number | null => {\n\tif (appearsNumber(value)) {\n\t\t// Condition matches if the entire string represents a number\n\n\t\tlet cleanValue: string = cleanNumberLike(value);\n\n\t\tif (appearsPercentage(value)) {\n\t\t\t// If value is a percentage string, divide by 100\n\t\t\tconst numValue = +cleanValue / 100;\n\n\t\t\t// To prevent division causing rounding errors, like\n\t\t\t// 0.10800000000000001, use string representation to\n\t\t\t// determine how to round the number.\n\n\t\t\t// Remove everything up to (and including) a radix point\n\t\t\t// e.g. convert '82.643' to '643'\n\t\t\tconst truncatedValue = cleanValue.replace(/^[^.]+\\.?/, '');\n\n\t\t\tconst precision = truncatedValue.length;\n\n\t\t\t// Add 2 to precision to compensate for dividing by 100\n\t\t\tcleanValue = numValue.toFixed(precision + 2);\n\t\t}\n\n\t\treturn +cleanValue;\n\t} else {\n\t\tif (value) {\n\t\t\tconsole.warn(`Number value not found in '${value}'${locationIdentifier ? `(${locationIdentifier})` : ''}`);\n\t\t}\n\t\treturn null;\n\t}\n};\n\n/**\n * Extracts boolean or number values from string representations if appropriate.\n *\n * No warnings will be generated if the value doesn't appear like a boolean or number.\n */\nexport const value: TransformerFn<boolean | number> = (value: string, locationIdentifier?: string): boolean | number | null => {\n\tif (appearsBoolean(value)) {\n\t\treturn boolean(value);\n\t} else if (appearsNumber(value)) {\n\t\treturn number(value);\n\t} else {\n\t\tconsole.warn(`Boolean or number value not found in '${value}'${locationIdentifier ? `(${locationIdentifier})` : ''}`);\n\t\treturn null;\n\t}\n};\n\n/**\n * Checks that the value, if it exists, is a member of an enum.\n *\n * If the value does not exist, it is transformed to null.\n *\n * If a recoding map is passed, and it contains instructions for this value, it is recoded first.\n *\n * If the value exists but it is not a member of the enum and cannot be recoded,\n * a warning will be generated and null will be returned.\n */\nexport function enumValue<E extends string>(enums: Record<string, E>, recodeMap?: Record<string, E>): TransformerFn<E> {\n\tconst enumValues: E[] = Object.values(enums);\n\n\tfunction isEnumMember(val: unknown): val is E {\n\t\t// Use `as unknown[]` so TypeScript doesn't complain when using Array.prototype.includes\n\t\treturn (enumValues as unknown[]).includes(val);\n\t}\n\n\tconst transformer = ((value: string, locationIdentifier?: string) => {\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isEnumMember(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (recodeMap && value in recodeMap) {\n\t\t\tconst recodedValue = recodeMap[value];\n\t\t\treturn recodedValue;\n\t\t}\n\n\t\tconsole.warn(`Value '${value}' does not exist within ${enumValues.join(', ')}${locationIdentifier ? `(${locationIdentifier})` : ''}`);\n\t\treturn null;\n\t}) as TransformerFn<E>;\n\t// Need to use a type assertion here as TypeScript doesn't know how to use the generic constraint to resolve the conditional type\n\t// See https://stackoverflow.com/questions/70553130/typescript-generic-conditional-type-as-return-value-for-generic-function/70553240#70553240\n\n\treturn transformer;\n}\n","import { parse as parseCSV } from '@cipscis/csv';\n\nimport { AnalyserRows } from './AnalyserRows.js';\nimport { FileConfig } from './FileConfig.js';\nimport { DataConfig } from './DataConfig.js';\n\nimport { getColNumbers } from './helpers.js';\n\nimport { createGroupFn } from './grouping.js';\nimport { createFilterFn } from './filtering.js';\n\nimport * as transformers from './transformers.js';\n\n/**\n * Load a single CSV file and process its contents, then return them.\n */\nasync function loadFile<T extends string>(fileConfig: FileConfig<T>): Promise<DataConfig<T>> {\n\tconst response = await fetch(fileConfig.path);\n\n\tif (response.ok) {\n\t\tconst data = await response.text();\n\n\t\tconst rows = parseCSV(data);\n\t\tconst dataConfig = _processData(rows, fileConfig);\n\t\treturn dataConfig;\n\t} else {\n\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\n\t}\n}\n\n/**\n * Processes CSV data into a DataConfig object ready for analysis via code.\n */\nfunction _processData<T extends string>(rows: string[][], fileConfig: FileConfig<T>): DataConfig<T> {\n\t// Remove header rows\n\tif (fileConfig.headerRows) {\n\t\trows.splice(0, fileConfig.headerRows);\n\t}\n\n\t// Remove footer rows\n\tif (fileConfig.footerRows) {\n\t\trows.splice(-fileConfig.footerRows);\n\t}\n\n\tconst cols = getColNumbers(fileConfig.cols);\n\n\t// Remove any specified rows to ignore\n\tconst { ignoreRows } = fileConfig;\n\tif (ignoreRows) {\n\t\t// Find all rows that match the `ignoreRows` function\n\t\tconst rowsToIgnore = rows.filter((row) => ignoreRows(row, cols));\n\n\t\t// If we found any rows to ignore, remove them\n\t\tif (rowsToIgnore.length > 0) {\n\t\t\tfor (let i = rows.length-1; i >= 0; i--) {\n\t\t\t\tconst row = rows[i];\n\t\t\t\tif (rowsToIgnore.includes(row)) {\n\t\t\t\t\trows.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst by = createFilterFn(fileConfig.aliases);\n\tconst group = createGroupFn(by, fileConfig.aliases);\n\n\tconst dataConfig: DataConfig<T> = {\n\t\trows: new AnalyserRows(rows),\n\t\tcols,\n\t\taddedCols: {},\n\t\tby,\n\t\tgroup,\n\t};\n\n\tif (fileConfig.aliases) {\n\t\tdataConfig.aliases = fileConfig.aliases;\n\t}\n\n\tif (fileConfig.transform) {\n\t\tfor (const colName in fileConfig.transform) {\n\t\t\tif (!(colName in dataConfig.cols)) {\n\t\t\t\tconsole.warn(`Column '${colName}' specified in transform not found in cols.`);\n\t\t\t} else {\n\t\t\t\tconst colNum = dataConfig.cols[colName];\n\t\t\t\tconst transformFn = fileConfig.transform[colName];\n\n\t\t\t\t// These conditions are intended to help when TypeScript isn't being used\n\t\t\t\tif (transformFn === transformers.array) {\n\t\t\t\t\tthrow new Error(`The 'array' transformer cannot be used directly. Please pass a 'separator' argument.`);\n\t\t\t\t} else if (transformFn === transformers.booleanCustom) {\n\t\t\t\t\tthrow new Error(`The 'booleanCustom' transformer cannot be used directly. Please invoke it to create a transformer function.`);\n\t\t\t\t// @ts-expect-error This check is only intended to catch errors if an incorrectly typed value is passed\n\t\t\t\t} else if (transformFn === transformers.enumValue) {\n\t\t\t\t\tthrow new Error(`The 'enumValue' transformer cannot be used directly. Please pass an 'enums' argument.`);\n\t\t\t\t}\n\n\t\t\t\tfor (const [index, row] of rows.entries()) {\n\t\t\t\t\tif (transformFn) {\n\t\t\t\t\t\tconst locationIdentifier = `column ${colName}, row ${index}`;\n\t\t\t\t\t\tdataConfig.rows[index][colNum] = transformFn(row[colNum], locationIdentifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dataConfig;\n}\n\nexport { loadFile };\n","import { AnalyserRows } from './AnalyserRows.js';\nimport { FilterResolverExtender, ExtensibleFilterResolver } from './filtering.js';\n\nimport { AnalyserGroup } from './AnalyserGroup.js';\n\ninterface Grouper {\n\t(rows: AnalyserRows, colNum: number): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, numGroups: number, right?: boolean): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, splitPoints: number[], right?: boolean): AnalyserGroup\n}\n\n/**\n * Creates a function that uses a FilterResolverExtender with an embedded\n * set of aliases, to create a summarisable group of AnalyserRows split\n * based on the specified column.\n */\nfunction createGroupFn(by: FilterResolverExtender, aliases?: string[][]): Grouper {\n\tconst grouperFn: Grouper = function (rows: AnalyserRows, colNum: number, splitting?: number | number[], right: boolean = true): AnalyserGroup {\n\t\t// First, collect enums\n\t\tconst enums: Set<unknown> = new Set();\n\t\tfor (const row of rows) {\n\t\t\tconst cellValue = row[colNum];\n\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\tfor (const value of cellValue) {\n\t\t\t\t\tenums.add(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenums.add(cellValue);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof splitting === 'undefined') {\n\t\t\t// Treat data as discrete\n\n\t\t\tif (aliases) {\n\t\t\t\tfor (const val of enums) {\n\t\t\t\t\tif (typeof val === 'string') {\n\t\t\t\t\t\t// If the value is a string in one or more alias sets,\n\t\t\t\t\t\t// ensure those sets will be used for grouping and\n\t\t\t\t\t\t// ensure only canonical values will be checked directly.\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and is **not** the canonical value */\n\t\t\t\t\t\tlet isNonCanonical = false;\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and **is** the canonical value */\n\t\t\t\t\t\tlet isCanonical = false;\n\n\t\t\t\t\t\tfor (const aliasList of aliases) {\n\t\t\t\t\t\t\tif (aliasList.includes(val)) {\n\t\t\t\t\t\t\t\tif (aliasList[0] === val) {\n\t\t\t\t\t\t\t\t\tisCanonical = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tisNonCanonical = true;\n\n\t\t\t\t\t\t\t\t\t// Remember the canonical value\n\t\t\t\t\t\t\t\t\tif (enums.has(aliasList[0]) === false) {\n\t\t\t\t\t\t\t\t\t\tenums.add(aliasList[0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the value is one one or more alias sets, but is never the canonical value,\n\t\t\t\t\t\t// then remove it from the set of enums to use for grouping.\n\t\t\t\t\t\tif (isCanonical === false && isNonCanonical === true) {\n\t\t\t\t\t\t\tenums.delete(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Then, interate through each enum and filter rows into groups\n\t\t\tconst group = new AnalyserGroup();\n\t\t\tfor (const val of enums) {\n\t\t\t\tconst matchingRows = rows.filter(by(colNum, val));\n\t\t\t\tgroup.set(val, matchingRows);\n\t\t\t}\n\t\t\treturn group;\n\t\t} else {\n\t\t\t// Treat data as continuous\n\n\t\t\t// Create the limits for each set\n\t\t\tconst setLimits: [number, number][] = [];\n\t\t\tif (typeof splitting === 'number') {\n\t\t\t\t// Create splitting number of groups based on values retrieved\n\n\t\t\t\tif (Number.isInteger(splitting) === false || splitting < 2) {\n\t\t\t\t\tthrow new RangeError(`The 'numGroups' argument must be an integer greater than 1.`);\n\t\t\t\t}\n\n\t\t\t\t// Sets are unordered, so create and sort an array (ascending)\n\t\t\t\tconst enumArr = new Array(...enums);\n\n\t\t\t\tif (enumArr.every((x: unknown): x is number => typeof x === 'number')) {\n\t\t\t\t\tconst values = enumArr.sort((a, b) => a - b);\n\n\t\t\t\t\tconst [min, max] = [values[0], values[values.length-1]];\n\n\t\t\t\t\tconst setSize = (max - min) / splitting;\n\t\t\t\t\tfor (let i = 0; i < splitting; i++) {\n\t\t\t\t\t\tconst setMin = min + i * setSize;\n\t\t\t\t\t\tconst setMax = min + (i+1) * setSize;\n\n\t\t\t\t\t\tsetLimits.push([setMin, setMax]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError(`Cannot split values based on a number unless each of those values is a number.`);\n\t\t\t\t}\n\n\t\t\t\t// The first and last sets should be unbounded\n\t\t\t\tsetLimits[0][0] = -Infinity;\n\t\t\t\tsetLimits[setLimits.length - 1][1] = Infinity;\n\t\t\t} else if (Array.isArray(splitting)) {\n\t\t\t\tif (splitting.length === 0) {\n\t\t\t\t\tthrow new RangeError(`At least one number is required for the 'splitPoints' argument.`);\n\t\t\t\t} else if (splitting.every((val) => typeof val === 'number') === false) {\n\t\t\t\t\tthrow new TypeError(`All 'splitPoints' must be numbers.`);\n\t\t\t\t}\n\n\t\t\t\t// Ensure splitting values are ordered (ascending)\n\t\t\t\tconst splitValues = splitting.concat().sort((a, b) => a - b);\n\n\t\t\t\t// Outer bounds will be -Infinity and Infinity\n\t\t\t\tsetLimits.push([-Infinity, splitValues[0]]);\n\n\t\t\t\tfor (let i = 0; i < splitValues.length-1; i++) {\n\t\t\t\t\tsetLimits.push([splitValues[i], splitValues[i+1]]);\n\t\t\t\t}\n\n\t\t\t\tsetLimits.push([splitValues[splitValues.length-1], Infinity]);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError(`Invalid argument type: ${typeof splitting}`);\n\t\t\t}\n\n\t\t\t// Group rows based on set limits\n\t\t\tconst group = new AnalyserGroup({ discrete: false });\n\t\t\tfor (const set of setLimits) {\n\t\t\t\tlet setName = '';\n\t\t\t\tlet filterFn: ExtensibleFilterResolver;\n\n\t\t\t\tif (right) {\n\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\tsetName += `${set[0]} < `;\n\t\t\t\t\t}\n\t\t\t\t\tsetName += `x`;\n\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\tsetName += ` <= ${set[1]}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] < val && val <= set[1]);\n\t\t\t\t} else {\n\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\tsetName += `${set[0]} <= `;\n\t\t\t\t\t}\n\t\t\t\t\tsetName += `x`;\n\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\tsetName += ` < ${set[1]}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] <= val && val < set[1]);\n\t\t\t\t}\n\n\t\t\t\tconst matchingRows = rows.filter(filterFn);\n\n\t\t\t\tgroup.set(setName, matchingRows);\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\t};\n\n\treturn grouperFn;\n}\n\nexport {\n\tcreateGroupFn,\n\n\tGrouper,\n};\n","function getNumArray(val: number[] | [number[]]): number[] {\n\tif (\n\t\t((value: unknown[]): value is [number[]] => {\n\t\t\treturn value.length === 1 && Array.isArray(value[0]);\n\t\t})(val)\n\t) {\n\t\treturn val[0];\n\t} else {\n\t\treturn val;\n\t}\n}\n\n/**\n * Return the sum of an array of numbers.\n */\nexport function sum(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn numbers.reduce(function (sum: number, val: number) {\n\t\treturn sum + val;\n\t}, 0);\n}\n\n/**\n * Returns the mean of an array of numbers.\n */\nexport function mean(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn sum(numbers) / numbers.length;\n}\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { ChartOptions } from './ChartOptions.js';\n\n/**\n * Types that can be coerced to `number`\n */\ntype NumberLike = number | string | Date;\n\nexport type ChartData<GroupName extends string = string> = {\n\tlabels: NumberLike[],\n\tgroupNames: GroupName[],\n\tgroups: number[][],\n\n\tmin?: number,\n\tmax?: number,\n\n\tstacked?: boolean,\n};\n\nexport function getChartData<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: ChartOptions<GroupName>): ChartData<GroupName> {\n\tconst [[, ...groupNames]] = summary; // Ignore first 'Value' entry in first row\n\tlet [, ...valueRows] = summary; // Ignore first row of group names\n\n\t// If all the values are dates or numbers, sort valueRows based on label then re-extract\n\tif (valueRows.every((row): row is [Date | number, ...unknown[]] => row[0] instanceof Date || typeof row[0] === 'number')) {\n\t\tvalueRows = valueRows.sort((a, b) => +a[0] - +b[0]);\n\t}\n\n\t// `valueRows` can contain any sort of values, but only values that can be converted to numbers can be used to create a chart\n\tif (!valueRows.every((row): row is [NumberLike, ...unknown[]] => typeof row[0] === 'number' || typeof row[0] === 'string' || row[0] instanceof Date)) {\n\t\tthrow new TypeError(`Charts can only be created from data that can be converted to numbers.`);\n\t}\n\n\t// Extract the labels\n\tlet labels = valueRows.map((row) => row[0]);\n\n\t// If the x axis is qualitative, and its labels were limited in its options\n\tif (options?.x && 'labels' in options.x && options.x.labels) {\n\t\t// Remove any labels not specified in the axis options\n\t\tfor (let i = 0; i < labels.length; i++) {\n\t\t\tconst label = labels[i];\n\t\t\t// Use `as unknown[]` so TypeScript doesn't complain when using Array.prototype.includes\n\t\t\tif ((options.x.labels as unknown[]).includes(label) === false) {\n\t\t\t\tlabels.splice(i, 1);\n\t\t\t\tvalueRows.splice(i, 1);\n\t\t\t\ti -= i;\n\t\t\t}\n\t\t}\n\n\t\t// Go through specified labels, and if any weren't in the dataset then add empty data\n\t\tfor (let i = 0; i < options.x.labels.length; i++) {\n\t\t\tconst label = options.x.labels[i];\n\t\t\tif (labels.includes(label) === false) {\n\t\t\t\tconst emptyData: [NumberLike, ...0[]] = [label, ...(new Array<0>(valueRows[0].length-1)).fill(0)];\n\t\t\t\tlabels.splice(i, 0, label);\n\t\t\t\tvalueRows.splice(i, 0, emptyData);\n\t\t\t}\n\t\t}\n\n\t\t// Also update order of labels and value rows to match specified label order\n\t\tlabels = options.x.labels;\n\t\tvalueRows = valueRows.sort((rowA, rowB) => {\n\t\t\tconst labelA = rowA[0];\n\t\t\tconst indexA = labels.indexOf(labelA);\n\n\t\t\tconst labelB = rowB[0];\n\t\t\tconst indexB = labels.indexOf(labelB);\n\n\t\t\treturn indexA - indexB;\n\t\t});\n\t}\n\n\t// Transpose valueRows to get groups\n\tconst valueGroups: unknown[][] = [];\n\tfor (let i = 0; i < valueRows.length; i++) {\n\t\t// Start at j = 1 to ignore labels\n\t\tfor (let j = 1; j < valueRows[i].length; j++) {\n\t\t\tif (typeof valueGroups[j] === 'undefined') {\n\t\t\t\tvalueGroups[j] = [];\n\t\t\t}\n\t\t\tvalueGroups[j][i] = valueRows[i][j];\n\t\t}\n\t}\n\t// This method has given us an empty element at index 0, so remove it\n\tvalueGroups.splice(0, 1);\n\n\t// We can only graph groups if all their values are numbers\n\tconst numberValueGroups = valueGroups.filter(\n\t\t(group): group is number[] => group.every(\n\t\t\t(value): value is number => typeof value === 'number'\n\t\t)\n\t);\n\n\t// Filter out the same non-number groups from the groupNames list\n\tconst numberValueGroupNames = groupNames.filter(\n\t\t// Using a type assertion here is safe because we're just checking for inclusion\n\t\t(groupName, index) => (numberValueGroups as unknown[]).includes(valueGroups[index])\n\t);\n\n\tconst chartData: ChartData<GroupName> = {\n\t\tlabels,\n\t\tgroupNames: numberValueGroupNames,\n\t\tgroups: numberValueGroups,\n\t};\n\n\tif (options && 'stacked' in options) {\n\t\tchartData.stacked = options.stacked;\n\t}\n\n\treturn chartData;\n}\n","import { ChartData } from './ChartData.js';\nimport { ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\n\nexport interface ScaleOptions {\n\tmin: number,\n\tmax: number,\n}\n\nexport class Scale {\n\tmin: number;\n\tmax: number;\n\n\tget width(): number {\n\t\treturn this.max - this.min;\n\t}\n\n\tconstructor(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x') {\n\t\t[this.min, this.max] = getMinMax(options, chartOptions, type);\n\t}\n\n\t/**\n\t * Standardises the scale to go from 0 to 1,\n\t * then finds the value's position within it.\n\t */\n\tgetProportion(value: number): number {\n\t\tconst proportion = (value - this.min) / this.width;\n\n\t\treturn proportion;\n\t}\n\n\t/**\n\t * Given a proportion value on a scale from 0 to 1,\n\t * find the equivalent value on this scale.\n\t */\n\tgetValue(proportion: number): number {\n\t\tconst value = this.width * proportion + this.min;\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * For a given length of at least 2, create an array\n\t * of numbers from the bottom of the scale to the top,\n\t * with an equal step between each number in the range.\n\t */\n\tgetSeries(length: number): number[] {\n\t\tif (length < 2) {\n\t\t\tlength = 2;\n\t\t}\n\n\t\tconst stepSize = this.width / (length-1);\n\n\t\t// Start with minimum value\n\t\tconst series: number[] = [this.min];\n\n\t\t// Add intermediate steps\n\t\tfor (let i = 0; i < length-2; i++) {\n\t\t\tseries.push(series[series.length-1] + stepSize);\n\t\t}\n\n\t\t// End with max value\n\t\tseries.push(this.max);\n\n\t\treturn series;\n\t}\n}\n\n/**\n * Determines the appropriate method for reading or calculating min and max values,\n * based on the available data and options, then reads or calculates them.\n */\nfunction getMinMax(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x'): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\t// First, get minMax from options\n\tif ('groups' in options) {\n\t\t// options is of type ChartData, so determine min and max based on\n\t\t// the labels or the data, depending on the type of scale being created\n\t\tif (type === 'x') {\n\t\t\t[min, max] = getMinMaxFromChartDataLabels(options);\n\t\t} else {\n\t\t\t[min, max] = getMinMaxFromChartData(options);\n\t\t}\n\t} else {\n\t\t// options is a ScaleOptions, so read min and max directly\n\t\t[min, max] = getMinMaxFromScaleOptions(options);\n\t}\n\n\t// If min is larger than max, swap them around\n\tif (min > max) {\n\t\t[min, max] = [max, min];\n\t}\n\n\t// Then, see if min and/or max are overridden by chartOptions\n\tif (type && chartOptions) {\n\t\tconst axisOptions = chartOptions[type];\n\t\tif (axisOptions && ('min' in axisOptions || 'max' in axisOptions || 'values' in axisOptions)) {\n\t\t\tconst allowAuto = type !== 'x';\n\t\t\t[min, max] = getMinMaxFromAxisOptions(axisOptions, min, max, allowAuto);\n\t\t}\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the values contained in a set of ChartData.\n */\nfunction getMinMaxFromChartData(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { groups } = options;\n\n\tif (!groups.length || !groups[0].length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tlet allValues: number[];\n\tif ('stacked' in options && options.stacked) {\n\t\tallValues = groups[0].map((el, i) => groups.reduce((sum, group) => sum + group[i], 0));\n\t} else {\n\t\t// Use `as number[]` here so TypeScript doesn't complain when using Array.prototype.concat\n\t\tallValues = ([] as number[]).concat(...groups);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...allValues);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...allValues);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the labels for a set of ChartData.\n * Assumes all labels can be converted to numbers, and will throw an error if this assumption is false.\n */\nfunction getMinMaxFromChartDataLabels(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { labels } = options;\n\n\tif (!labels.length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tconst numberLabels = labels.map((label) => typeof label === 'number' ? label : +label);\n\tif (!numberLabels.every((label) => isNaN(label) === false)) {\n\t\tthrow new TypeError(`Cannot extract minimum or maximum values from labels that aren't all numbers.`);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...numberLabels);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...numberLabels);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Reads min and max values directly from a ScaleOptions object.\n */\nfunction getMinMaxFromScaleOptions(options: ScaleOptions): [number, number] {\n\tconst { min, max } = options;\n\n\treturn [min, max];\n}\n\n/**\n * Determines min and max values from an AxisOptions object, either reading them\n * directly from the options or calculating them from the highest order of magnitude\n * and, if specified, the number of values that needs to display on an axis.\n */\nfunction getMinMaxFromAxisOptions(axisOptions: AxisOptionsQuantitative, min: number, max: number, allowAuto = true): [number, number] {\n\tif (\n\t\t(Array.isArray(axisOptions.values) && axisOptions.values.length) ||\n\t\t(Array.isArray(axisOptions.gridlines) && axisOptions.gridlines.length)\n\t) {\n\t\t// If all the axis values or gridlines are specified,\n\t\t// the values they determine can extend min and/or max\n\t\t// past the values already determined.\n\n\t\t// Axis options can specify values as dates, but Scale always works with numbers\n\t\tlet allValues: number[] = [];\n\t\tif (Array.isArray(axisOptions.values)) {\n\t\t\tallValues = allValues.concat(axisOptions.values.map((val) => +val));\n\t\t}\n\t\tif (Array.isArray(axisOptions.gridlines)) {\n\t\t\tallValues = allValues.concat(axisOptions.gridlines.map((val) => +val));\n\t\t}\n\t\tmin = Math.min(min, ...allValues);\n\t\tmax = Math.max(max, ...allValues);\n\t}\n\n\tif (typeof axisOptions.min === 'number') {\n\t\tmin = axisOptions.min;\n\t} else if (allowAuto && (axisOptions.min === 'auto' || typeof axisOptions.min === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Round down min to nearest multiple of that power of 10\n\t\tconst widthRoundTo = Math.pow(10, maxPower);\n\t\tmin = Math.floor(min / widthRoundTo) * widthRoundTo;\n\n\t\t// If the power was negative, fix any floating point issues that may have arisen\n\t\tif (maxPower < 0) {\n\t\t\tmin = +(min.toFixed(-maxPower));\n\t\t}\n\t}\n\n\tif (typeof axisOptions.max === 'number') {\n\t\tmax = axisOptions.max;\n\t} else if (allowAuto && (axisOptions.max === 'auto' || typeof axisOptions.max === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Subtract min so we're working directly with the width\n\t\tmax -= min;\n\n\t\t// Round up max to nearest multiple of that power of 10\n\t\tlet widthRoundTo = Math.pow(10, maxPower);\n\t\tmax = Math.ceil(max / widthRoundTo) * widthRoundTo;\n\n\t\t// If the number of values to be displayed has been set\n\t\tif (typeof axisOptions.values === 'number') {\n\t\t\t// Only integers are accepted\n\t\t\tif (Number.isInteger(axisOptions.values) === false) {\n\t\t\t\tthrow new TypeError(`axisOptions.values must be an integer.`);\n\t\t\t}\n\n\t\t\t// Continue to increase max until it is a multiple of the next\n\t\t\t// greatest power of 10 below the largest one beneath max.\n\t\t\t// Also, ensure max is greater than min\n\t\t\tconst valuePower = maxPower - 1;\n\t\t\tlet valueRoundTo = Math.pow(10, valuePower) * axisOptions.values;\n\n\t\t\t// If that power is negative, JavaScript can run into issues\n\t\t\t// to do with numbers like 0.1 being unable to be represented in binary.\n\t\t\t// So multiply everything by that power and round it, then divide and fix at the end\n\t\t\tif (valuePower < 0) {\n\t\t\t\tvalueRoundTo = Math.round(valueRoundTo / Math.pow(10, valuePower));\n\t\t\t\twidthRoundTo = Math.round(widthRoundTo / Math.pow(10, valuePower));\n\t\t\t\tmax = Math.round(max / Math.pow(10, valuePower));\n\t\t\t}\n\n\t\t\tfor (let iterations = 0; iterations < 1000; iterations++) {\n\t\t\t\tconst remainder = max % valueRoundTo;\n\n\t\t\t\tif (remainder === 0 && max > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tmax += widthRoundTo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we muliplied everything earlier, undo that now then fix any floating point issues\n\t\t\tif (valuePower < 0) {\n\t\t\t\tmax = +(max * Math.pow(10, valuePower)).toFixed(-valuePower);\n\t\t\t}\n\t\t}\n\n\t\t// Add min back to convert width back to max\n\t\tmax += min;\n\t}\n\n\treturn [min, max];\n}\n","import { ChartData } from './ChartData.js';\nimport { BaseChartOptions, ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\nimport { Scale } from './Scale.js';\n\nexport function chart<GroupName extends string>(chartData: ChartData<GroupName>, contents: string, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<figure class=\"chart\">\n\t\t\t${options?.title ? title(options) : ''}\n\n\t\t\t<div class=\"chart__area\">\n\t\t\t\t${options?.legend ? legend(chartData, options) : ''}\n\n\t\t\t\t${yGridlines(chartData, options)}\n\n\t\t\t\t${xGridlines(chartData, options)}\n\n\t\t\t\t${contents}\n\t\t\t</div>\n\n\t\t\t${yAxis(chartData, options)}\n\n\t\t\t${xAxis(chartData, options)}\n\t\t</figure>\n\t`;\n}\n\nfunction title<GroupName extends string>(options: ChartOptions<GroupName>): string {\n\treturn options.title ? `<figcaption class=\"chart__title\">${options.title}</figcaption>` : '';\n}\n\nfunction legend<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<div class=\"chart__legend\">\n\t\t\t<span class=\"chart__legend__title\">Legend</span>\n\n\t\t\t<ul class=\"chart__legend__items\">\n\t\t\t\t${chartData.groupNames.map((groupName, index) => {\n\t\t\t\t\tconst colour: string | undefined = options?.colours && options.colours[groupName];\n\n\t\t\t\t\tconst str = `<li class=\"chart__legend__item\">\n\t\t\t\t\t\t<span class=\"chart__legend__item__swatch\"${colour ? ` style=\"background-color: ${colour};\"` : ''}></span>\n\t\t\t\t\t\t<span class=\"chart__legend__item__name\">${groupName}</span>\n\t\t\t\t\t</li>`;\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t</div>\n\t`;\n}\n\nfunction yAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.y;\n\n\tconst scale = new Scale(chartData, options, 'y');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\t// Render axis based on scale\n\treturn `\n\t<div class=\"chart__y-axis\">\n\t\t${axisOptions?.title ? `\n\t\t<span class=\"chart__y-axis__title\">${axisOptions.title}</span>\n\t\t` : ''}\n\n\t\t<ul class=\"chart__y-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__y-axis__value\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\tif (axisOptions) {\n\t\t// AxisOptions has no required values, so we can only be certain what axis type we're dealing with if labels or values is specified\n\t\tif ('labels' in axisOptions) {\n\t\t\treturn xAxisQualitative(chartData, options);\n\t\t} else if ('values' in axisOptions) {\n\t\t\treturn xAxisQuantitative(chartData, options);\n\t\t}\n\t}\n\n\treturn xAxisMinimal(chartData, options);\n}\n\nfunction xAxisQualitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst { labels } = chartData;\n\n\t// For each label, render that label\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__label-list\">\n\t\t\t${labels.map((label) => `<li class=\"chart__x-axis__label\">${applyFormat(label, axisOptions)}</li>`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisQuantitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst scale = new Scale(chartData, options, 'x');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__x-axis__value\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisMinimal<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t</div>`;\n}\n\nfunction yGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst scale = new Scale(chartData, options, 'y');\n\n\tconst { values } = getAxisGridlines(scale, options?.y);\n\n\t// Render gridlines based on scale\n\treturn `\n\t\t<ul class=\"chart__y-gridlines\" role=\"presentation\">\n\t\t\t${values.map((val, index) => {\n\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t// since that line is already drawn by the x axis\n\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t<li class=\"chart__y-gridline\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t'';\n\n\t\t\t\treturn gridlines;\n\t\t\t}).join('')}\n\t\t</ul>\n\t`;\n}\n\nfunction xGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\tif (axisOptions && ('values' in axisOptions || 'gridlines' in axisOptions)) {\n\t\tconst scale = new Scale(chartData, options, 'x');\n\t\tconst { values } = getAxisGridlines(scale, axisOptions);\n\n\t\t// Render gridlines based on scale\n\t\treturn `\n\t\t\t<ul class=\"chart__x-gridlines\" role=\"presentation\">\n\t\t\t\t${values.map((val, index) => {\n\t\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t\t// since that line is already drawn by the y axis\n\t\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t\t<li class=\"chart__x-gridline\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t\t'';\n\n\t\t\t\t\treturn gridlines;\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t`;\n\t} else {\n\t\treturn '';\n\t}\n}\n\nexport function tooltip<GroupName extends string>(chartData: ChartData<GroupName>, group: number[], label: unknown, options?: ChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst groupIndex = groups.indexOf(group);\n\tif (groupIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised group`);\n\t}\n\n\tconst groupName = groupNames[groupIndex];\n\n\t// Use `as unknown[]` so TypeScript doesn't complain when using Array.prototype.includes\n\tconst labelIndex = (labels as unknown[]).indexOf(label);\n\tif (labelIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised label`);\n\t}\n\n\tconst value = group[labelIndex];\n\n\tconst str = `\n\t<div class=\"chart__tooltip\">\n\t\t${groups.length > 1 ? groupName : ''} ${label}: ${applyFormat(value, options?.y)}\n\t</div>`;\n\n\treturn str;\n}\n\ninterface AxisValues {\n\tvalues: number[],\n\tdates: boolean,\n}\n\nfunction getAxisValues(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.values !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.values);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tvalues = scale.getSeries(2);\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\nfunction getAxisGridlines(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.gridlines !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.gridlines);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tconst axisValues = getAxisValues(scale, axisOptions);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\n/**\n * Both axis values and axis gridlines are retrieved in the same way, only with different fallbacks.\n * This base function contains that shared functionality, including the necessary conversion from\n * Date to number if the specified values are Dates, while remembering that they were Dates so they\n * can be converted back to Dates further down the line.\n */\nfunction getAxisValuesBase(scale: Scale, axisValues: Exclude<AxisOptionsQuantitative['values'], undefined>): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisValues === 'number') {\n\t\tconst numValues = axisValues + 1;\n\t\tvalues = scale.getSeries(numValues);\n\t} else if (axisValues.length > 0) {\n\t\t// These type assertions are necessary because of how `Array.prototype.every` has been typed\n\t\t// https://stackoverflow.com/questions/71012370/narrowing-a-union-of-array-types-using-array-every\n\t\tif ((axisValues as unknown[]).every((val: unknown): val is number => typeof val === 'number')) {\n\t\t\tvalues = axisValues as number[];\n\t\t} else {\n\t\t\tdates = true;\n\t\t\tvalues = axisValues.map((val) => +val);\n\t\t}\n\t} else {\n\t\tvalues = axisValues as [];\n\t}\n\n\treturn { values, dates };\n}\n\nfunction applyFormat(value: unknown, axisOptions?: AxisOptionsQuantitative): string {\n\tif (typeof value === 'number') {\n\t\tif (axisOptions?.numberFormat) {\n\t\t\tif (axisOptions.numberFormat instanceof Intl.NumberFormat) {\n\t\t\t\treturn axisOptions.numberFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.numberFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else if (value instanceof Date) {\n\t\tif (axisOptions?.dateFormat) {\n\t\t\tif (axisOptions.dateFormat instanceof Intl.DateTimeFormat) {\n\t\t\t\treturn axisOptions.dateFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.dateFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else {\n\t\treturn '' + value;\n\t}\n}\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { BarChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderBars<GroupName extends string>(chartData: ChartData<GroupName>, options?: BarChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scale = new Scale(chartData, options, 'y');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<ul class=\"chart__bar-groups\">\n\t\t\t${labels.map((label, index) =>\n\t\t\t`<li class=\"chart__bar-group\">\n\t\t\t\t<ul class=\"chart__bar-group-bars${options?.stacked ? ` chart__bar-group-bars--stacked` : ''}\">\n\t\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\t\tconst colour = colours && colours[groupName];\n\t\t\t\t\t\tconst value = group[index];\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li\n\t\t\t\t\t\t\t\tclass=\"chart__bar\"\n\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t` style=\"flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t}%;\"` :\n\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclass=\"chart__bar__area\"\n\t\t\t\t\t\t\t\tstyle=\"\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\tcolour ?\n\t\t\t\t\t\t\t\t\t\t\t`background: ${colour}; ` :\n\t\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t\t'' :\n\t\t\t\t\t\t\t\t\t\t\t`flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t\t}%;`\n\t\t\t\t\t\t\t\t\t}\" data-value=\"${value}\"\n\t\t\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>`;\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t</li>`).join('')}\n\t\t</ul>\n\t`;\n}\n\nexport function bar<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: BarChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst bars = renderBars(chartData, options);\n\n\tconst chart = renderChart(chartData, bars, options);\n\n\treturn chart;\n}\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { LineChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderLines<GroupName extends string>(chartData: ChartData<GroupName>, options?: LineChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scaleY = new Scale(chartData, options, 'y');\n\tconst scaleX = new Scale(chartData, options, 'x');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<svg class=\"chart__lines\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\">\n\t\t\t<g transform=\"translate(0, 100) scale(1, -1)\">\n\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\t\t\tconst points = labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\t\t\t\t\t\tconst str = `${leftPercent},${percentage}`;\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join(' ');\n\n\t\t\t\t\tconst str = `\n\t\t\t\t\t\t<polyline class=\"chart__line\" points=\"${points}\"${colour ? ` style=\"stroke: ${colour};\"` : ''}></polyline>\n\t\t\t\t\t`;\n\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</g>\n\t\t</svg>\n\n\t\t${groups.map((group, groupIndex) => {\n\t\t\tconst str = `\n\t\t\t\t<ul class=\"chart__line__points\">\n\t\t\t\t\t${labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li class=\"chart__line__point\" style=\"left: ${leftPercent}%; bottom: ${percentage}%\" tabindex=\"0\">\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t`;\n\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t`;\n\n\t\t\treturn str;\n\t\t}).join('')}\n\t`;\n}\n\nexport function line<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: LineChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst lines = renderLines(chartData, options);\n\n\tconst chart = renderChart(chartData, lines, options);\n\n\treturn chart;\n}\n","import * as codebook from '@cipscis/codebook';\n\nimport * as csv from '@cipscis/csv';\nimport * as analyser from '@cipscis/analyser';\n\nconst selectors = Object.freeze({\n\texample: '.js-docs__example',\n\tblock: '.js-docs__example .js-codebook__block[contenteditable]',\n\trun: '.js-docs__run',\n\tlog: '.js-docs__log',\n\n\tcodebookSet: '.js-codebook__set',\n} as const);\n\nconst dataAttributes = Object.freeze({\n\tcodebookSet: 'data-codebook-set',\n} as const);\n\nconst classes = Object.freeze({\n\terror: 'docs-example__control--error',\n} as const);\n\nlet $currentBlock: HTMLElement | null = null;\n\nfunction init() {\n\t_initEvents();\n\n\t_runInitialSets();\n}\n\nfunction _initEvents() {\n\tconst $runSetButtons = document.querySelectorAll<HTMLElement>(selectors.run);\n\t$runSetButtons.forEach(($runSetButton) => {\n\t\t$runSetButton.addEventListener('click', _runSetEvent);\n\t});\n\n\tconst $blocks = document.querySelectorAll<HTMLElement>(selectors.block);\n\t$blocks.forEach(($block) => {\n\t\t$block.addEventListener('blur', _clearCurrentBlock);\n\t\t$block.addEventListener('input', _markAsCurrentBlock);\n\t\t$block.addEventListener('keydown', _markAsCurrentBlockOnArrowDown);\n\t});\n\tdocument.addEventListener('keydown', _handleTabInsertion);\n}\n\nfunction _runInitialSets() {\n\tcodebook.tidy();\n\n\tcodebook.runSet('example-data', { csv });\n}\n\nfunction _runSetEvent(this: HTMLElement, e: MouseEvent) {\n\tconst $runSetButton = this;\n\tconst $set = $runSetButton.closest(selectors.codebookSet);\n\tconst setName = $set?.getAttribute(dataAttributes.codebookSet);\n\n\t$runSetButton.setAttribute('aria-busy', 'true');\n\n\tconst args = { csv, analyser };\n\tconst promise = setName ? codebook.runSet(setName, args) : codebook.runSet(args);\n\n\tpromise\n\t\t.then(() => {\n\t\t\t$runSetButton.classList.remove(classes.error);\n\t\t})\n\t\t.catch((reason) => {\n\t\t\t$runSetButton.classList.add(classes.error);\n\t\t\tconst $example = $runSetButton.closest(selectors.example);\n\t\t\tconst $log = $example?.querySelector(selectors.log);\n\n\t\t\tif ($log) {\n\t\t\t\tconsole.error(reason);\n\t\t\t\t$log.innerHTML = reason.toString();\n\t\t\t}\n\t\t})\n\t\t.finally(() => {\n\t\t\t$runSetButton.setAttribute('aria-busy', 'false');\n\t\t});\n}\n\nfunction _markAsCurrentBlock(this: HTMLElement, e: Event) {\n\t$currentBlock = this;\n}\n\nfunction _markAsCurrentBlockOnArrowDown(this: HTMLElement, e: KeyboardEvent) {\n\tif (\n\t\te.key === 'ArrowUp' ||\n\t\te.key === 'ArrowRight' ||\n\t\te.key === 'ArrowDown' ||\n\t\te.key === 'ArrowLeft'\n\t) {\n\t\t_markAsCurrentBlock.call(this, e);\n\t}\n}\n\nfunction _clearCurrentBlock(this: HTMLElement, e: FocusEvent) {\n\t$currentBlock = null;\n}\n\nfunction _handleTabInsertion(this: Document, e: KeyboardEvent) {\n\tif (e.key !== 'Tab') {\n\t\treturn;\n\t}\n\n\tif ($currentBlock === null) {\n\t\treturn;\n\t}\n\n\te.preventDefault();\n\n\tconst selection = this.getSelection();\n\tconst range = selection?.getRangeAt(0);\n\tif (range) {\n\t\trange.deleteContents();\n\t\trange.insertNode(document.createTextNode('\\t'));\n\t\trange.collapse(false);\n\t}\n}\n\ninit();\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","selectors","freeze","block","set","inert","dataAttributes","index","log","html","defaultSetName","$textarea","document","createElement","async","runSet","setNameOrArgs","argsParam","setName","args","sets","$blocks","querySelectorAll","setNames","$block","_getSetName","includes","push","_createNewSet","blocks","_gatherSetBlocks","_sortCodeBlocks","_createCodeSets","code","reduce","_combineCode","logId","getAttribute","$log","getElementById","innerHTML","_clearLogs","argNames","argValues","keys","values","_spreadArgs","Error","Function","apply","concat","_logOutput","_htmlOutput","fn","_runSet","RangeError","sort","$blockA","$blockB","iA","iB","assign","allCode","$newCode","newCode","htmlString","textContent","htmlId","$parent","closest","output","forEach","outputEl","outputString","Date","padZeroes","num","minLength","numStr","toString","length","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","JSON","stringify","$html","data","options","transpose","sanitise","rows","rowStrings","i","join","_join","row","j","_escapeCell","_escape","maxLength","Math","max","iMax","jMax","iRow","iCol","cellValue","_shape","cell","cellString","match","replace","parse","csvString","mapper","stringRows","tokens","inQuote","wasQuote","tokenStart","char","comma","quote","newline","eof","SyntaxError","token","substring","_tokenise","rowLength","_validate","map","fileConfig","AnalyserRows","Array","constructor","source","isArray","super","this","getCol","colNum","TypeError","col","addCol","creator","colIndex","entries","getColNumber","colName","Number","isInteger","alphabet","rowNumber","upperColName","toUpperCase","charIndex","indexOf","pow","getColNumbers","colsConfig","newCols","colNumber","defaultSummarisers","Count","AnalyserGroup","Map","discrete","summarise","summarisersArg","summarisers","summaryHeaderRow","summaryValueRows","groupName","summaryRow","summariser","rowSummary","summaryValuesSorted","a","b","createFilterFn","aliases","_extendFilterFn","arr","_applyFilter","filterResolver","extendedFilterResolver","andBy","orBy","valueMatch","valuesArr","cellValues","_matchAlias","aliasList","cleanNumberLike","appearsNumber","cleanValue","parseFloat","array","separator","limit","split","booleanCustom","truthy","falsey","locationIdentifier","cleanedValue","trim","toLowerCase","test","console","warn","number","appearsPercentage","numValue","precision","toFixed","appearsTrue","appearsFalse","appearsBoolean","enumValue","enums","recodeMap","enumValues","val","loadFile","response","fetch","path","ok","headerRows","splice","footerRows","cols","ignoreRows","rowsToIgnore","filter","by","group","splitting","right","Set","add","isNonCanonical","isCanonical","has","delete","matchingRows","setLimits","enumArr","every","x","min","setSize","setMin","setMax","Infinity","splitValues","filterFn","createGroupFn","dataConfig","addedCols","transform","transformFn","_processData","text","status","getNumArray","sum","mean","numbers","getChartData","summary","groupNames","valueRows","labels","label","emptyData","fill","rowA","rowB","labelA","indexA","labelB","valueGroups","numberValueGroups","numberValueGroupNames","chartData","groups","stacked","Scale","chartOptions","type","numberLabels","isNaN","getMinMaxFromChartDataLabels","allValues","el","getMinMaxFromChartData","getMinMaxFromScaleOptions","axisOptions","allowAuto","gridlines","maxPower","floor","log10","abs","widthRoundTo","ceil","valuePower","valueRoundTo","round","iterations","getMinMaxFromAxisOptions","getMinMax","getProportion","width","getValue","proportion","getSeries","stepSize","series","contents","title","legend","colour","colours","scale","getAxisGridlines","y","yGridlines","xGridlines","dates","getAxisValues","applyFormat","yAxis","xAxisQualitative","xAxisQuantitative","xAxisMinimal","xAxis","tooltip","groupIndex","labelIndex","axisValues","getAxisValuesBase","numValues","numberFormat","Intl","NumberFormat","format","dateFormat","DateTimeFormat","bar","renderBars","line","scaleY","scaleX","leftPercent","renderLines","example","run","codebookSet","classes","error","$currentBlock","_runSetEvent","e","$runSetButton","setAttribute","csv","analyser","then","classList","remove","catch","reason","querySelector","finally","_markAsCurrentBlock","_markAsCurrentBlockOnArrowDown","_clearCurrentBlock","addEventListener","preventDefault","range","getSelection","getRangeAt","deleteContents","insertNode","createTextNode","collapse","level","pattern","RegExp"],"sourceRoot":""}