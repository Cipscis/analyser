{"version":3,"file":"docs-script.bundle.js","mappings":"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","sources":["webpack://@cipscis/analyser/./node_modules/@cipscis/codebook/dist/codebook.js","webpack://@cipscis/analyser/./src/AnalyserRows.ts","webpack://@cipscis/analyser/./src/helpers.ts","webpack://@cipscis/analyser/./src/AnalyserGroup.ts","webpack://@cipscis/analyser/./src/filtering.ts","webpack://@cipscis/analyser/./src/transformers.ts","webpack://@cipscis/analyser/./src/file-processing.ts","webpack://@cipscis/analyser/./src/grouping.ts","webpack://@cipscis/analyser/./node_modules/@cipscis/csv/dist/parse.js","webpack://@cipscis/analyser/./src/charts/ChartData.ts","webpack://@cipscis/analyser/./src/charts/Scale.ts","webpack://@cipscis/analyser/./src/charts/chart.ts","webpack://@cipscis/analyser/./src/statistics.ts","webpack://@cipscis/analyser/./docs/assets/js/src/docs-script.ts","webpack://@cipscis/analyser/./src/charts/bar.ts","webpack://@cipscis/analyser/./src/charts/line.ts"],"sourcesContent":["const selectors = Object.freeze({\r\n    block: '.js-codebook__block',\r\n    set: '.js-codebook__set',\r\n    inert: '.js-codebook__inert',\r\n});\r\nconst dataAttributes = Object.freeze({\r\n    set: 'data-codebook-set',\r\n    index: 'data-codebook-index',\r\n    log: 'data-codebook-log',\r\n    html: 'data-codebook-html',\r\n});\r\nconst defaultSetName = 'default';\r\n// Create a single textarea element for decoding HTML\r\nconst $textarea = document.createElement('textarea');\r\n/**\r\n * Run all Codebook blocks in all Codebook sets in order, with any specified external arguments made available.\r\n */\r\nexport function run(args) {\r\n    return new Promise((resolve, reject) => {\r\n        const sets = _createCodeSets(args);\r\n        const promises = [];\r\n        for (let setName in sets) {\r\n            const set = sets[setName];\r\n            promises.push(_runSet(set));\r\n        }\r\n        Promise.all(promises)\r\n            .then(resolve)\r\n            .catch(reject);\r\n    });\r\n}\r\nexport async function runSet(setNameOrArgs, argsParam) {\r\n    let setName;\r\n    let args = undefined;\r\n    // Figure out which arguments were passed.\r\n    if (typeof setNameOrArgs === 'string') {\r\n        setName = setNameOrArgs;\r\n        if (argsParam) {\r\n            args = argsParam;\r\n        }\r\n    }\r\n    else {\r\n        // If no set name was specified, use the default set name.\r\n        setName = defaultSetName;\r\n        if (setNameOrArgs) {\r\n            args = setNameOrArgs;\r\n        }\r\n    }\r\n    const sets = _createCodeSets(args);\r\n    if (setName in sets) {\r\n        const set = sets[setName];\r\n        return _runSet(set);\r\n    }\r\n    else {\r\n        throw new RangeError(`Codebook: Cannot run unrecognised set '${setName}'`);\r\n    }\r\n}\r\n/**\r\n * Adjust the indentation of Codebook sets so it appears correctly when viewed on a page.\r\n */\r\nexport function tidy() {\r\n    const $blocks = document.querySelectorAll(`${selectors.block}, ${selectors.inert}`);\r\n    for (let $block of $blocks) {\r\n        const code = $block.innerHTML;\r\n        // Look for tab indentation only\r\n        const match = code.match(/^(\\t*)\\S/m);\r\n        if (match) {\r\n            const indentation = match[1];\r\n            const level = indentation.length;\r\n            const pattern = new RegExp(`^\\\\t{${level}}`, 'gm');\r\n            $block.innerHTML = code.replace(pattern, '').trim();\r\n        }\r\n    }\r\n    ;\r\n}\r\n/**\r\n * Gathers all Codebook sets, and sorts blocks within their sets according to their index where applicable.\r\n */\r\nfunction _createCodeSets(args) {\r\n    const sets = _gatherSetBlocks(args);\r\n    // Loop through created sets and sort their blocks by index\r\n    for (let setName in sets) {\r\n        const set = sets[setName];\r\n        _sortCodeBlocks(set);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Gathers all Codebook blocks according to the order in which they appear in the markup,\r\n * and adds them to the set they belong to.\r\n */\r\nfunction _gatherSetBlocks(args) {\r\n    const $blocks = document.querySelectorAll(selectors.block);\r\n    const setNames = [];\r\n    const sets = {};\r\n    // Loop through all elements and add them to the right set\r\n    for (let $block of $blocks) {\r\n        const setName = _getSetName($block);\r\n        let set;\r\n        if (setNames.includes(setName)) {\r\n            set = sets[setName];\r\n        }\r\n        else {\r\n            setNames.push(setName);\r\n            set = _createNewSet(args);\r\n            sets[setName] = set;\r\n        }\r\n        set.blocks.push($block);\r\n    }\r\n    ;\r\n    return sets;\r\n}\r\n/**\r\n * Sorts Codebook blocks according to their index data attribute, if they have one.\r\n */\r\nfunction _sortCodeBlocks(set) {\r\n    // If any blocks have an explicit index, sort them\r\n    set.blocks.sort(($blockA, $blockB) => {\r\n        const iA = $blockA.getAttribute(dataAttributes.index);\r\n        const iB = $blockB.getAttribute(dataAttributes.index);\r\n        if (iA === iB) {\r\n            return 0; // Leave the order unchanged\r\n        }\r\n        else if (iA !== null && iB === null) {\r\n            return -1; // Put $blockA first\r\n        }\r\n        else if (iA === null && iB !== null) {\r\n            return +1; // Put $blockB first\r\n        }\r\n        else {\r\n            // Neither index is null\r\n            return (+iA) - (+iB); // Put the code with the lower index first\r\n        }\r\n    });\r\n}\r\n/**\r\n * Creates a new Codebook set.\r\n */\r\nfunction _createNewSet(args) {\r\n    args = args || {};\r\n    return {\r\n        blocks: [],\r\n        args: Object.assign({}, args),\r\n    };\r\n}\r\n/**\r\n * Clears a set's logs, then runs each block within it with the `log` and `html` utility functions available.\r\n */\r\nfunction _runSet(set) {\r\n    const code = set.blocks.reduce(_combineCode, '');\r\n    _clearLogs(set);\r\n    const args = set.args;\r\n    const [argNames, argValues] = _spreadArgs(args);\r\n    console.log(argNames);\r\n    if (argNames.includes('_log') ||\r\n        argNames.includes('_$log') ||\r\n        argNames.includes('log') ||\r\n        argNames.includes('_html') ||\r\n        argNames.includes('_$html') ||\r\n        argNames.includes('html')) {\r\n        throw new Error(`Codebook: The following argument names are reserved and cannot be used:\\n'_log', '_$log', 'log', '_html', '_$html', 'html'`);\r\n    }\r\n    const fnFactory = Function.apply(null, argNames.concat(['_log', '_html', `\r\n\t\treturn async () => {\r\n\t\t\t'use strict';\r\n\r\n\t\t\tlet _$log = null;\r\n\t\t\tlet log = function () {};\r\n\r\n\t\t\tlet _$html = null;\r\n\t\t\tlet html = function () {};\r\n\r\n\t\t\t${code}\r\n\t\t};\r\n\t`]));\r\n    const fn = fnFactory.apply(null, argValues.concat([_logOutput, _htmlOutput]));\r\n    return fn();\r\n}\r\n/**\r\n * Clears the contents of all log elements for each block in a given Codebook set.\r\n */\r\nfunction _clearLogs(set) {\r\n    for (let $block of set.blocks) {\r\n        const logId = $block.getAttribute(dataAttributes.log);\r\n        if (logId) {\r\n            const $log = document.getElementById(`${logId}`);\r\n            if ($log) {\r\n                $log.innerHTML = '';\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Converts a CodebookSetArgs object into separate arrays of its arguments' names and values.\r\n */\r\nfunction _spreadArgs(args) {\r\n    const names = Object.keys(args);\r\n    const values = Object.values(args);\r\n    return [\r\n        names,\r\n        values,\r\n    ];\r\n}\r\n/**\r\n * To be used with `Array.prototype.reduce`, combines the code for all blocks within\r\n * a Codebook set and ensures the special `log` and `html` functions always have correct values.\r\n */\r\nfunction _combineCode(allCode, $newCode) {\r\n    let newCode = _decodeHtml($newCode.textContent || '');\r\n    const logId = $newCode.getAttribute(dataAttributes.log);\r\n    if (logId) {\r\n        newCode = `\r\n\t\t\t_$log = document.getElementById('${logId}');\r\n\t\t\tlog = function (...output) {\r\n\t\t\t\t_log(_$log, ...output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\tlog = function () {};\r\n\t\t`;\r\n    }\r\n    const htmlId = $newCode.getAttribute(dataAttributes.html);\r\n    if (htmlId) {\r\n        newCode = `\r\n\t\t\t_$html = document.getElementById('${htmlId}');\r\n\t\t\thtml = function (output) {\r\n\t\t\t\t_html(_$html, output);\r\n\t\t\t};\r\n\r\n\t\t\t${newCode}\r\n\r\n\t\t\thtml = function () {};\r\n\t\t`;\r\n    }\r\n    const combinedCode = `${allCode}\\n${newCode}`;\r\n    return combinedCode;\r\n}\r\n/**\r\n * Read the name of a Codebook block's set.\r\n */\r\nfunction _getSetName($block) {\r\n    let setName = $block.getAttribute(dataAttributes.set);\r\n    if (!setName) {\r\n        const $parent = $block.closest(selectors.set);\r\n        if ($parent) {\r\n            setName = $parent.getAttribute(dataAttributes.set);\r\n        }\r\n        if (!setName) {\r\n            setName = defaultSetName;\r\n        }\r\n    }\r\n    return setName;\r\n}\r\n/**\r\n * A helper function used to create the special `log` function, allowing values inside\r\n * Codebook blocks to be logged to that block's log element.\r\n */\r\nfunction _logOutput($log, ...output) {\r\n    if ($log) {\r\n        output.forEach((outputEl) => {\r\n            let outputString;\r\n            if (outputEl instanceof Date) {\r\n                function padZeroes(num, minLength = 2) {\r\n                    let numStr = num.toString();\r\n                    while (numStr.length < minLength) {\r\n                        numStr = `0${numStr}`;\r\n                    }\r\n                    return numStr;\r\n                }\r\n                const year = outputEl.getFullYear();\r\n                const month = padZeroes(outputEl.getMonth() + 1);\r\n                const day = padZeroes(outputEl.getDate());\r\n                outputString = `${year}-${month}-${day}`;\r\n                if (outputEl.getHours() || outputEl.getMinutes() || outputEl.getSeconds()) {\r\n                    const hours = padZeroes(outputEl.getHours());\r\n                    const minutes = padZeroes(outputEl.getMinutes());\r\n                    const seconds = padZeroes(outputEl.getSeconds());\r\n                    outputString += ` ${hours}:${minutes}:${seconds}`;\r\n                }\r\n            }\r\n            else if (typeof outputEl === 'object') {\r\n                outputString = JSON.stringify(outputEl, null, '\\t');\r\n            }\r\n            else if (typeof outputEl === 'string') {\r\n                outputString = outputEl;\r\n            }\r\n            else {\r\n                // Can't rely on everything having a `toString` method, so use type coercion.\r\n                outputString = '' + outputEl;\r\n            }\r\n            $log.innerHTML += `${outputString}\\n`;\r\n        });\r\n    }\r\n}\r\n/**\r\n * A helper function used to create the special `html` function, allowing values inside\r\n * Codebook blocks to be logged to that block's html element.\r\n */\r\nfunction _htmlOutput($html, output) {\r\n    if ($html) {\r\n        $html.innerHTML = output;\r\n    }\r\n}\r\n/**\r\n * Decode HTML entities in a string by applying it as the value\r\n * of an HTMLTextAreaElement then reading it back again.\r\n */\r\nfunction _decodeHtml(htmlString) {\r\n    // We don't want to see things like =&gt; in code when we really mean =>\r\n    $textarea.innerHTML = htmlString;\r\n    const decodedString = $textarea.value;\r\n    return decodedString;\r\n}\r\n//# sourceMappingURL=codebook.js.map","interface AnalyserRows {\n\tfilter(...args: Parameters<typeof Array.prototype.filter>): this;\n}\n\nclass AnalyserRows extends Array<unknown[]> {\n\tconstructor(source?: unknown[][] | number) {\n\t\tif (Array.isArray(source)) {\n\t\t\tsuper(source.length);\n\t\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\t\tthis[i] = source[i];\n\t\t\t}\n\t\t} else if (typeof source === 'number') {\n\t\t\tsuper(source);\n\t\t} else {\n\t\t\tsuper();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the specified column.\n\t */\n\tgetCol(colNum: number): unknown[] {\n\t\tif (typeof colNum !== 'number') {\n\t\t\tthrow new TypeError(`colNum must be a number.`);\n\t\t} else if (colNum < 0 || colNum >= this[0]?.length) {\n\t\t\tthrow new RangeError(`colNum out of range.`);\n\t\t}\n\n\t\tconst col: unknown[] = [];\n\t\tfor (let row of this) {\n\t\t\tcol.push(row[colNum]);\n\t\t}\n\n\t\treturn col;\n\t}\n\n\t/**\n\t * Adds a new column to AnalyserRows, and returns its index.\n\t */\n\taddCol<T>(creator: (row: any[], index: number) => T): number\n\taddCol<T>(creator: T[]): number\n\taddCol<T>(creator: ((row: any[], index: number) => T) | T[]): number {\n\t\tconst colIndex = this[0].length;\n\n\t\tif (Array.isArray(creator)) {\n\t\t\tif (this.length !== creator.length) {\n\t\t\t\tthrow new Error(`New column of length ${creator.length} cannot be added. It must be of length ${this.length}.`);\n\t\t\t}\n\n\t\t\tfor (let [i, row] of this.entries()) {\n\t\t\t\trow.push(creator[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let [i, row] of this.entries()) {\n\t\t\t\trow.push(creator(row, i));\n\t\t\t}\n\t\t}\n\n\t\treturn colIndex;\n\t}\n}\n\nexport { AnalyserRows };\n","/**\n * Convert a column heading from spreadsheet software to its integer representation. For example, converts 'A' to 0, or 'ZE' to 680.\n *\n * If a non-negative integer is passed, it will be returned untransformed. Any other value, including an invalid string, will return null.\n */\nfunction getColNumber<T extends number>(colName: T): T | null\nfunction getColNumber<T extends string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null\nfunction getColNumber<T extends number | string>(colName: T): number | null {\n\tif (typeof colName === 'number') {\n\t\tif (Number.isInteger(colName) && colName >= 0) {\n\t\t\treturn colName;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t} else if (colName === '') {\n\t\treturn null;\n\t} else if (typeof colName !== 'string') {\n\t\treturn null;\n\t}\n\n\tconst alphabet: readonly string[] = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\tlet rowNumber = -1; // Adjust for 0-based counting\n\n\tconst upperColName = colName.toUpperCase();\n\tfor (let i = 0; i < upperColName.length; i++) {\n\t\tconst char = upperColName[i];\n\t\tconst charIndex = alphabet.indexOf(char);\n\n\t\tif (charIndex === -1) {\n\t\t\t// colName contains an invalid character\n\t\t\treturn null;\n\t\t}\n\n\t\trowNumber += (charIndex + 1) * Math.pow(alphabet.length, colName.length - (i+1));\n\t}\n\n\treturn rowNumber;\n}\n\n/**\n * Converts a map of column names to column identifiers using getColNumbers so all column identifiers are integers.\n *\n * Any columns with invalid identifiers will be removed from the result.\n */\nfunction getColNumbers<T extends string>(colsConfig: Record<T, number | string>): Record<T, number> {\n\tconst newCols: Partial<Record<T, number>> = {};\n\n\tfor (let key in colsConfig) {\n\t\tconst value = colsConfig[key];\n\t\tconst colNumber = getColNumber(value);\n\n\t\tif (typeof colNumber === 'number') {\n\t\t\tnewCols[key] = colNumber;\n\t\t}\n\t}\n\n\treturn newCols as Record<T, number>;\n}\n\nexport {\n\tgetColNumber,\n\tgetColNumbers,\n};\n","import { AnalyserRows } from './AnalyserRows.js';\n\n/**\n * A function for summarising a set of AnalyserRows\n */\ntype AnalyserSummariser<T = any, G = any> = (rows: AnalyserRows, groupName: G) => T;\n\n/**\n * A group of AnalyserSummariser functions\n */\ntype AnalyserSummarisers<SummaryName extends string> = Record<SummaryName, AnalyserSummariser>;\n\nconst defaultSummarisers = {\n\tCount: (rows: AnalyserRows) => rows.length\n} as const;\ntype DefaultSummaryName = keyof typeof defaultSummarisers;\n\n/**\n * A 2D array of the results of AnalyserSummariser functions applied to an AnalyserGroup of AnalyserRows,\n * able to be printed to the console using `console.table`.\n *\n * After the first header row, each row represents a set of AnalyserRows grouped by the value given in the first cell.\n * After the first column, each column represents a summary of a group of AnalyserRows. The name of the summary is given in the first cell.\n */\nexport type AnalyserSummary<SummaryName extends string> = [[unknown, ...SummaryName[]], ...[any, ...any[]][]];\n\ninterface AnalyserGroupOptions {\n\tdiscrete?: boolean,\n}\n\nexport class AnalyserGroup extends Map<any, AnalyserRows> {\n\t#discrete: boolean\n\n\tconstructor(options?: AnalyserGroupOptions) {\n\t\tsuper();\n\n\t\tif (typeof options?.discrete === 'boolean') {\n\t\t\tthis.#discrete = options.discrete;\n\t\t} else {\n\t\t\tthis.#discrete = true;\n\t\t}\n\t}\n\n\t/**\n\t * Create a 2D summary array that can be printed using console.table.\n\t */\n\tsummarise(): AnalyserSummary<DefaultSummaryName>\n\tsummarise<SummaryName extends string>(summarisers: AnalyserSummarisers<SummaryName>): AnalyserSummary<SummaryName>\n\tsummarise<SummaryName extends string>(summarisersArg?: AnalyserSummarisers<SummaryName>): AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName> {\n\t\t// If there was no argument, use a default value instead. This will affect the return type, as per the overloads\n\t\tconst summarisers = summarisersArg ?? defaultSummarisers;\n\n\t\tconst summaryNames = Object.keys(summarisers) as (DefaultSummaryName)[] | SummaryName[];\n\t\tconst summaryHeaderRow = ['Value', ...summaryNames] as const;\n\n\t\tlet summaryValueRows: [any, ...any[]][] = [];\n\t\tfor (let [groupName, rows] of this.entries()) {\n\t\t\tconst summaryRow: [any, ...any[]] = [groupName];\n\n\t\t\tfor (let [, summariser] of Object.entries<AnalyserSummariser>(summarisers)) {\n\t\t\t\tconst rowSummary = summariser(rows, groupName);\n\t\t\t\tsummaryRow.push(rowSummary);\n\t\t\t}\n\n\t\t\tsummaryValueRows.push(summaryRow);\n\t\t}\n\n\t\tif (this.#discrete) {\n\t\t\t// Sort summary based on its values\n\n\t\t\t// Use basic Array.prototype.sort to sort numbers or strings, to use as a reference when sorting the summary\n\t\t\tconst summaryValues = summaryValueRows.map((summaryRow) => summaryRow[0]);\n\t\t\tconst summaryValuesSorted = summaryValues.sort();\n\n\t\t\t// Sort summary value rows using the sorted values as a reference\n\t\t\tsummaryValueRows = summaryValueRows.sort((a, b) => summaryValuesSorted.indexOf(a[0]) - summaryValuesSorted.indexOf(b[0]));\n\t\t}\n\n\t\tconst summary = [summaryHeaderRow, ...summaryValueRows];\n\n\t\t// Let the overloads tell TypeScript which type the summary actually is.\n\t\t// If there was no `summarisersArg` argument, it will be AnalyserSummary<DefaultSummaryNames>,\n\t\t// otherwise the type T could be inferred so no default was necessary and it will be AnalyserSummary<SummaryName>\n\t\treturn summary as AnalyserSummary<DefaultSummaryName> | AnalyserSummary<SummaryName>;\n\t}\n}\n","import { AnalyserRows } from './AnalyserRows.js';\n\ntype FilterInput = ((value: any) => boolean) | any[] | Exclude<any, []>\n\n/**\n * A function used by Array.prototype.filter\n */\ninterface FilterResolver {\n\t(val: any, index: number, arr: any[]): boolean,\n}\n\n/**\n * A FilterResolver that can be extended using FilterResolverExtender methods\n */\ninterface ExtensibleFilterResolver extends FilterResolver {\n\tandBy: FilterResolverExtender,\n\torBy: FilterResolverExtender,\n}\n\n/**\n * A function that either creates a new FilterResolver or extends and existing one, embedding information about the column to look at and the values to match.\n */\ninterface FilterResolverExtender {\n\t(colIndex: number, values: FilterInput): ExtensibleFilterResolver,\n}\n\n/**\n * Creates a function that remembers a set of aliases, and can be called\n * to create a function that can be used with Array.prototype.filter to\n * use that alias when filtering a set of data using _applyFilter.\n */\nfunction createFilterFn(aliases?: string[][]): FilterResolverExtender {\n\tconst by = function (colIndex: number, values: FilterInput) {\n\t\tconst applyFilterToRow: FilterResolver = function (row, index, arr) {\n\t\t\treturn _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst extendedApplyFilterToRow = _extendFilterFn(applyFilterToRow, aliases);\n\n\t\treturn extendedApplyFilterToRow;\n\t};\n\n\treturn by;\n}\n\n/**\n * Extend a FilterResolver into an ExtensibleFilterResolver, including embedding an optional set of aliases.\n */\nfunction _extendFilterFn(filterResolver: FilterResolver, aliases?: string[][]): ExtensibleFilterResolver {\n\tconst extendedFilterResolver = filterResolver as ExtensibleFilterResolver;\n\n\textendedFilterResolver.andBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) && _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\textendedFilterResolver.orBy = function (colIndex: number, values: FilterInput) {\n\t\tconst newFilterResolver: FilterResolver = function (row, index, arr) {\n\t\t\treturn filterResolver(row, index, arr) || _applyFilter(row, colIndex, values, aliases);\n\t\t};\n\n\t\tconst newExtendedFilterResolver = _extendFilterFn(newFilterResolver, aliases);\n\t\treturn newExtendedFilterResolver;\n\t};\n\n\treturn extendedFilterResolver;\n}\n\n/**\n * Applies a filter to a specific row, looking at a specified column index\n * and checking its value against either a specific value, a set of values,\n * or a function.\n *\n * If the value or values being checked against are strings, a set of\n * aliases can be used as well.\n */\nfunction _applyFilter(row: any[], colIndex: number, values: FilterInput, aliases?: string[][]): boolean {\n\tif (typeof values === 'function') {\n\t\treturn values(row[colIndex]);\n\t}\n\n\tif (!Array.isArray(values)) {\n\t\tvalues = [values];\n\t}\n\n\tconst cell = row[colIndex];\n\tlet cellValues;\n\n\tif (Array.isArray(cell)) {\n\t\tcellValues = cell;\n\t} else {\n\t\tcellValues = [cell];\n\t}\n\n\tfor (let cellValue of cellValues) {\n\t\tfor (let value of values) {\n\t\t\tif (_matchAlias(value, cellValue, aliases)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * Checks if the value of a cell matches the value passed,\n * optionally taking one or more sets of aliases to match.\n */\nfunction _matchAlias(cell: any, value: any, aliases?: string[][]): boolean {\n\tif (cell === value) {\n\t\treturn true;\n\t}\n\n\tif (aliases && typeof cell === 'string' && typeof value === 'string') {\n\t\tfor (let aliasList of aliases) {\n\t\t\tif (aliasList.includes(cell) && aliasList.includes(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport {\n\tcreateFilterFn,\n\n\tFilterResolverExtender,\n\tExtensibleFilterResolver,\n};\n","//////////////////////////\n// Appearance functions //\n//////////////////////////\n\nexport interface TransformerFn<T> {\n\t(value: string, locationIdentifier?: string): T extends any[] ? T : (T | null)\n}\n\n/**\n * Checks if a string appears like it represents true\n */\nfunction appearsTrue(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'true';\n}\n\n/**\n * Checks if a string appears like it represents false\n */\nfunction appearsFalse(value: string): boolean {\n\treturn value.trim().toLowerCase() === 'false';\n}\n\n/**\n * Checks if a string appears like it represents a boolean vaue\n */\nfunction appearsBoolean(value: string): boolean {\n\treturn appearsTrue(value) || appearsFalse(value);\n}\n\ntype NoCommas<T extends string> = T extends `${infer U},${infer V}` ? NoCommas<`${U}${V}`> : T;\ntype NoPercent<T extends string> = T extends `${infer W}%` ? W : T;\ntype CleanNumberLike<T extends string> = NoCommas<NoPercent<T>>;\n\n/**\n * Removes any ',' characters, and any '%' at the end of\n * a string that may appear like it represents a number\n */\nfunction cleanNumberLike<T extends string>(value: T): CleanNumberLike<T> {\n\tconst cleanValue = value.replace(/,|%$/g, '') as CleanNumberLike<T>;\n\treturn cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a number\n */\nfunction appearsNumber(value: string): boolean {\n\tconst cleanValue = cleanNumberLike(value);\n\n\treturn parseFloat(cleanValue) === +cleanValue;\n}\n\n/**\n * Checks if a string appears like it represents a percentage\n */\nfunction appearsPercentage(value: string): boolean {\n\treturn appearsNumber(value) && !!value.match(/%$/);\n}\n\n///////////////////////////\n// Transformer functions //\n///////////////////////////\n\n/**\n * Splits a string into an array using String.prototype.split\n */\nexport function array(separator: string | RegExp, limit?: number): TransformerFn<string[]> {\n\treturn function (value: string): string[] {\n\t\treturn value.split(separator, limit);\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation using a custom definition.\n *\n *  If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport function booleanCustom(truthy: string | RegExp = 'true', falsey: string | RegExp = 'false'): TransformerFn<boolean> {\n\treturn function (value: string, locationIdentifier?: string): boolean | null {\n\t\tconst cleanedValue = value.trim().toLowerCase();\n\n\t\tif (typeof truthy === 'string') {\n\t\t\tif (cleanedValue === truthy.trim().toLowerCase()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (truthy.test(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof falsey === 'string') {\n\t\t\tif (cleanedValue === falsey.trim().toLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (falsey.test(value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (value) {\n\t\t\tconsole.warn(`Boolean value not found in '${value}', checking for ${truthy} or ${falsey} (${locationIdentifier})`);\n\t\t}\n\t\treturn null;\n\t};\n}\n\n/**\n * Extracts a boolean value from a string representation, if it contains one.\n *\n * If the value doesn't appear like it represents a boolean, a warning will be generated.\n */\nexport const boolean = booleanCustom();\n\n/**\n * Extracts a number from a string representation, if it contains one.\n * Strings ending with '%' are treated as percentages and divided by 100.\n *\n * If the value doesn't appear like it represents a number, a warning will be generated.\n */\nexport const number: TransformerFn<number> = (value: string, locationIdentifier?: string): number | null => {\n\tif (appearsNumber(value)) {\n\t\t// Condition matches if the entire string represents a number\n\n\t\tlet cleanValue: string = cleanNumberLike(value);\n\n\t\tif (appearsPercentage(value)) {\n\t\t\t// If value is a percentage string, divide by 100\n\t\t\tconst numValue = +cleanValue / 100;\n\n\t\t\t// To prevent division causing rounding errors, like\n\t\t\t// 0.10800000000000001, use string representation to\n\t\t\t// determine how to round the number.\n\n\t\t\t// Remove everything up to (and including) a radix point\n\t\t\t// e.g. convert '82.643' to '643'\n\t\t\tconst truncatedValue = cleanValue.replace(/^[^.]+\\.?/, '');\n\n\t\t\tconst precision = truncatedValue.length;\n\n\t\t\t// Add 2 to precision to compensate for dividing by 100\n\t\t\tcleanValue = numValue.toFixed(precision + 2);\n\t\t}\n\n\t\treturn +cleanValue;\n\t} else {\n\t\tif (value) {\n\t\t\tconsole.warn(`Number value not found in '${value}' (${locationIdentifier})`);\n\t\t}\n\t\treturn null;\n\t}\n}\n\n/**\n * Extracts boolean or number values from string representations if appropriate.\n *\n * No warnings will be generated if the value doesn't appear like a boolean or number.\n */\nexport const value: TransformerFn<boolean | number> = (value: string, locationIdentifier?: string): boolean | number | null => {\n\tif (appearsBoolean(value)) {\n\t\treturn boolean(value);\n\t} else if (appearsNumber(value)) {\n\t\treturn number(value);\n\t} else {\n\t\tconsole.warn(`Boolean or number value not found in '${value}' (${locationIdentifier})`);\n\t\treturn null;\n\t}\n}\n\n/**\n * Checks that the value, if it exists, is a member of an enum.\n *\n * If the value does not exist, it is transformed to null.\n *\n * If a recoding map is passed, and it contains instructions for this value, it is recoded first.\n *\n * If the value exists but it is not a member of the enum and cannot be recoded,\n * a warning will be generated and null will be returned.\n */\nexport function enumValue<E extends string>(enums: Record<string, E>, recodeMap?: Record<string, E>): TransformerFn<E> {\n\tconst enumValues: E[] = Object.values(enums);\n\n\tfunction isEnumMember(val: unknown): val is E {\n\t\t// Use `as any[]` so TypeScript doesn't complain when using Array.prototype.includes\n\t\treturn (enumValues as any[]).includes(val);\n\t}\n\n\tconst transformer = ((value: string, locationIdentifier?: string) => {\n\t\tif (!value) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (isEnumMember(value)) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif (recodeMap && value in recodeMap) {\n\t\t\tconst recodedValue = recodeMap[value];\n\t\t\treturn recodedValue;\n\t\t}\n\n\t\tconsole.warn(`Value '${value}' does not exist within ${enumValues.join(', ')} (${locationIdentifier})`);\n\t\treturn null;\n\t}) as TransformerFn<E>;\n\t// Need to use a type assertion here as TypeScript doesn't know how to use the generic constraint to resolve the conditional type\n\t// See https://stackoverflow.com/questions/70553130/typescript-generic-conditional-type-as-return-value-for-generic-function/70553240#70553240\n\n\treturn transformer;\n}\n","import { parse as parseCSV } from '@cipscis/csv';\n\nimport { AnalyserRows } from './AnalyserRows.js';\nimport { FileConfig } from './FileConfig.js';\nimport { DataConfig } from './DataConfig.js';\n\nimport { getColNumbers } from './helpers.js';\n\nimport { createGroupFn } from './grouping.js';\nimport { createFilterFn } from './filtering.js';\n\nimport * as transformers from './transformers.js';\n\n/**\n * Load a single CSV file and process its contents, then return them.\n */\nasync function loadFile<T extends string>(fileConfig: FileConfig<T>): Promise<DataConfig<T>> {\n\tconst response = await fetch(fileConfig.path);\n\n\tif (response.ok) {\n\t\tconst data = await response.text();\n\n\t\tconst rows = parseCSV(data);\n\t\tconst dataConfig = _processData(rows, fileConfig);\n\t\treturn dataConfig;\n\t} else {\n\t\tthrow new Error(`Failed to fetch file at ${fileConfig.path}: ${response.status}`);\n\t}\n}\n\n/**\n * Processes CSV data into a DataConfig object ready for analysis via code.\n */\nfunction _processData<T extends string>(rows: string[][], fileConfig: FileConfig<T>): DataConfig<T> {\n\t// Remove header rows\n\tif (fileConfig.headerRows) {\n\t\trows.splice(0, fileConfig.headerRows);\n\t}\n\n\t// Remove footer rows\n\tif (fileConfig.footerRows) {\n\t\trows.splice(-fileConfig.footerRows);\n\t}\n\n\tconst by = createFilterFn(fileConfig.aliases);\n\tconst group = createGroupFn(by, fileConfig.aliases);\n\n\tconst dataConfig: DataConfig<T> = {\n\t\trows: new AnalyserRows(rows),\n\t\traw: rows,\n\t\tcols: getColNumbers(fileConfig.cols),\n\t\taddedCols: {},\n\t\tby,\n\t\tgroup,\n\t};\n\n\tif (fileConfig.aliases) {\n\t\tdataConfig.aliases = fileConfig.aliases;\n\t}\n\n\tif (fileConfig.transform) {\n\t\tfor (let colName in fileConfig.transform) {\n\t\t\tif (!(colName in dataConfig.cols)) {\n\t\t\t\tconsole.warn(`Column '${colName}' specified in transform not found in cols.`);\n\t\t\t} else {\n\t\t\t\tconst colNum = dataConfig.cols[colName];\n\t\t\t\tconst transformFn = fileConfig.transform[colName];\n\n\t\t\t\t// Some of these conditions are ignored because they're intended to help when TypeScript isn't being used\n\t\t\t\tif (transformFn === transformers.array) {\n\t\t\t\t\tthrow new Error(`The 'array' transformer cannot be used directly. Please pass a 'separator' argument.`);\n\t\t\t\t} else if (transformFn === transformers.booleanCustom) {\n\t\t\t\t\tthrow new Error(`The 'booleanCustom' transformer cannot be used directly. Please invoke it to create a transformer function.`);\n\t\t\t\t// @ts-ignore\n\t\t\t\t} else if (transformFn === transformers.enumValue) {\n\t\t\t\t\tthrow new Error(`The 'enumValue' transformer cannot be used directly. Please pass an 'enums' argument.`);\n\t\t\t\t}\n\n\t\t\t\tfor (let row of rows) {\n\t\t\t\t\tif (transformFn) {\n\t\t\t\t\t\tconst locationIdentifier = `column ${colName}, row ${rows.indexOf(row)}`;\n\t\t\t\t\t\trow[colNum] = transformFn(row[colNum], locationIdentifier);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dataConfig;\n}\n\nexport { loadFile };\n","import { AnalyserRows } from './AnalyserRows.js';\nimport { FilterResolverExtender, ExtensibleFilterResolver } from './filtering.js';\n\nimport { AnalyserGroup } from './AnalyserGroup.js';\n\ninterface Grouper {\n\t(rows: AnalyserRows, colNum: number): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, numGroups: number, right?: boolean): AnalyserGroup\n\t(rows: AnalyserRows, colNum: number, splitPoints: number[], right?: boolean): AnalyserGroup\n}\n\n/**\n * Creates a function that uses a FilterResolverExtender with an embedded\n * set of aliases, to create a summarisable group of AnalyserRows split\n * based on the specified column.\n */\nfunction createGroupFn (by: FilterResolverExtender, aliases?: string[][]): Grouper {\n\tconst grouperFn: Grouper = function (rows: AnalyserRows, colNum: number, splitting?: number | number[], right: boolean = true): AnalyserGroup {\n\t\t// Ignore aliases for now, and don't worry about splitting\n\n\t\t// First, collect enums\n\t\tconst enums: Set<unknown> = new Set();\n\t\tfor (let row of rows) {\n\t\t\tconst cellValue = row[colNum];\n\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\tfor (let value of cellValue) {\n\t\t\t\t\tenums.add(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenums.add(cellValue);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof splitting === 'undefined') {\n\t\t\t// Treat data as discrete\n\n\t\t\tif (aliases) {\n\t\t\t\tfor (let val of enums) {\n\t\t\t\t\tif (typeof val === 'string') {\n\t\t\t\t\t\t// If the value is a string in one or more alias sets,\n\t\t\t\t\t\t// ensure those sets will be used for grouping and\n\t\t\t\t\t\t// ensure only canonical values will be checked directly.\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and is **not** the canonical value */\n\t\t\t\t\t\tlet isNonCanonical = false;\n\n\t\t\t\t\t\t/** If the value appears in at least one alias list and **is** the canonical value */\n\t\t\t\t\t\tlet isCanonical = false;\n\n\t\t\t\t\t\tfor (let aliasList of aliases) {\n\t\t\t\t\t\t\tif (aliasList.includes(val)) {\n\t\t\t\t\t\t\t\tif (aliasList[0] === val) {\n\t\t\t\t\t\t\t\t\tisCanonical = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tisNonCanonical = true;\n\n\t\t\t\t\t\t\t\t\t// Remember the canonical value\n\t\t\t\t\t\t\t\t\tif (enums.has(aliasList[0]) === false) {\n\t\t\t\t\t\t\t\t\t\tenums.add(aliasList[0]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the value is one one or more alias sets, but is never the canonical value,\n\t\t\t\t\t\t// then remove it from the set of enums to use for grouping.\n\t\t\t\t\t\tif (isCanonical === false && isNonCanonical === true) {\n\t\t\t\t\t\t\tenums.delete(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Then, interate through each enum and filter rows into groups\n\t\t\tconst group = new AnalyserGroup();\n\t\t\tfor (let val of enums) {\n\t\t\t\tconst matchingRows = rows.filter(by(colNum, val));\n\t\t\t\tgroup.set(val, matchingRows);\n\t\t\t}\n\t\t\treturn group;\n\t\t} else {\n\t\t\t// Treat data as continuous\n\n\t\t\t// Create the limits for each set\n\t\t\tconst setLimits: [number, number][] = [];\n\t\t\tif (typeof splitting === 'number') {\n\t\t\t\t// Create splitting number of groups based on values retrieved\n\n\t\t\t\tif (Number.isInteger(splitting) === false || splitting < 2) {\n\t\t\t\t\tthrow new RangeError(`The 'numGroups' argument must be an integer greater than 1.`);\n\t\t\t\t}\n\n\t\t\t\t// Sets are unordered, so create and sort an array (ascending)\n\t\t\t\tconst enumArr = new Array(...enums);\n\n\t\t\t\tif (enumArr.every((x: any): x is number => typeof x === 'number')) {\n\t\t\t\t\tconst values = enumArr.sort((a, b) => a - b);\n\n\t\t\t\t\tconst [min, max] = [values[0], values[values.length-1]];\n\n\t\t\t\t\tconst setSize = (max - min) / splitting;\n\t\t\t\t\tfor (let i = 0; i < splitting; i++) {\n\t\t\t\t\t\tconst setMin = min + i * setSize;\n\t\t\t\t\t\tconst setMax = min + (i+1) * setSize;\n\n\t\t\t\t\t\tsetLimits.push([setMin, setMax]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError(`Cannot split values based on a number unless each of those values is a number.`);\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(splitting)) {\n\t\t\t\tif (splitting.length === 0) {\n\t\t\t\t\tthrow new RangeError(`At least one number is required for the 'splitPoints' argument.`);\n\t\t\t\t} else if (splitting.every((val) => typeof val === 'number') === false) {\n\t\t\t\t\tthrow new TypeError(`All 'splitPoints' must be numbers.`);\n\t\t\t\t}\n\n\t\t\t\t// Ensure splitting values are ordered (ascending)\n\t\t\t\tconst splitValues = splitting.concat().sort((a, b) => a - b);\n\n\t\t\t\t// Outer bounds will be -Infinity and Infinity\n\t\t\t\tsetLimits.push([-Infinity, splitValues[0]]);\n\n\t\t\t\tfor (let i = 0; i < splitValues.length-1; i++) {\n\t\t\t\t\tsetLimits.push([splitValues[i], splitValues[i+1]]);\n\t\t\t\t}\n\n\t\t\t\tsetLimits.push([splitValues[splitValues.length-1], Infinity]);\n\t\t\t} else {\n\t\t\t\tthrow new TypeError(`Invalid argument type: ${typeof splitting}`);\n\t\t\t}\n\n\t\t\t// Group rows based on set limits\n\t\t\tconst group = new AnalyserGroup({ discrete: false });\n\t\t\tfor (let row of rows) {\n\t\t\t\tfor (let set of setLimits) {\n\t\t\t\t\tlet setName = '';\n\t\t\t\t\tlet filterFn: ExtensibleFilterResolver;\n\n\t\t\t\t\tif (right) {\n\t\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\t\tsetName += `${set[0]} < `;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetName += `x`;\n\t\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\t\tsetName += ` <= ${set[1]}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] < val && val <= set[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (set[0] !== -Infinity) {\n\t\t\t\t\t\t\tsetName += `${set[0]} <= `;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetName += `x`;\n\t\t\t\t\t\tif (set[1] !== Infinity) {\n\t\t\t\t\t\t\tsetName += ` < ${set[1]}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfilterFn = by(colNum, (val: number) => set[0] <= val && val < set[1]);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst matchingRows = rows.filter(filterFn);\n\n\t\t\t\t\tgroup.set(setName, matchingRows);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\t};\n\n\treturn grouperFn;\n}\n\nexport {\n\tcreateGroupFn,\n\n\tGrouper,\n};","function parse(csvString, mapper) {\r\n    const stringRows = _tokenise(csvString);\r\n    _validate(stringRows);\r\n    if (typeof mapper !== 'undefined') {\r\n        const dataRows = stringRows.map((row) => row.map(mapper));\r\n        return dataRows;\r\n    }\r\n    else {\r\n        return stringRows;\r\n    }\r\n}\r\n/**\r\n * Walk through each character and produce an array of cell values. Throws an error if the string is not formatted as expected for a CSV.\r\n *\r\n * @param {string} csvString - A string representation of a CSV.\r\n *\r\n * @throws {SyntaxError} - The csvString must not be malformed.\r\n */\r\nfunction _tokenise(csvString) {\r\n    // Walk through each character and produce an array of tokens\r\n    const tokens = [];\r\n    // Remove carriage returns\r\n    csvString = csvString.replace(/\\r/g, '');\r\n    let inQuote = false;\r\n    let wasQuote = false;\r\n    let tokenStart = 0;\r\n    let row = [];\r\n    for (let i = 0; i < csvString.length; i++) {\r\n        const char = csvString[i];\r\n        const comma = char === ',';\r\n        const quote = char === '\"';\r\n        const newline = char === '\\n';\r\n        const eof = i === csvString.length - 1; // eof - End Of File\r\n        if (inQuote) {\r\n            // Characters may be delimited\r\n            if (quote) {\r\n                // Check if the next character is another double quote, i.e. if it is escaped\r\n                const nextChar = csvString[i + 1];\r\n                if (nextChar === '\"') {\r\n                    // This and the next character combined make an escaped double quote,\r\n                    // so the quote has not ended and we should skip over the next character\r\n                    i++;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // The quote has ended\r\n                    inQuote = false;\r\n                    wasQuote = true;\r\n                    if (!eof) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            else if (eof) {\r\n                throw new SyntaxError(`CSV parse: Reached end of file before ending quote. At index ${i}`);\r\n            }\r\n        }\r\n        if (!inQuote && (comma || newline || eof)) {\r\n            // These are the characters that denote the end of a token\r\n            let token = csvString.substring(tokenStart, i + 1);\r\n            if (comma || newline) {\r\n                // Don't keep the separator\r\n                token = token.substring(0, token.length - 1);\r\n            }\r\n            if (wasQuote) {\r\n                wasQuote = false;\r\n                // Remove start and end quotes\r\n                token = token.substring(1, token.length - 1);\r\n                // Replace escaped quotes\r\n                token = token.replace(/\"\"/g, '\"');\r\n            }\r\n            row.push(token);\r\n            if (comma && eof) {\r\n                // It's the end of the last token, and the last cell is empty\r\n                row.push('');\r\n            }\r\n            if (newline || eof) {\r\n                tokens.push(row);\r\n                if (newline) {\r\n                    row = [];\r\n                }\r\n            }\r\n            tokenStart = i + 1;\r\n        }\r\n        else if (wasQuote) {\r\n            throw new SyntaxError(`CSV parse: A value must be complete immediately after closing a quote. At index ${i}`);\r\n        }\r\n        else if (quote) {\r\n            inQuote = true;\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n/**\r\n * Checks that an array of CSV values is rectangular, i.e. that each row has the same length.\r\n *\r\n * Throws a SyntaxError if validation fails.\r\n *\r\n * @param {string[][]} rows - A 2D array of CSV values.\r\n *\r\n * @throws {SyntaxError} - The rows 2D Array must not be malformed.\r\n */\r\nfunction _validate(rows) {\r\n    // Each row of a CSV should have the same length;\r\n    if (rows && rows.length > 1) {\r\n        let rowLength = rows[0].length;\r\n        for (let i = 1; i < rows.length; i++) {\r\n            let row = rows[i];\r\n            if (row.length !== rowLength) {\r\n                throw new SyntaxError(`CSV parse: Row ${i} does not have the same length as the first row (${rowLength})`);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport { parse };\r\n//# sourceMappingURL=parse.js.map","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { ChartOptions } from './ChartOptions.js';\n\nexport type ChartData<GroupName extends string = string> = {\n\tlabels: any[],\n\tgroupNames: GroupName[],\n\tgroups: number[][],\n\n\tmin?: number,\n\tmax?: number,\n\n\tstacked?: boolean,\n};\n\nexport function getChartData<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: ChartOptions<GroupName>): ChartData<GroupName> {\n\tconst [[, ...groupNames]] = summary; // Ignore first 'Value' entry in first row\n\tlet [, ...valueRows] = summary; // Ignore first row of group names\n\n\t// Extract the labels\n\tlet labels = valueRows.map((row) => row[0]);\n\n\t// If the x axis is qualitative, and its labels were limited in its options\n\tif (options?.x && 'labels' in options.x && options.x.labels) {\n\t\t// Remove any labels not specified in the axis options\n\t\tfor (let i = 0; i < labels.length; i++) {\n\t\t\tconst label = labels[i];\n\t\t\tif (options.x.labels.includes(label) === false) {\n\t\t\t\tlabels.splice(i, 1);\n\t\t\t\tvalueRows.splice(i, 1);\n\t\t\t\ti -= i;\n\t\t\t}\n\t\t}\n\n\t\t// Go through specified labels, and if any weren't in the dataset then add empty data\n\t\tfor (let i = 0; i < options.x.labels.length; i++) {\n\t\t\tconst label = options.x.labels[i];\n\t\t\tif (labels.includes(label) === false) {\n\t\t\t\tconst emptyData: [string, ...0[]] = [label, ...(new Array(valueRows[0].length-1)).fill(0)];\n\t\t\t\tlabels.splice(i, 0, label);\n\t\t\t\tvalueRows.splice(i, 0, emptyData);\n\t\t\t}\n\t\t}\n\n\t\t// Also update order of labels and value rows to match specified label order\n\t\tlabels = options.x.labels;\n\t\tvalueRows = valueRows.sort((rowA, rowB) => {\n\t\t\tconst labelA = rowA[0];\n\t\t\tconst indexA = labels.indexOf(labelA);\n\n\t\t\tconst labelB = rowB[0];\n\t\t\tconst indexB = labels.indexOf(labelB);\n\n\t\t\treturn indexA - indexB;\n\t\t});\n\t}\n\n\t// Transpose valueRows to get groups\n\tconst valueGroups: any[][] = [];\n\tfor (let i = 0; i < valueRows.length; i++) {\n\t\t// Start at j = 1 to ignore labels\n\t\tfor (let j = 1; j < valueRows[i].length; j++) {\n\t\t\tif (typeof valueGroups[j] === 'undefined') {\n\t\t\t\tvalueGroups[j] = [];\n\t\t\t}\n\t\t\tvalueGroups[j][i] = valueRows[i][j]\n\t\t}\n\t}\n\t// This method has given us an empty element at index 0, so remove it\n\tvalueGroups.splice(0, 1);\n\n\t// We can only graph groups if all their values are numbers\n\tconst numberValueGroups = valueGroups.filter(\n\t\t(group): group is number[] => group.every(\n\t\t\t(value): value is number => typeof value === 'number'\n\t\t)\n\t);\n\n\t// Filter out the same non-number groups from the groupNames list\n\tconst numberValueGroupNames = groupNames.filter(\n\t\t(groupName, index) => numberValueGroups.includes(valueGroups[index])\n\t);\n\n\tconst chartData: ChartData<GroupName> = {\n\t\tlabels,\n\t\tgroupNames: numberValueGroupNames,\n\t\tgroups: numberValueGroups,\n\t};\n\n\tif (options && 'stacked' in options) {\n\t\tchartData.stacked = options.stacked;\n\t}\n\n\treturn chartData;\n}\n","import * as statistics from '../statistics.js';\nimport { ChartData } from './ChartData.js';\nimport { ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\n\nexport interface ScaleOptions {\n\tmin: number,\n\tmax: number,\n}\n\nexport class Scale {\n\tmin: number;\n\tmax: number;\n\n\tget width(): number {\n\t\treturn this.max - this.min;\n\t};\n\n\tconstructor(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x') {\n\t\t[this.min, this.max] = getMinMax(options, chartOptions, type);\n\t}\n\n\t/**\n\t * Standardises the scale to go from 0 to 1,\n\t * then finds the value's position within it.\n\t */\n\tgetProportion(value: number): number {\n\t\tconst proportion = (value - this.min) / this.width;\n\n\t\treturn proportion;\n\t}\n\n\t/**\n\t * Given a proportion value on a scale from 0 to 1,\n\t * find the equivalent value on this scale.\n\t */\n\tgetValue(proportion: number): number {\n\t\tconst value = this.width * proportion + this.min;\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * For a given length of at least 2, create an array\n\t * of numbers from the bottom of the scale to the top,\n\t * with an equal step between each number in the range.\n\t */\n\tgetSeries(length: number): number[] {\n\t\tif (length < 2) {\n\t\t\tlength = 2;\n\t\t}\n\n\t\tconst stepSize = this.width / (length-1);\n\n\t\t// Start with minimum value\n\t\tconst series: number[] = [this.min];\n\n\t\t// Add intermediate steps\n\t\tfor (let i = 0; i < length-2; i++) {\n\t\t\tseries.push(series[series.length-1] + stepSize);\n\t\t}\n\n\t\t// End with max value\n\t\tseries.push(this.max);\n\n\t\treturn series;\n\t}\n}\n\n/**\n * Determines the appropriate method for reading or calculating min and max values,\n * based on the available data and options, then reads or calculates them.\n */\nfunction getMinMax(options: ScaleOptions | ChartData, chartOptions?: ChartOptions, type?: 'y' | 'x'): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\t// First, get minMax from options\n\tif ('groups' in options) {\n\t\t// options is of type ChartData, so determine min and max based on\n\t\t// the labels or the data, depending on the type of scale being created\n\t\tif (type === 'x') {\n\t\t\t[min, max] = getMinMaxFromChartDataLabels(options);\n\t\t} else {\n\t\t\t[min, max] = getMinMaxFromChartData(options);\n\t\t}\n\t} else {\n\t\t// options is a ScaleOptions, so read min and max directly\n\t\t[min, max] = getMinMaxFromScaleOptions(options);\n\t}\n\n\t// If min is larger than max, swap them around\n\tif (min > max) {\n\t\t[min, max] = [max, min];\n\t}\n\n\t// Then, see if min and/or max are overridden by chartOptions\n\tif (type && chartOptions) {\n\t\tconst axisOptions = chartOptions[type];\n\t\tif (axisOptions && ('min' in axisOptions || 'max' in axisOptions || 'values' in axisOptions)) {\n\t\t\tconst allowAuto = type !== 'x';\n\t\t\t[min, max] = getMinMaxFromAxisOptions(axisOptions, min, max, allowAuto);\n\t\t}\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the values contained in a set of ChartData.\n */\nfunction getMinMaxFromChartData(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { groups } = options;\n\n\tif (!groups.length || !groups[0].length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tlet allValues: number[];\n\tif ('stacked' in options && options.stacked) {\n\t\tallValues = groups[0].map((el, i) => groups.reduce((sum, group) => sum + group[i], 0));\n\t} else {\n\t\t// Use `as number[]` here so TypeScript doesn't complain when using Array.prototype.concat\n\t\tallValues = ([] as number[]).concat(...groups);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...allValues);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...allValues);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Calculates min and max values based on the labels for a set of ChartData.\n * Assumes all labels can be converted to numbers, and will throw an error if this assumption is false.\n */\nfunction getMinMaxFromChartDataLabels(options: ChartData): [number, number] {\n\tlet min: number;\n\tlet max: number;\n\n\tconst { labels } = options;\n\n\tif (!labels.length) {\n\t\tthrow new TypeError('Cannot extract minimum or maximum values from empty chart data.');\n\t}\n\n\tconst numberLabels = labels.map((label) => typeof label === 'number' ? label : +label);\n\tif (!numberLabels.every((label) => isNaN(label) === false)) {\n\t\tthrow new TypeError(`Cannot extract minimum or maximum values from labels that aren't all numbers.`);\n\t}\n\n\tif (typeof options.min === 'undefined') {\n\t\tmin = Math.min(...numberLabels);\n\t} else {\n\t\tmin = options.min;\n\t}\n\n\tif (typeof options.max === 'undefined') {\n\t\tmax = Math.max(...numberLabels);\n\t} else {\n\t\tmax = options.max;\n\t}\n\n\treturn [min, max];\n}\n\n/**\n * Reads min and max values directly from a ScaleOptions object.\n */\nfunction getMinMaxFromScaleOptions(options: ScaleOptions): [number, number] {\n\tconst { min, max } = options;\n\n\treturn [min, max];\n}\n\n/**\n * Determines min and max values from an AxisOptions object, either reading them\n * directly from the options or calculating them from the highest order of magnitude\n * and, if specified, the number of values that needs to display on an axis.\n */\nfunction getMinMaxFromAxisOptions(axisOptions: AxisOptionsQuantitative, min: number, max: number, allowAuto = true): [number, number] {\n\tif (\n\t\t(Array.isArray(axisOptions.values) && axisOptions.values.length) ||\n\t\t(Array.isArray(axisOptions.gridlines) && axisOptions.gridlines.length)\n\t) {\n\t\t// If all the axis values or gridlines are specified,\n\t\t// the values they determine can extend min and/or max\n\t\t// past the values already determined.\n\n\t\t// Axis options can specify values as dates, but Scale always works with numbers\n\t\tlet allValues: number[] = [];\n\t\tif (Array.isArray(axisOptions.values)) {\n\t\t\tallValues = allValues.concat(axisOptions.values.map((val) => +val));\n\t\t}\n\t\tif (Array.isArray(axisOptions.gridlines)) {\n\t\t\tallValues = allValues.concat(axisOptions.gridlines.map((val) => +val));\n\t\t}\n\t\tmin = Math.min(min, ...allValues);\n\t\tmax = Math.max(max, ...allValues);\n\t}\n\n\tif (typeof axisOptions.min === 'number') {\n\t\tmin = axisOptions.min;\n\t} else if (allowAuto && (axisOptions.min === 'auto' || typeof axisOptions.min === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Round down min to nearest multiple of that power of 10\n\t\tconst widthRoundTo = Math.pow(10, maxPower);\n\t\tmin = Math.floor(min / widthRoundTo) * widthRoundTo;\n\n\t\t// If the power was negative, fix any floating point issues that may have arisen\n\t\tif (maxPower < 0) {\n\t\t\tmin = +(min.toFixed(-maxPower));\n\t\t}\n\t}\n\n\tif (typeof axisOptions.max === 'number') {\n\t\tmax = axisOptions.max;\n\t} else if (allowAuto && (axisOptions.max === 'auto' || typeof axisOptions.max === 'undefined')) {\n\t\t// Determine highest power of 10 within min and max\n\t\tconst maxPower = Math.floor(\n\t\t\tMath.log10(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.abs(max),\n\t\t\t\t\tMath.abs(min),\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\t// Subtract min so we're working directly with the width\n\t\tmax -= min;\n\n\t\t// Round up max to nearest multiple of that power of 10\n\t\tlet widthRoundTo = Math.pow(10, maxPower);\n\t\tmax = Math.ceil(max / widthRoundTo) * widthRoundTo;\n\n\t\t// If the number of values to be displayed has been set\n\t\tif (typeof axisOptions.values === 'number') {\n\t\t\t// Only integers are accepted\n\t\t\tif (Number.isInteger(axisOptions.values) === false) {\n\t\t\t\tthrow new TypeError(`axisOptions.values must be an integer.`);\n\t\t\t}\n\n\t\t\t// Continue to increase max until it is a multiple of the next\n\t\t\t// greatest power of 10 below the largest one beneath max.\n\t\t\t// Also, ensure max is greater than min\n\t\t\tconst valuePower = maxPower - 1;\n\t\t\tlet valueRoundTo = Math.pow(10, valuePower) * axisOptions.values;\n\n\t\t\t// If that power is negative, JavaScript can run into issues\n\t\t\t// to do with numbers like 0.1 being unable to be represented in binary.\n\t\t\t// So multiply everything by that power and round it, then divide and fix at the end\n\t\t\tif (valuePower < 0) {\n\t\t\t\tvalueRoundTo = Math.round(valueRoundTo / Math.pow(10, valuePower));\n\t\t\t\twidthRoundTo = Math.round(widthRoundTo / Math.pow(10, valuePower));\n\t\t\t\tmax = Math.round(max / Math.pow(10, valuePower));\n\t\t\t}\n\n\t\t\tfor (let iterations = 0; iterations < 1000; iterations++) {\n\t\t\t\tlet remainder = max % valueRoundTo;\n\n\t\t\t\tif (remainder === 0 && max > 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tmax += widthRoundTo;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we muliplied everything earlier, undo that now then fix any floating point issues\n\t\t\tif (valuePower < 0) {\n\t\t\t\tmax = +(max * Math.pow(10, valuePower)).toFixed(-valuePower);\n\t\t\t}\n\t\t}\n\n\t\t// Add min back to convert width back to max\n\t\tmax += min;\n\t}\n\n\treturn [min, max];\n}\n","import { ChartData } from './ChartData.js';\nimport { BaseChartOptions, ChartOptions } from './ChartOptions.js';\nimport { AxisOptionsQuantitative } from './AxisOptions.js';\nimport { Scale } from './Scale.js';\n\nexport function chart<GroupName extends string>(chartData: ChartData<GroupName>, contents: string, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<figure class=\"chart\">\n\t\t\t${options?.title ? title(options) : ''}\n\n\t\t\t<div class=\"chart__area\">\n\t\t\t\t${options?.legend ? legend(chartData, options) : ''}\n\n\t\t\t\t${yGridlines(chartData, options)}\n\n\t\t\t\t${xGridlines(chartData, options)}\n\n\t\t\t\t${contents}\n\t\t\t</div>\n\n\t\t\t${yAxis(chartData, options)}\n\n\t\t\t${xAxis(chartData, options)}\n\t\t</figure>\n\t`;\n}\n\nfunction title<GroupName extends string>(options: ChartOptions<GroupName>): string {\n\treturn `<figcaption class=\"chart__title\">${options.title}</figcaption>`;\n}\n\nfunction legend<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\treturn `\n\t\t<div class=\"chart__legend\">\n\t\t\t<span class=\"chart__legend__title\">Legend</span>\n\n\t\t\t<ul class=\"chart__legend__items\">\n\t\t\t\t${chartData.groupNames.map((groupName, index) => {\n\t\t\t\t\tconst colour = options?.colours && options.colours[groupName];\n\n\t\t\t\t\tconst str = `<li class=\"chart__legend__item\">\n\t\t\t\t\t\t<span class=\"chart__legend__item__swatch\"${colour ? ` style=\"background-color: ${colour};\"` : ''}></span>\n\t\t\t\t\t\t<span class=\"chart__legend__item__name\">${groupName}</span>\n\t\t\t\t\t</li>`;\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t</div>\n\t`;\n}\n\nfunction yAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.y;\n\n\tconst scale = new Scale(chartData, options, 'y');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\t// Render axis based on scale\n\treturn `\n\t<div class=\"chart__y-axis\">\n\t\t${axisOptions?.title ? `\n\t\t<span class=\"chart__y-axis__title\">${axisOptions.title}</span>\n\t\t` : ''}\n\n\t\t<ul class=\"chart__y-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__y-axis__value\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxis<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\tif (axisOptions) {\n\t\t// AxisOptions has no required values, so we can only be certain what axis type we're dealing with if labels or values is specified\n\t\tif ('labels' in axisOptions) {\n\t\t\treturn xAxisQualitative(chartData, options);\n\t\t} else if ('values' in axisOptions) {\n\t\t\treturn xAxisQuantitative(chartData, options);\n\t\t}\n\t}\n\n\treturn xAxisMinimal(chartData, options);\n}\n\nfunction xAxisQualitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst { labels } = chartData;\n\n\t// For each label, render that label\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__label-list\">\n\t\t\t${labels.map((label) => `<li class=\"chart__x-axis__label\">${applyFormat(label, axisOptions)}</li>`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisQuantitative<GroupName extends string>(chartData: ChartData<GroupName>, options?: BaseChartOptions<GroupName, AxisOptionsQuantitative>): string {\n\tconst axisOptions = options?.x;\n\n\tconst scale = new Scale(chartData, options, 'x');\n\tconst { values, dates } = getAxisValues(scale, axisOptions);\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t\t<ul class=\"chart__x-axis__value-list\">\n\t\t\t${values.map((val) => `\n\t\t\t<li class=\"chart__x-axis__value\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\">\n\t\t\t\t${applyFormat(dates ? new Date(val) : val, axisOptions)}\n\t\t\t</li>\n\t\t\t`).join('')}\n\t\t</ul>\n\t</div>`;\n}\n\nfunction xAxisMinimal<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\treturn `\n\t<div class=\"chart__x-axis\">\n\t\t${axisOptions?.title ? `<span class=\"chart__x-axis__title\">${axisOptions.title}</span>` : ''}\n\t</div>`;\n}\n\nfunction yGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst scale = new Scale(chartData, options, 'y');\n\n\tconst axisOptions = options?.y;\n\tconst { values } = getAxisGridlines(scale, options?.y);\n\n\t// Render gridlines based on scale\n\treturn `\n\t\t<ul class=\"chart__y-gridlines\" role=\"presentation\">\n\t\t\t${values.map((val, index) => {\n\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t// since that line is already drawn by the x axis\n\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t<li class=\"chart__y-gridline\" style=\"bottom: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t'';\n\n\t\t\t\treturn gridlines\n\t\t\t}).join('')}\n\t\t</ul>\n\t`;\n}\n\nfunction xGridlines<GroupName extends string>(chartData: ChartData<GroupName>, options?: ChartOptions<GroupName>): string {\n\tconst axisOptions = options?.x;\n\n\tif (axisOptions && ('values' in axisOptions || 'gridlines' in axisOptions)) {\n\t\tconst scale = new Scale(chartData, options, 'x');\n\t\tconst { values } = getAxisGridlines(scale, axisOptions);\n\n\t\t// Render gridlines based on scale\n\t\treturn `\n\t\t\t<ul class=\"chart__x-gridlines\" role=\"presentation\">\n\t\t\t\t${values.map((val, index) => {\n\t\t\t\t\t// Only render the first gridline if it's above the minimum number,\n\t\t\t\t\t// since that line is already drawn by the y axis\n\t\t\t\t\tconst gridlines = (index > 0 || val > scale.min) ? `\n\t\t\t\t\t\t<li class=\"chart__x-gridline\" style=\"left: ${Math.max(0, scale.getProportion(val)) * 100}%;\"></li>` :\n\t\t\t\t\t\t'';\n\n\t\t\t\t\treturn gridlines\n\t\t\t\t}).join('')}\n\t\t\t</ul>\n\t\t`;\n\t} else {\n\t\treturn '';\n\t}\n}\n\nexport function tooltip<GroupName extends string>(chartData: ChartData<GroupName>, group: number[], label: string, options?: ChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst groupIndex = groups.indexOf(group);\n\tif (groupIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised group`);\n\t}\n\n\tconst groupName = groupNames[groupIndex];\n\n\tconst labelIndex = labels.indexOf(label);\n\tif (labelIndex === -1) {\n\t\tthrow new Error(`Cannot render tooltip: unrecognised label`);\n\t}\n\n\tconst value = group[labelIndex];\n\n\tconst str = `\n\t<div class=\"chart__tooltip\">\n\t\t${groups.length > 1 ? groupName : ''} ${label}: ${applyFormat(value, options?.y)}\n\t</div>`;\n\n\treturn str;\n}\n\ninterface AxisValues {\n\tvalues: number[],\n\tdates: boolean,\n}\n\nfunction getAxisValues(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.values !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.values);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tvalues = scale.getSeries(2);\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\nfunction getAxisGridlines(scale: Scale, axisOptions?: AxisOptionsQuantitative): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisOptions?.gridlines !== 'undefined') {\n\t\tconst axisValues = getAxisValuesBase(scale, axisOptions.gridlines);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t} else {\n\t\tconst axisValues = getAxisValues(scale, axisOptions);\n\t\tvalues = axisValues.values;\n\t\tdates = axisValues.dates;\n\t}\n\n\treturn {\n\t\tvalues,\n\t\tdates,\n\t};\n}\n\n/**\n * Both axis values and axis gridlines are retrieved in the same way, only with different fallbacks.\n * This base function contains that shared functionality, including the necessary conversion from\n * Date to number if the specified values are Dates, while remembering that they were Dates so they\n * can be converted back to Dates further down the line.\n */\nfunction getAxisValuesBase(scale: Scale, axisValues: Exclude<AxisOptionsQuantitative['values'], undefined>): AxisValues {\n\tlet values: number[];\n\tlet dates: boolean = false;\n\n\tif (typeof axisValues === 'number') {\n\t\tconst numValues = axisValues + 1;\n\t\tvalues = scale.getSeries(numValues);\n\t} else if (axisValues.length > 0) {\n\t\t// These type assertions are necessary because of how `Array.prototype.every` has been typed\n\t\t// https://stackoverflow.com/questions/71012370/narrowing-a-union-of-array-types-using-array-every\n\t\tif ((axisValues as unknown[]).every((val: unknown): val is number => typeof val === 'number')) {\n\t\t\tvalues = axisValues as number[];\n\t\t} else {\n\t\t\tdates = true;\n\t\t\tvalues = axisValues.map((val) => +val);\n\t\t}\n\t} else {\n\t\tvalues = axisValues as [];\n\t}\n\n\treturn { values, dates };\n}\n\nfunction applyFormat(value: any, axisOptions?: AxisOptionsQuantitative): string {\n\tif (typeof value === 'number') {\n\t\tif (axisOptions?.numberFormat) {\n\t\t\tif (axisOptions.numberFormat instanceof Intl.NumberFormat) {\n\t\t\t\treturn axisOptions.numberFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.numberFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else if (value instanceof Date) {\n\t\tif (axisOptions?.dateFormat) {\n\t\t\tif (axisOptions.dateFormat instanceof Intl.DateTimeFormat) {\n\t\t\t\treturn axisOptions.dateFormat.format(value);\n\t\t\t} else {\n\t\t\t\treturn axisOptions.dateFormat(value);\n\t\t\t}\n\t\t} else {\n\t\t\treturn value.toString();\n\t\t}\n\t} else {\n\t\treturn '' + value;\n\t}\n}\n","function getNumArray(val: number[] | [number[]]): number[] {\n\tif (\n\t\t((value: any[]): value is [number[]] => {\n\t\t\treturn value.length === 1 && Array.isArray(value[0]);\n\t\t})(val)\n\t) {\n\t\treturn val[0];\n\t} else {\n\t\treturn val;\n\t}\n}\n\n/**\n * Return the sum of an array of numbers.\n */\nexport function sum(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn numbers.reduce(function (sum: number, val: number) {\n\t\treturn sum + val;\n\t}, 0);\n}\n\n/**\n * Returns the mean of an array of numbers.\n */\nexport function mean(...arr: number[] | [number[]]): number {\n\tconst numbers = getNumArray(arr);\n\n\treturn sum(numbers) / numbers.length;\n}\n","import * as codebook from '@cipscis/codebook';\n\nimport * as analyser from '@cipscis/analyser';\nimport { sum } from '@cipscis/analyser/statistics';\n\ncodebook.tidy();\n\nconst analyse = async function () {\n\tconst fileInfoA = analyser.fileConfig({\n\t\tpath: '/analyser/assets/data/city example.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tNAME: 'A',\n\t\t\tCOUNTRY: 'B',\n\t\t\tPOPULATION: 'C',\n\t\t\tCAPITAL: 'D',\n\t\t\tPUBLIC_TRANSPORT: 'E',\n\t\t\tMAYOR_2012: 'F',\n\t\t\tMAYOR_2018: 'G',\n\t\t},\n\t\ttransform: {\n\t\t\tPOPULATION: analyser.transformers.number,\n\t\t\tCAPITAL: analyser.transformers.booleanCustom('true', /^$|^'no'$/i),\n\t\t\tPUBLIC_TRANSPORT: analyser.transformers.array(','),\n\t\t\tMAYOR_2018: analyser.transformers.array(','),\n\t\t},\n\t\taliases: [\n\t\t\t['New Zealand', 'Aotearoa']\n\t\t],\n\t});\n\n\tconst fileInfoB = analyser.fileConfig({\n\t\tpath: '/analyser/assets/data/city example 2.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tNAME: 'A',\n\t\t\tCOUNTRY: 'B',\n\t\t\tPOPULATION: 'C',\n\t\t},\n\t});\n\tconst fileInfoC = analyser.fileConfig({\n\t\tpath: '/analyser/assets/data/city example 3.csv',\n\t\theaderRows: 1,\n\t\tcols: {\n\t\t\tYEAR: 'A',\n\t\t\tPOPULATION: 'B',\n\t\t},\n\t});\n\n\tconst [cityData, cityData2, cityData3] = await Promise.all([\n\t\tanalyser.loadFile(fileInfoA),\n\t\tanalyser.loadFile(fileInfoB),\n\t\tanalyser.loadFile(fileInfoC),\n\t]);\n\n\tconst {\n\t\trows,\n\t\tcols,\n\t\taddedCols,\n\t\tby,\n\t\tgroup,\n\t} = cityData;\n\n\t// console.log(rows);\n\t// console.log(cols);\n\n\t// console.log(rows.filter(\n\t// \tby(cols.POPULATION, (pop: number) => pop > 1000)\n\t// \t.orBy(cols.POPULATION, (pop: number) => pop < 300)\n\t// \t.andBy(cols.MAYOR_2012, 'Len Brown')\n\t// ));\n\n\tconst getIndex = (row: any[], i: number): number => i;\n\n\taddedCols.INDEX = rows.addCol(getIndex);\n\t// console.log(addedCols.INDEX);\n\n\t// console.dir(group(rows, cols.COUNTRY));\n\n\t// console.table(group(rows, cols.COUNTRY).summarise({\n\t// \tnumber: (rows) => rows.length,\n\t// }));\n\n\t// console.table(group(rows, cols.PUBLIC_TRANSPORT).summarise({\n\t// \tnumber: (rows) => rows.length,\n\t// }));\n\n\tconst nameGroup = group(rows, cols.NAME);\n\tconst nameGroupSummary = nameGroup.summarise({\n\t\tpopulation: (rows) => sum(rows.getCol(cols.POPULATION) as number[]),\n\t\tpop_half: (rows) => sum(rows.getCol(cols.POPULATION) as number[]) / 2,\n\t});\n\tconst barChartHtml = analyser.bar(nameGroupSummary,\n\t{\n\t\ttitle: 'Bar Chart',\n\t\tlegend: true,\n\n\t\tcolours: {\n\t\t\tpopulation: 'blue',\n\t\t\tpop_half: 'red',\n\t\t},\n\n\t\ty: {\n\t\t\ttitle: 'population',\n\t\t\tvalues: 8,\n\t\t\t// values: [0, 1000, 6000],\n\t\t\t// gridlines: [0, 1000, 6000],\n\t\t\t// gridlines: [],\n\t\t\tgridlines: 4,\n\n\t\t\tnumberFormat: new Intl.NumberFormat('en-NZ', {\n\t\t\t\tuseGrouping: true,\n\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t}),\n\t\t\t// numberFormat: (value: number) => value.toFixed(2),\n\n\t\t\t// max: 'auto',\n\t\t\t// min: 'auto',\n\t\t\t// max: 6500,\n\t\t\t// min: -1000,\n\t\t},\n\t\tx: {\n\t\t\ttitle: 'City',\n\t\t\tlabels: ['Sydney', 'Hamburg', 'Auckland', 'Wellington', 'Christchurch', 'Hamilton', 'Nothing', 0],\n\t\t\tnumberFormat: (value: number) => value.toFixed(2),\n\t\t},\n\n\t\tstacked: true,\n\t});\n\n\tconst $barChart = document.getElementById('bar-chart');\n\tif ($barChart) {\n\t\t$barChart.innerHTML = barChartHtml;\n\t}\n\n\tconst lineChartHtml = analyser.line(\n\t\t[\n\t\t\t[, 'Line 1', 'Line 2'],\n\t\t\t[new Date(2022, 2, 1), 0, 50],\n\t\t\t[new Date(2022, 2, 2), 10, 40],\n\t\t\t[new Date(2022, 2, 4), 25, 20],\n\t\t\t[new Date(2022, 2, 5), 50, 15],\n\t\t\t[new Date(2022, 2, 6), 30, 30],\n\n\t\t\t// [1, 0, 50],\n\t\t\t// [2, 10, 40],\n\t\t\t// [3, 25, 20],\n\t\t\t// [4, 50, 15],\n\t\t\t// [5, 30, 30],\n\t\t],\n\t\t{\n\t\t\ttitle: 'Line Chart',\n\t\t\tlegend: true,\n\n\t\t\tcolours: {\n\t\t\t\t'Line 1': 'blue',\n\t\t\t\t// 'Line 2': 'red',\n\t\t\t},\n\n\t\t\ty: {\n\t\t\t\ttitle: 'y axis',\n\t\t\t\tvalues: 5,\n\n\t\t\t\tnumberFormat: new Intl.NumberFormat('en-NZ', {\n\t\t\t\t\tuseGrouping: true,\n\t\t\t\t\tmaximumFractionDigits: 0,\n\t\t\t\t}),\n\t\t\t},\n\n\t\t\tx: {\n\t\t\t\ttitle: 'x axis',\n\t\t\t\t// values: 5,\n\t\t\t\tvalues: [\n\t\t\t\t\tnew Date(2022, 2, 1),\n\t\t\t\t\tnew Date(2022, 2, 2),\n\t\t\t\t\tnew Date(2022, 2, 4),\n\t\t\t\t\tnew Date(2022, 2, 5),\n\t\t\t\t\tnew Date(2022, 2, 6),\n\t\t\t\t],\n\t\t\t\t// values: [0, 2, 4, 6],\n\n\t\t\t\tgridlines: 5,\n\t\t\t\t// gridlines: [\n\t\t\t\t// \tnew Date(2022, 2, 1),\n\t\t\t\t// \tnew Date(2022, 2, 2),\n\t\t\t\t// \tnew Date(2022, 2, 3),\n\t\t\t\t// \tnew Date(2022, 2, 4),\n\t\t\t\t// \tnew Date(2022, 2, 5),\n\t\t\t\t// \tnew Date(2022, 2, 6),\n\t\t\t\t// ],\n\t\t\t\t// gridlines: [1, 4],\n\n\t\t\t\t// numberFormat: (value: number) => value.toFixed(1),\n\t\t\t\tnumberFormat: (value: number) => {\n\t\t\t\t\tconst date = new Date(value);\n\t\t\t\t\tconst dateString = new Intl.DateTimeFormat('en-NZ', {\n\t\t\t\t\t\tdateStyle: 'short',\n\t\t\t\t\t}).format(date);\n\t\t\t\t\tconst timeString = new Intl.DateTimeFormat('en-NZ', {\n\t\t\t\t\t\ttimeStyle: 'short',\n\t\t\t\t\t}).format(date);\n\n\t\t\t\t\tconst dateTimeString = `${dateString} ${timeString}`;\n\n\t\t\t\t\treturn dateTimeString;\n\t\t\t\t},\n\t\t\t\tdateFormat: new Intl.DateTimeFormat('en-NZ'),\n\t\t\t},\n\t\t}\n\t);\n\n\tconst $lineChart = document.getElementById('line-chart');\n\tif ($lineChart) {\n\t\t$lineChart.innerHTML = lineChartHtml;\n\t}\n};\n\nanalyse();\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { BarChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderBars<GroupName extends string>(chartData: ChartData<GroupName>, options?: BarChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scale = new Scale(chartData, options, 'y');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<ul class=\"chart__bar-groups\">\n\t\t\t${labels.map((label, index) =>\n\t\t\t`<li class=\"chart__bar-group\">\n\t\t\t\t<ul class=\"chart__bar-group-bars${options?.stacked ? ` chart__bar-group-bars--stacked` : ''}\">\n\t\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\t\tconst colour = colours && colours[groupName];\n\t\t\t\t\t\tconst value = group[index];\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li\n\t\t\t\t\t\t\t\tclass=\"chart__bar\"\n\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t` style=\"flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t}%;\"` :\n\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclass=\"chart__bar__area\"\n\t\t\t\t\t\t\t\tstyle=\"\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\tcolour ?\n\t\t\t\t\t\t\t\t\t\t\t`background: ${colour}; ` :\n\t\t\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t${\n\t\t\t\t\t\t\t\t\t\toptions?.stacked ?\n\t\t\t\t\t\t\t\t\t\t\t'' :\n\t\t\t\t\t\t\t\t\t\t\t`flex-basis: ${\n\t\t\t\t\t\t\t\t\t\t\t\t(Math.max(0, scale.getProportion(value))) * 100\n\t\t\t\t\t\t\t\t\t\t\t}%;`\n\t\t\t\t\t\t\t\t\t}\" data-value=\"${value}\"\n\t\t\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>`\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t</li>`).join('')}\n\t\t</ul>\n\t`;\n}\n\nexport function bar<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: BarChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst bars = renderBars(chartData, options);\n\n\tconst chart = renderChart(chartData, bars, options);\n\n\treturn chart;\n};\n","import { AnalyserSummary } from '../AnalyserGroup.js';\nimport { LineChartOptions } from './ChartOptions.js';\n\nimport { ChartData, getChartData } from './ChartData.js';\nimport { Scale } from './Scale.js';\n\nimport { chart as renderChart, tooltip as renderTooltip } from './chart.js';\n\nfunction renderLines<GroupName extends string>(chartData: ChartData<GroupName>, options?: LineChartOptions<GroupName>): string {\n\tconst { labels, groups, groupNames } = chartData;\n\tconst { colours } = options || {};\n\tconst scaleY = new Scale(chartData, options, 'y');\n\tconst scaleX = new Scale(chartData, options, 'x');\n\n\t// For each label, render a bar from each group\n\treturn `\n\t\t<svg class=\"chart__lines\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"none\">\n\t\t\t<g transform=\"translate(0, 100) scale(1, -1)\">\n\t\t\t\t${groups.map((group, groupIndex) => {\n\t\t\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\t\t\tconst points = labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\t\t\t\t\t\tconst str = `${leftPercent},${percentage}`;\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join(' ');\n\n\t\t\t\t\tconst str = `\n\t\t\t\t\t\t<polyline class=\"chart__line\" points=\"${points}\"${colour ? ` style=\"stroke: ${colour};\"` : ''}></polyline>\n\t\t\t\t\t`;\n\n\t\t\t\t\treturn str;\n\t\t\t\t}).join('')}\n\t\t\t</g>\n\t\t</svg>\n\n\t\t${groups.map((group, groupIndex) => {\n\t\t\tconst groupName = groupNames[groupIndex];\n\t\t\tconst colour = colours && colours[groupName];\n\n\t\t\tconst str = `\n\t\t\t\t<ul class=\"chart__line__points\">\n\t\t\t\t\t${labels.map((label, labelIndex) => {\n\t\t\t\t\t\tconst leftPercent = scaleX.getProportion(+label) * 100;\n\n\t\t\t\t\t\tconst value = group[labelIndex];\n\t\t\t\t\t\tconst percentage = scaleY.getProportion(value) * 100;\n\n\t\t\t\t\t\tconst str = `\n\t\t\t\t\t\t\t<li class=\"chart__line__point\" style=\"left: ${leftPercent}%; bottom: ${percentage}%\" tabindex=\"0\">\n\t\t\t\t\t\t\t\t${renderTooltip(chartData, group, label, options)}\n\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t`;\n\n\t\t\t\t\t\treturn str;\n\t\t\t\t\t}).join('')}\n\t\t\t\t</ul>\n\t\t\t`;\n\n\t\t\treturn str;\n\t\t}).join('')}\n\t`;\n}\n\nexport function line<GroupName extends string>(summary: AnalyserSummary<GroupName>, options?: LineChartOptions<GroupName>) {\n\tconst chartData = getChartData(summary, options);\n\tconst lines = renderLines(chartData, options);\n\n\tconst chart = renderChart(chartData, lines, options);\n\n\treturn chart;\n};\n"],"names":["selectors","Object","freeze","block","set","inert","index","log","html","document","createElement","AnalyserRows","Array","constructor","source","isArray","super","length","i","this","getCol","colNum","TypeError","RangeError","col","row","push","addCol","creator","colIndex","Error","entries","getColNumber","colName","Number","isInteger","alphabet","rowNumber","upperColName","toUpperCase","char","charIndex","indexOf","Math","pow","getColNumbers","colsConfig","newCols","key","colNumber","defaultSummarisers","Count","rows","AnalyserGroup","Map","options","discrete","summarise","summarisersArg","summarisers","summaryHeaderRow","keys","summaryValueRows","groupName","summaryRow","summariser","rowSummary","summaryValuesSorted","map","sort","a","b","createFilterFn","aliases","values","_extendFilterFn","arr","_applyFilter","filterResolver","extendedFilterResolver","andBy","orBy","cell","cellValues","cellValue","value","_matchAlias","aliasList","includes","cleanNumberLike","replace","appearsNumber","cleanValue","parseFloat","array","separator","limit","split","booleanCustom","truthy","falsey","locationIdentifier","cleanedValue","trim","toLowerCase","test","console","warn","number","match","appearsPercentage","numValue","precision","toFixed","enumValue","enums","recodeMap","enumValues","val","join","async","loadFile","fileConfig","response","fetch","path","ok","headerRows","splice","footerRows","by","group","splitting","right","Set","add","isNonCanonical","isCanonical","has","delete","matchingRows","filter","setLimits","enumArr","every","x","min","max","setSize","setMin","setMax","splitValues","concat","Infinity","filterFn","setName","createGroupFn","dataConfig","raw","cols","addedCols","transform","transformFn","_processData","csvString","mapper","stringRows","tokens","inQuote","wasQuote","tokenStart","comma","quote","newline","eof","SyntaxError","token","substring","_tokenise","rowLength","_validate","parse","text","status","getChartData","summary","groupNames","valueRows","labels","label","emptyData","fill","rowA","rowB","labelA","indexA","labelB","valueGroups","j","numberValueGroups","numberValueGroupNames","chartData","groups","stacked","Scale","chartOptions","type","numberLabels","isNaN","getMinMaxFromChartDataLabels","allValues","el","reduce","sum","getMinMaxFromChartData","getMinMaxFromScaleOptions","axisOptions","allowAuto","gridlines","maxPower","floor","log10","abs","widthRoundTo","ceil","valuePower","valueRoundTo","round","iterations","getMinMaxFromAxisOptions","getMinMax","getProportion","width","getValue","proportion","getSeries","stepSize","series","contents","title","legend","colour","colours","scale","y","getAxisGridlines","yGridlines","xGridlines","dates","getAxisValues","applyFormat","Date","yAxis","xAxisQualitative","xAxisQuantitative","xAxisMinimal","xAxis","tooltip","groupIndex","labelIndex","axisValues","getAxisValuesBase","numValues","numberFormat","Intl","NumberFormat","format","toString","dateFormat","DateTimeFormat","$blocks","querySelectorAll","$block","code","innerHTML","level","pattern","RegExp","fileInfoA","NAME","COUNTRY","POPULATION","CAPITAL","PUBLIC_TRANSPORT","MAYOR_2012","MAYOR_2018","cityData","cityData2","cityData3","Promise","all","YEAR","INDEX","barChartHtml","renderBars","population","pop_half","useGrouping","maximumFractionDigits","$barChart","getElementById","lineChartHtml","scaleY","scaleX","leftPercent","renderLines","date","dateStyle","timeStyle","$lineChart","analyse"],"sourceRoot":""}