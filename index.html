<!DOCTYPE html>
<html>
<head>
	<title>Analyser</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />

	<link rel="stylesheet" href="/analyser/assets/css/main.css" />
	<script type="module" src="/analyser/assets/js/dist/docs-script.bundle.js"></script>
</head>
<body>
	<main class="layout">
		<section>
			<div class="content">
				<h1>Analyser</h1>

				<p>Analyser is a package for analysing and charting data in TypeScript, made available under the <a href="https://firstdonoharm.dev/" target="_blank">Hippocratic Licence</a>.</p>
			</div>
		</section>
		<section>
			<div class="content">
				<h2>About this page</h2>

				<p>This project is a rebuild of another data analysis library I created a few years ago called <a href="https://cipscis.github.io/charter/app/docs/" target="_blank">Charter</a>. Charter started as an attempt to create accessible graphs using HTML5 and CSS, and as I worked more on the code to generate those graphs it became more of a data analysis tool.</p>

				<p>Analyser is my attempt to rebuild this library in TypeScript, starting from the ground up with a clearer focus, after the lessons I've learned from using Charter to analyse complex data sets.</p>

				<p>This documentation is not yet complete, once I've finished each section I still need to reorganise the flow of the documentation and add some navigation aids.</p>
			</div>
		</section>

		<section>
			<div class="content">
				<h2 id="installation">Installation <a class="anchor" href="#installation"></a></h2>

				<p>You can install Analyser as an npm package:</p>

				<code>npm install @cipscis/analyser --save</code>

				<p>The main Analyser code can be imported with:</p>

				<code>import * as analyser from '@cipscis/analyser';</code>

				<p>Some parts of Analyser can also be accessed via submodules.</p>

				<p><a href="#usage-types">Type functions</a>:</p>

				<code>import { types } from '@cipscis/analyser';</code><br />
				<code>import * as types from '@cipscis/analyser/types';</code>

				<p><a href="#statistics">Statistical helper functions</a>:</p>

				<code>import { statistics } from '@cipscis/analyser';</code><br />
				<code>import * as statistics from '@cipscis/analyser/statistics';</code>
			</div>
		</section>

		<section>
			<div class="content">
				<h2 id="example-data">Example data <a class="anchor" href="#example-data"></a></h2>

				<p>This documentation uses example data:</p>
			</div>

			<script type="text/plain" class="js-codebook__block" data-codebook-html="html-example-data" data-codebook-set="example-data">
				const csvString = await (await fetch('/analyser/assets/data/city example.csv')).text();
				const data = csv.parse(csvString);

				const table = `<table>
					${data.map((row, i) => `<tr>
						${row.map((cell) => `<${i ? 'td' : 'th'}>
							${cell}
						</${i ? 'td' : 'th'}>`).join('')}
					</tr>`).join('')}
				</table>`;

				html(table);
			</script>

			<div class="content content--autoscroll" id="html-example-data">
				<p>A table showing the example data will load here.</p>
			</div>

			<div class="content">
				<p>The code examples in this documentation are editable, and run using <a href="https://cipscis.github.io/codebook" target="_blank">@cipscis/codebook</a>. Editable code is marked with a ‚úèÔ∏è, and its output is marked with a üìù.</p>

				<p>To ensure the examples' <code>log</code> and <code>html</code> helper functions work correctly, make sure you use <code>await</code> so all asynchronous code finishes before reaching the end of the example.</p>
			</div>

			<div class="docs-example js-docs__example js-codebook__set" data-codebook-set="example-output">
				<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-codebook-example" data-codebook-html="html-codebook-example" contenteditable spellcheck="false">
					log('You can log output');
					html('<p>Some examples can <b>print custom HTML</b></p>');
				</script>

				<div class="docs-example__controls">
					<button class="docs-example__control js-docs__run">Run code</button>
				</div>

				<div class="docs-example__html" id="html-codebook-example"></div>

				<samp class="docs-example__log js-docs__log" id="log-codebook-example"></samp>
			</div>
		</section>

		<section>
			<div class="content">
				<h2 id="usage">Usage <a class="anchor" href="#usage"></a></h2>

				<p>The first step to analysing data with Analyser is loading it. The <code><a href="#methods-loadFile">loadFile</a></code> method can be used to load data from a CSV file, using <a href="https://cipscis.github.io/csv" target="_blank">@cipscis/csv</a> internally for parsing and <a href="#usage-types">type functions</a> to determine types and do any necessary cleaning or recoding.</p>

				<p><code>loadFile</code> returns a <code><a href="#interfaces-Data">Data</a></code> object, which can be used to analyse the data using <a href="#methods-matchWithAlias">filtering</a> functions to filter the rows of data and <a href="#interfaces-Data-groupBy">grouping</a> functions to create summaries.</p>

				<p>Those summaries can then be used to <a href="#usage-graphs">create graphs</a>.</p>
			</div>

			<section>
				<div class="content">
					<h2 id="usage-types">Types <a class="anchor" href="#usage-types"></a></h2>

					<p>Analyser provides a number of <a href="#interfaces-TypeFn">type functions</a> for converting strings in CSV cells into common types. These can be imported from <code>'@cipscis/analyser/types'</code>.</p>

					<p>There are also some utility functions provided here for creating custom some simple type functions.</p>

					<p>Each of these functions can be accessed either via <code>analyser.types</code> or by importing them from the <code>@cipscis/analyser/types</code> submodule:</p>

					<code>import { types } from '@cipscis/analyser';</code><br />
					<code>import * as types from '@cipscis/analyser/types';</code>

					<p>If a type function is unable to transform a string value because it doesn't match its expectations, it will throw an error. When these errors are handled within <code><a href="#methods-loadFile">loadFile</a></code>, they will print a message to the console detailing the failure and its location within your data.</p>
				</div>

				<section class="js-codebook__set" data-codebook-set="usage-types-boolean">
					<div class="content">
						<h3 id="usage-types-boolean">boolean <a class="anchor" href="#usage-types-boolean"></a></h3>

						<p>If a value is <code>'true'</code> or <code>'false'</code>, ignoring case and any leading or trailing whitespace, then it is converted to the relevant boolean value.</p>

						<div class="docs-example js-docs__example">
							<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-types-boolean" contenteditable spellcheck="false">
								const fileConfig = analyser.fileConfig({
									path: '/analyser/assets/data/city example.csv',
									cols: {
										capital: ['D', analyser.types.boolean],
									},
									headerRows: 1,
									footerRows: 1,
								});

								const rows = await analyser.loadFile(fileConfig, { strict: false });
								log(rows.map(({ capital }) => capital));
							</script>

							<div class="docs-example__controls">
								<button class="docs-example__control js-docs__run">Run code</button>
							</div>

							<samp class="docs-example__log js-docs__log" id="log-usage-types-boolean"></samp>
						</div>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-types-booleanCustom">
					<div class="content">
						<h3 id="usage-types-booleanCustom">booleanCustom <a class="anchor" href="#usage-types-booleanCustom"></a></h3>

						<code>booleanCustom(truthy: string | RegExp, falsey: string | RegExp): <a href="#interfaces-TypeFn">TypeFn</a>&lt;boolean&gt;</code>

						<p>The <code>booleanCustom</code> helper function can be used to create a custom <a href="#interfaces-TypeFn">type function</a> for converting a string into boolean values.</p>

						<p>If a cell matches the string or regular expression in the <code>truthy</code> argument, it will be converted to <code>true</code>. Otherwise, if it matches the string or regular expression in the <code>falsey</code> argument, it will be converted to <code>false</code>.</p>

						<p>If strings are specified, the matching will be exact. If you need your match to be case-insensitive, or to ignore leading or trailing whitespace, then use a regular expression instead.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-types-booleanCustom" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									capital: ['D', analyser.types.booleanCustom('true', /^'No'$|^false$/)],
								},
								headerRows: 1,
							});

							const rows = await analyser.loadFile(fileConfig, { strict: false });
							log(rows.map(({ capital }) => capital));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-usage-types-booleanCustom"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-types-number">
					<div class="content">
						<h3 id="usage-types-number">number <a class="anchor" href="#usage-types-number"></a></h3>

						<p>If a cell's value looks like a number, it will be converted to a number. Analyser expects string representations of numbers to use the <code>'.'</code> character for a decimal point, and optionally the <code>','</code> character for separators within the number.</p>

						<p>If a string looks like a number and also ends with a <code>'%'</code> character, it will be divided by <code>100</code> to convert it into a percentage.</p>

						<div class="docs-example js-docs__example">
							<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-types-number" contenteditable spellcheck="false">
								const fileConfig = analyser.fileConfig({
									path: '/analyser/assets/data/city example.csv',
									cols: {
										population: ['C', analyser.types.number],
									},
									headerRows: 1,
									footerRows: 1,
								});

								const rows = await analyser.loadFile(fileConfig);
								log(rows.map(({ population }) => population));

								log(
									'Transforming a percentage:',
									analyser.types.number('0.2%')
								);
							</script>

							<div class="docs-example__controls">
								<button class="docs-example__control js-docs__run">Run code</button>
							</div>

							<samp class="docs-example__log js-docs__log" id="log-usage-types-number"></samp>
						</div>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-types-value">
					<div class="content">
						<h3 id="usage-types-value">value <a class="anchor" href="#usage-types-value"></a></h3>

						<p><code>value</code> combines the <a href="#usage-types-boolean">boolean</a> and <a href="#usage-types-number">number</a> type functions.</p>

						<p>If a cell looks like it contains a boolean, it will be converted to a boolean. Otherwise, if it looks like it contains a number, it will be converted to a number.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-types-value" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									population: ['C', analyser.types.value],
									capital: ['D', analyser.types.value],
								},
								headerRows: 1,
							});

							const rows = await analyser.loadFile(fileConfig, { strict: false });
							log(rows.map(({ population }) => population));
							log(rows.map(({ capital }) => capital));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-usage-types-value"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-types-array">
					<div class="content">
						<h3 id="usage-types-array">array <a class="anchor" href="#usage-types-array"></a></h3>

						<code>array(separator: string | RegExp, limit?: number): <a href="#interfaces-TypeFn">TypeFn</a>&lt;string[]&gt;</code>

						<p>The <code>array</code> function provided by Analyser can be used to create a <a href="#interfaces-TypeFn">type function</a> that converts a string into an array of strings.</p>

						<p>The arguments taken by the <code>array</code> helper function are the same as those used by <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank">String.prototype.split</a></code>.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-types-array" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									publicTransport: ['E', analyser.types.array(',')],
								},
								headerRows: 1,
							});

							const rows = await analyser.loadFile(fileConfig);
							log(rows.map(({ publicTransport }) => publicTransport));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-usage-types-array"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="usage-types--enumValue">
					<div class="content">
						<h3 id="usage-types-enumValue">enumValue <a class="anchor" href="#usage-types-enumValue"></a></h3>

						<code>enumValue&lt;E extends string&gt;(enums: Record&lt;string, E&gt;, recodeMap?: Record&lt;string, E&gt; | Iterable&lt;[string, E]&gt;): <a href="#interfaces-TypeFn">TypeFn</a>&lt;E&gt;</code>

						<p>The <code>enumValue</code> helper function can be used to create a custom <a href="#interfaces-TypeFn">type function</a> that ensures that the value of every cell in a column exists within an object like a string <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank">TypeScript enum</a>.</p>

						<p>By default, this function doesn't transform the values passed into it. Instead, it acts as a check that they exist within the passed <code>enum</code>.</p>

						<p>However, <code>enumValue</code> has an optional second parameter that can be used to transform strings that don't exist within the <code>enum</code> into strings that are members. These transformations are applied before the value's membership is checked.</p>

						<p>If the <code>recodeMap</code> argument is an <code>Iterable&lt;[string, E]&gt;</code>, such as a <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank">Map</a></code>, the only first matching entry will be used.</p>

						<p>Using the <code>recodeMap</code> argument can be particularly useful for data cleaning.</p>

						<div class="docs-example js-docs__example">
							<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-types-enumValue" contenteditable spellcheck="false">
								// When working in TypeScript, this could be a string enum
								const countries = {
									Aotearoa: 'Aotearoa',
									Australia: 'Australia',
									Germany: 'Germany',
								};

								const countriesMap = {
									'New Zealand': 'Aotearoa',
								};

								const fileConfig = analyser.fileConfig({
									path: '/analyser/assets/data/city example.csv',
									cols: {
										country: ['B', analyser.types.enumValue(countries, countriesMap)],
									},
									headerRows: 1,
									footerRows: 1,
								});

								const rows = await analyser.loadFile(fileConfig);
								log(rows.map(({ country }) => country));
							</script>

							<div class="docs-example__controls">
								<button class="docs-example__control js-docs__run">Run code</button>
							</div>

							<samp class="docs-example__log js-docs__log" id="log-usage-types-enumValue"></samp>
						</div>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h2 id="usage-graphs">Graphs <a class="anchor" href="#usage-graphs"></a></h2>

					<p>Once data has been processed and analysed, Analyser is able to produce some forms of graphs from numerical summaries of data created through <code><a href="#interfaces-DataGroup-summarise">DataGroup.summarise()</a></code>.</p>

					<p>These graphs are created using HTML and some SVG, and rely on Analyser's CSS to make them appear correctly. They are designed to be reasonably accessible to screen reader users. The base CSS for them is written in Sass, and can be found in <code>~/docs/assets/scss/_chart.scss</code>.</p>

					<p>The methods Analyser uses to create graphs rely on some common interfaces for configuring their labels and axes.
				</div>

				<section>
					<div class="content">
						<h3 id="usage-graphs-ChartOptions">ChartOptions</h3>

						<code class="code--block js-codebook__inert">
							<a href="#usage-graphs-ChartOptions-title">title</a>?: string,
							<a href="#usage-graphs-ChartOptions-legend">legend</a>?: boolean,

							<a href="#usage-graphs-ChartOptions-colours">colours</a>?: Record&lt;string, string&gt;,

							<a href="#usage-graphs-ChartOptions-x">x</a>?: <a href="#usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative</a> | <a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a>,
							<a href="#usage-graphs-ChartOptions-y">y</a>?: <a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a>,

							<a href="#usage-graphs-ChartOptions-stacked">stacked</a>?: boolean,
						</code>

						<p>All charts share a common <code>ChartOptions</code> interface, with only minor differences between chart types.</p>
					</div>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-title"><code>title</code> <a class="anchor" href="#usage-graphs-ChartOptions-title"></a></h4>
						</div>

						<p>The title to display above the graph.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-legend"><code>legend</code> <a class="anchor" href="#usage-graphs-ChartOptions-legend"></a></h4>
						</div>

						<p>Whether or not a legend should be displayed. The position of the legend can be controlled via CSS.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-colours"><code>colours</code> <a class="anchor" href="#usage-graphs-ChartOptions-colours"></a></h4>
						</div>

						<p>An object representing what colours each group of data included on the graph should be. The property names of this object should line up with the names of the summaries that have been created.</p>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-x"><code>x</code> <a class="anchor" href="#usage-graphs-ChartOptions-x"></a></h4>

							<p>The configuration options for a graph's x axis might be quantitative or qualitative, depending on the type of chart. This option uses either the <code><a href="#usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative</a></code> or <code><a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a></code> interface depending on what is required by the graph.</p>
						</div>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-y"><code>y</code> <a class="anchor" href="#usage-graphs-ChartOptions-y"></a></h4>

							<p>A graph's y axis is always configured using the <code><a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a></code> interface.</p>
						</div>
					</section>

					<section>
						<div class="content">
							<h4 id="usage-graphs-ChartOptions-stacked"><code>stacked</code> <a class="anchor" href="#usage-graphs-ChartOptions-stacked"></a></h4>

							<p>Analyser's <a href="#usage-graphs-bar">bar graphs</a> support the <code>stacked</code> property to generate a stacked bar chart.</p>
						</div>
					</section>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative <a class="anchor" href="#usage-graphs-AxisOptionsQualitative"></a></h3>

					<code class="code--block js-codebook__inert">
						{
							<a href="#usage-graphs-AxisOptionsQualitative-title">title</a>?: string,

							<a href="#usage-graphs-AxisOptionsQualitative-numberFormat">numberFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> | ((value: number) => string),
							<a href="#usage-graphs-AxisOptionsQualitative-dateFormat">dateFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> | ((value: Date) => string),

							<a href="#usage-graphs-AxisOptionsQualitative-labels">labels</a>?: string[],
						}
					</code>
				</div>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-title"><code>title</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-title"></a></h4>

						<p>The axis title.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-numberFormat"><code>numberFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-numberFormat"></a></h4>

						<p>If any of the axis's values are numbers, the <code>numberFormat</code> property will determine how those numbers are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> object or by passing a custom function that takes in a number and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-dateFormat"><code>dateFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-dateFormat"></a></h4>

						<p>If any of the axis's values are dates, the <code>dateFormat</code> property will determine how those dates are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> or by passing a custom function that takes in a <code>Date</code> and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQualitative-labels"><code>labels</code> <a class="anchor" href="#usage-graphs-AxisOptionsQualitative-labels"></a></h4>

						<p>The labels to display on the axis. If absent, these labels will be gathered automatically from the <a href="#interfaces-DataGroup-summarise">summary</a> used to create the graph.</p>

						<p>This property can be used to customise the order of the data, and to exclude certain items from appearing on the graph. If a label that doesn't exist in the data is added, empty data will be generated to be used for it.</p>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative"></a></h3>

					<code class="code--block js-codebook__inert">
						{
							<a href="#usage-graphs-AxisOptionsQuantitative-title">title</a>?: string,

							<a href="#usage-graphs-AxisOptionsQuantitative-numberFormat">numberFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> | ((value: number) => string),
							<a href="#usage-graphs-AxisOptionsQuantitative-dateFormat">dateFormat</a>?: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> | ((value: Date) => string),

							<a href="#usage-graphs-AxisOptionsQuantitative-values">values</a>?: number | number[] | Date[],
							<a href="#usage-graphs-AxisOptionsQuantitative-gridlines">gridlines</a>?: number | number[] | Date[],

							<a href="#usage-graphs-AxisOptionsQuantitative-max">max</a>?: number | 'auto',
							<a href="#usage-graphs-AxisOptionsQuantitative-min">min</a>?: number | 'auto',
						}
					</code>
				</div>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQuantitative-title"><code>title</code> <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative-title"></a></h4>

						<p>The axis title.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQuantitative-numberFormat"><code>numberFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative-numberFormat"></a></h4>

						<p>If any of the axis's values are numbers, the <code>numberFormat</code> property will determine how those numbers are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat" target="_blank">Intl.NumberFormat</a> object or by passing a custom function that takes in a number and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQuantitative-dateFormat"><code>dateFormat</code> <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative-dateFormat"></a></h4>

						<p>If any of the axis's values are dates, the <code>dateFormat</code> property will determine how those dates are converted into strings. This can be done either via an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat" target="_blank">Intl.DateTimeFormat</a> or by passing a custom function that takes in a <code>Date</code> and returns a string.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQuantitative-values"><code>values</code> <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative-values"></a></h4>

						<p>This property can be used to specify the values that appear on a quantitative axis.</p>

						<p>If it is a <code>number</code>, Analyser will generate that many equally spaced values between the minimum and maximum values.</p>

						<p>If it is a <code>number[]</code>, Analyser will display each of the numbers in the array on the axis and no other values.</p>

						<p>Note that, when using the <code>number</code> form, the minimum value <em>does not count</em> against the number of values. This is for ease of use when working with data with a baseline at <code>0</code>, so a number of values that is a divisor of the maximum value (or, for data without a <code>0</code> minimum, a divisor of the range of the data) that will cause integer values to be generated.</p>

						<p>This allows for easier generation of values in many circumstances, for example specifying <code>values</code> of <code>5</code> for an axis that goes from <code>0</code> to <code>5000</code> will result in a value at each interval of <code>1000</code>.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQuantitative-gridlines"><code>gridlines</code> <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative-gridlines"></a></h4>

						<p>The <code>gridlines</code> property works the same as the <code><a href="#usage-graphs-AxisOptionsQuantitative-values">values</a></code> property, except instead of generating values to display on the axis it generates gridlines to extend from the axis.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQuantitative-max"><code>max</code> <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative-max"></a></h4>

						<p>Setting <code>max</code> to a <code>number</code> will override the maximum value of the axis.</p>

						<p>Alternately, setting <code>max</code> to the string <code>'auto'</code> will allow Analyser to try to intelligently determine the maximum value. It does this by rounding the maximum value in the data up to the nearest multiple of the largest power of 10 beneath it. So, for example, <code>13</code> would round up to <code>20</code> whereas <code>723</code> would round up to <code>800</code>.</p>

						<p>If both <code>max</code> and <code><a href="#usage-graphs-AxisOptionsQuantitative-min">min</a></code> are absent, the maximum and minimum values in the data will be used. However, if either one of them is set then the other will default to <code>'auto'</code> behaviour.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="usage-graphs-AxisOptionsQuantitative-min"><code>min</code> <a class="anchor" href="#usage-graphs-AxisOptionsQuantitative-min"></a></h4>

						<p>Like the <code><a href="#usage-graphs-AxisOptionsQuantitative-max">max</a></code> property, <code>min</code> can be used to override the minimum value of an axis. If set to <code>'auto'</code> Analyser will determine a sensible minimum value in the same way as with <code>max</code>, except it will instead start with the minimum value in the data and round down.</p>
					</div>
				</section>
			</section>

			<section class="js-codebook__set" data-codebook-set="usage-graphs-bar">
				<div class="content">
					<h3 id="usage-graphs-bar">bar <a class="anchor" href="#usage-graphs-bar"></a></h3>

					<code><span class="todo">bar(summary: AnalyserSummary, options?: BarChartOptions)</span></code>

					<p>Bar charts have a qualitative x axis, so use the <code><a href="#usage-graphs-AxisOptionsQualitative">AxisOptionsQualitative</a></code> interface for configuring their x axis.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-graphs-bar" data-codebook-html="html-usage-graphs-bar" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								country: ['B', analyser.types.string],
								population: ['C', analyser.types.number],
							},
							headerRows: 1,
							footerRows: 1,

							aliases: [
								['Aotearoa', 'New Zealand'],
							],
						});

						const rows = await analyser.loadFile(fileConfig);

						const countryGroup = rows.groupBy('country');

						const meanPopulationSummary = countryGroup.summarise({
							mean: (rows) => analyser.statistics.mean(rows.map(({ population }) => population)),
						});
						log('Mean city population by country:', meanPopulationSummary);

						const barChartHtml = analyser.bar(meanPopulationSummary, {
							title: 'Mean city population',
							legend: true,

							colours: {
								'mean': '#ff0000',
							},

							x: {
								title: 'Country',

								labels: ['Australia', 'Germany', 'Aotearoa'],
							},
							y: {
								title: 'Population',

								numberFormat: new Intl.NumberFormat('en-nz', { useGrouping: 'always', roundingIncrement: 1 }),

								values: 5,
								min: 0,
							},

							stacked: true,
						});

						html(barChartHtml);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<div class="docs-example__html" id="html-usage-graphs-bar"></div>

					<samp class="docs-example__log js-docs__log" id="log-usage-graphs-bar"></samp>
				</div>
			</section>

			<section>
				<div class="content">
					<h3 id="usage-graphs-line">line <a class="anchor" href="#usage-graphs-line"></a></h3>

					<code><span class="todo">line(summary: AnalyserSummary, options?: LineChartOptions)</span></code>

					<p>Line charts have a quantitative x axis, so use the <code><a href="#usage-graphs-AxisOptionsQuantitative">AxisOptionsQuantitative</a></code> interface for configuring their x axis.</p>
				</div>

				<div class="docs-example js-docs__example todo">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-usage-graphs-line" data-codebook-html="html-usage-graphs-line" contenteditable spellcheck="false"></script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<div class="docs-example__html" id="html-usage-graphs-line"></div>

					<samp class="docs-example__log js-docs__log" id="log-usage-graphs-line"></samp>
				</div>
			</section>
		</section>

		<section>
			<div class="content">
				<h2 id="interfaces">Interfaces <a class="anchor" href="#interfaces"></a></h2>
			</div>

			<section class="js-codebook__set" data-codebook-set="FileConfig">
				<div class="content">
					<h3 id="interfaces-FileConfig">FileConfig <a class="anchor" href="#interfaces-FileConfig"></a></h3>

					<code class="code--block js-codebook__inert">
					{
						<a href="#interfaces-FileConfig-path">path</a>: string,
						<a href="#interfaces-FileConfig-cols">cols</a>: Record&lt;string, [string | number, <a href="#interfaces-TypeFn">TypeFn</a>]&gt;,

						<a href="#interfaces-FileConfig-headerRows">headerRows</a>?: number,
						<a href="#interfaces-FileConfig-footerRows">footerRows</a>?: number,
						<a href="#interfaces-FileConfig-ignoreRows">ignoreRows</a>?: (row: RowShape, cols: Record&lt;string, number&gt;) => boolean,

						<a href="#interfaces-FileConfig-aliases">aliases</a>?: string[][],
					}
					</code>

					<p>A <code>FileConfig</code> object tells Analyser everything it needs to know to process a file, including where it is and what sort of contents to expect.</p>

					<p>A <code>FileConfig</code> object can be created directly, but because of how TypeScript's generic type inference is limited to functions it is recommended to use the <code><a href="#methods-fileConfig">fileConfig</a></code> method provided when working with TypeScript in order to improve both type checking when creating the object and autocompletion prompts for column names after the file has been read.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-FileConfig" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								name: ['A', analyser.types.string],
								country: ['B', analyser.types.string],
								population: ['C', analyser.types.number],
								capital: ['D', analyser.types.booleanCustom('true', '\'No\'')],
								publicTransport: ['E', analyser.types.array(',')],
								mayor2012: ['F', analyser.types.array(',')],
								mayor2018: ['G', analyser.types.array(',')],
							},

							headerRows: 1,
							footerRows: 1,

							aliases: [
								['Aotearoa', 'New Zealand'],
							],
						});

						const rows = await analyser.loadFile(fileConfig, { strict: false });

						log('First row:', rows[0]);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-FileConfig"></samp>
				</div>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-path"><code>path</code> <a class="anchor" href="#interfaces-FileConfig-path"></a></h4>

						<p>This string is used to <a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch" target="_blank">fetch</a> the CSV file to be processed.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-cols"><code>cols</code> <a class="anchor" href="#interfaces-FileConfig-cols"></a></h4>

						<p>The <code>cols</code> object specifies the names and locations of each column to be processed, as well as what type it should have. Not every column present in the file needs to be specified, but you should specify each column that you wish to access.</p>

						<p>If the a column's location is specified as a string, it will be passed through <code><a href="#methods-getColNumber">getColNumber</a></code> to convert it into a number.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-headerRows"><code>headerRows</code> <a class="anchor" href="#interfaces-FileConfig-headerRows"></a></h4>

						<p>An optional integer to specify how many rows at the start of the CSV file should be ignored, such as header rows.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-footerRows"><code>footerRows</code> <a class="anchor" href="#interfaces-FileConfig-footerRows"></a></h4>

						<p>An optional integer to specify how many rows at the end of the CSV file should be ignored, such as total rows.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-ignoreRows"><code>ignoreRows</code> <a class="anchor" href="#interfaces-FileConfig-ignoreRows"></a></h4>

						<p>An optional function that should return <code>true</code> when it's passed any row that should be ignored.</p>
					</div>
				</section>

				<section>
					<div class="content">
						<h4 id="interfaces-FileConfig-aliases"><code>aliases</code> <a class="anchor" href="#interfaces-FileConfig-aliases"></a></h4>

						<p>When <a href="#methods-matchWithAlias">filtering</a> and <a href="#interfaces-Data-groupBy">grouping</a> data, it can be useful to treat different values as if they were the same, particularly if the source data is inconsistent.</p>

						<p>Each element in the <code>aliases</code> array is an array of strings, where each string is treated as being equal to each other string in the array when filtering the data.</p>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-Data">Data <a class="anchor" href="#interfaces-Data"></a></h3>

					<p>The <code>Data</code> class extends the native <code>Array</code> class. For most purposes, it can be treated the same as any regular <code>Array</code>, for example by calling methods such as <code>Array.prototype.filter</code>.</p>

					<p>The key difference between <code>Data</code> and a native <code>Array</code> is that, if the data was processed with a set of <a href="#interfaces-FileConfig-aliases">aliases</a>, these aliases will be preserved in the <code><a href="#interfaces-Data-aliases">aliases</a></code> property.</p>

					<p>An <code>Data</code> object is returned by <code><a href="#methods-loadFile">loadFile</a></code>.</p>
				</div>

				<section>
					<div class="content">
						<h4 id="interfaces-Data-aliases">aliases <a class="anchor" href="#interfaces-Data-aliases"></a></h4>

						<p>If <code><a href="#methods-loadFile">loadFile</a></code> was called with a <code><a href="#interfaces-FileConfig">FileConfig</a></code> that contained a <code><a href="#interfaces-FileConfig-aliases">aliases</a></code> property, those aliases are preserved here. This makes them available to be used with the <code><a href="#methods-matchWithAlias">matchWithAlias</a></code> method.</p>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="interfaces-Data-addCol">
					<div class="content">
						<h4 id="interfaces-Data-addCol">addCol <a class="anchor" href="#interfaces-Data-addCol"></a></h4>

						<code>addCol&lt;T&gt;(colName: string, creator: (row: RowShape, index: number, data: Data) => T): Data</code><br />
						<code>addCol&lt;T&gt;(colName: string, newRow: T[]): Data</code><br />

						<p>The <code>addCol</code> method is used to add a new row to an <code>Data</code> object.</p>

						<p>To ensure proper type inference when working with TypeScript, this results in a new <code>Data</code> object that contains the new column.</p>

						<p>There are two methods of calling <code>addCol</code>. The primary method relies on a <code>creator</code> function, which works similarly to a function passed to <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">Array.prototype.map</a></code>. This <code>creator</code> function takes a single row object and that row's index, and creates the value that row should have in the new column.</p>

						<p>The second method of calling <code>addCol</code> simply passes a newly constructed column in entirely, as an array. This array must be of the same length as the <code>Data</code> being added to.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-interfaces-Data-addCol" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									popThousands: ['C', analyser.types.number],
									publicTransport: ['E', analyser.types.array(',')],
								},
								headerRows: 1,
								footerRows: 1,
							});

							const rows = await analyser.loadFile(fileConfig);

							const rowsWithPop = rows.addCol('pop', (row) => row.popThousands * 1000);
							log(rowsWithPop.map(({ pop }) => pop));

							const hasTrainCol = rowsWithPop.map((row) => row.publicTransport.includes('Train'));
							const rowsWithHasTrain = rowsWithPop.addCol('hasTrain', hasTrainCol);
							log(rowsWithHasTrain.map(({ hasTrain }) => hasTrain));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-interfaces-Data-addCol"></samp>
					</div>
				</section>

				<section class="js-codebook__set" data-codebook-set="interfaces-Data-groupBy">
					<div class="content">
						<h4 id="interfaces-Data-groupBy">groupBy <a class="anchor" href="#interfaces-Data-groupBy"></a></h4>

						<p>The <code>groupBy</code> method is used for grouping rows in a <code>Data</code> object.</p>

						<p>These groups can then be used to produce summaries of the data, which in turn can be used to create <a href="#usage-graphs">graphs</a>.</p>

						<p>The <code>groupBy</code> function effectively has any <a href="#interfaces-FileConfig-aliases">aliases</a> baked in, with any values in a set of aliases treated as though they were the first value in the set. That first value does not need to appear in the data, but it will always be used in any <code><a href="#interfaces-DataGroup">DataGroup</a></code> created by <code>group</code>.</p>

						<p><code>group</code> has three overrides:</p>

						<code>(colName: string): <a href="#interfaces-DataGroup">DataGroup</a></code><br />
						<code>(colName: string, numGroups: number, right: boolean = true): <a href="#interfaces-DataGroup">DataGroup</a></code><br />
						<code>(colName: string, splitPoints: number[], right: boolean = true): <a href="#interfaces-DataGroup">DataGroup</a></code>

						<p>When grouping by discrete data, the first override should always be used. The other two overrides provide different methods for dividing continuous data into groups.</p>

						<p>If the <code>numGroups</code> argument is provided with a number, <code>group</code> will split the continuous data into that many groups of the same range. For example, if the data ranges from <code>0</code> to <code>100</code> and the <code>numGroups</code> argument is <code>5</code>, the first group would contain data from <code>0</code> to <code>20</code>.</p>

						<p>Otherwise, the <code>splitPoints</code> argument can be provided with an array of numbers, which will be used as the points where the groups will be split.</p>

						<p>For both of the continuous data overloads, there is an optional <code>right</code> argument that determines which end of a group is open. If <code>right</code> is <code>true</code> (its default value), then values equal to the upper limit of a group will be included. Otherwise, values equal to a group's lower limit will be included instead.</p>

						<p>However, the first and last group will always include values at their outer boundaries, since they will be determined based on the minimum and maximum values in the data set.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-interfaces-Data-groupBy" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									name: ['A', analyser.types.string],
									country: ['B', analyser.types.string],
									pop: ['C', analyser.types.number],
								},

								headerRows: 1,
								footerRows: 1,

								aliases: [
									['Aotearoa', 'New Zealand'],
								],
							});

							const rows = await analyser.loadFile(fileConfig);

							const groupByCountry = rows.groupBy('country');
							log('Grouped by country:');
							groupByCountry.forEach((groupRows, name) => log(name, groupRows.length));

							const groupByPopulation = rows.groupBy('pop', 5);
							log('Grouped by population:');
							groupByPopulation.forEach((groupRows, name) => log(name, groupRows.length));

							const groupByPopulationCustom = rows.groupBy('pop', [50, 200, 1000]);
							log('Grouped by population (custom split points):');
							groupByPopulationCustom.forEach((groupRows, name) => log(name, groupRows.length));
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-interfaces-Data-groupBy"></samp>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-DataGroup">DataGroup <a class="anchor" href="#interfaces-DataGroup"></a></h3>

					<p>The <code>DataGroup</code> class extends the native <code>Map</code> class to add an additional method. It is primarily intended to be interacted with only through this method.</p>
				</div>

				<section class="js-codebook__set" data-codebook-set="interfaces-DataGroup-summarise">
					<div class="content">
						<h4 id="interfaces-DataGroup-summarise">summarise <a class="anchor" href="#interfaces-DataGroup-summarise"></a></h4>

						<code>summarise(summarisers?: Record&lt;string, (rows: Data, groupName: unknown) => unknown&gt;): unknown[][]</code>

						<p>The <code>summarise</code> method converts a <code>DataGroup</code> into a specially formatted 2D array made for easy viewing. The first row is a header row, giving the name of each summary, and the first column gives the name of each group from the <code>DataGroup</code> used to create it. The other cells each contain a particular summary of that group.</p>

						<p>By default, if not passed a <code>summarisers</code> argument, the default "Count" summary will be used, which calculates the number of rows in each group.</p>

						<p>More complex summaries can be passed to the <code>summarise</code> function as an object where each property is a function that takes an <code>Data</code> and the name of its group and produces some result.</p>

						<p>Summaries that all produce numeric results can then be used to <a href="#usage-graphs">create graphs</a>.</p>
					</div>

					<div class="docs-example js-docs__example">
						<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-interfaces-DataGroup-summarise" contenteditable spellcheck="false">
							const fileConfig = analyser.fileConfig({
								path: '/analyser/assets/data/city example.csv',
								cols: {
									country: ['B', analyser.types.string],
									population: ['C', analyser.types.number],
								},
								headerRows: 1,
								footerRows: 1,
								aliases: [
									['Aotearoa', 'New Zealand'],
								],
							});

							const rows = await analyser.loadFile(fileConfig);

							const countryGroup = rows.groupBy('country');

							const countSummary = countryGroup.summarise();
							log('Count of cities by country:', countSummary);

							const meanPopulationSummary = countryGroup.summarise({
								mean: (rows, groupName) => analyser.statistics.mean(rows.map(({ population }) => population)),
							});
							log('Mean city population by country:', meanPopulationSummary);
						</script>

						<div class="docs-example__controls">
							<button class="docs-example__control js-docs__run">Run code</button>
						</div>

						<samp class="docs-example__log js-docs__log" id="log-interfaces-DataGroup-summarise"></samp>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-LoadFileOptions">LoadFileOptions <a class="anchor" href="#interfaces-LoadFileOptions"></a></h3>

					<code class="code--block js-codebook__inert">
					{
						<a href="#interfaces-LoadFileOptions-strict">strict</a>?: boolean = true,
					}
					</code>

					<p>The <code>LoadFileOptions</code> interfaces can be used to configure the behaviour of <code><a href="#methods-loadFile">loadFile</a></code>.</p>
				</div>

				<section>
					<div class="content">
						<h4 id="interfaces-LoadFileOptions-strict">strict <a class="anchor" href="#interfaces-LoadFileOptions-strict"></a></h4>

						<p>This property controls how <code><a href="#methods-loadFile">loadFile</a></code> deals with errors being thrown by type functions.</p>

						<p>By default, these errors will not be handled within Analyser, and they will print an error to the console detailing where the value that caused the error exists in your data.</p>

						<p>However, if <code>strict</code> is set to <code>false</code>, then instead these errors will result in a warning being passed to the console, and the value that caused the error will be converted to <code>null</code>.</p>

						<p>This non-strict mode should only be used when initially determining how a data set should be processed, as the conversion of data to <code>null</code> is not type safe.</p>
					</div>
				</section>
			</section>

			<section>
				<div class="content">
					<h3 id="interfaces-TypeFn">TypeFn <a class="anchor" href="#interfaces-TypeFn"></a></h3>

					<code>TypeFn&lt;T&gt; (value: string, locationIdentifier?: string): T extends unknown[] ? T : (T | null)</code>

					<p>Type functions are used to convert strings in a CSV file into typed data that can be further analysed.</p>

					<p>For most types, you can use one of the <a href="#usage-types">type functions</a> provided by Analyser.</p>

					<p>For more complex data, though, you may need to create a custom type function. These functions always take a string argument, and should throw an error if that string doesn't match whatever requirements it might have to correctly convert it to the desired type.
				</div>
			</section>
		</section>

		<section>
			<div class="content">
				<h2 id="methods">Methods <a class="anchor" href="#methods"></a></h2>
			</div>

			<section class="js-codebook__set" data-codebook-set="methods-fileConfig">
				<div class="content">
					<h3 id="methods-fileConfig">fileConfig <a class="anchor" href="#methods-fileConfig"></a></h3>

					<code>fileConfig(fileConfig: <a href="#interfaces-FileConfig">FileConfig</a>): <a href="#interfaces-FileConfig">FileConfig</a></code>

					<p>This function doesn't do anything itself, it just returns the object passed to it. However, when working with TypeScript using a function in this way is necessary in order for the TypeScript compiler to correctly infer the generic string type based on the specified column names for the data.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-fileConfig" contenteditable spellcheck="false">
						// Passing this object through analyser.fileConfig ensures
						// TypeScript would infer its type as FileConfig<'CITY'|'COUNTRY'>
						// This allows column names to be autocompleted after
						// the file is loaded, unlike using FileConfig<string>

						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								city: ['A', analyser.types.string],
								country: ['B', analyser.types.string],
							},
						});

						log(fileConfig);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-fileConfig"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="methods-getColNumber">
				<div class="content">
					<h3 id="methods-getColNumber">getColNumber <a class="anchor" href="#methods-getColNumber"></a></h3>

					<code>getColNumber(colName: number | string): number | null</code>

					<p><code>getColNumber</code> converts strings of the format used as column headings by spreadsheet software like Microsoft Excel into 0-indexed numbers.</p>

					<p>For example, <code>'A'</code> would be converted to <code>0</code>, whereas <code>'ZE'</code> would be converted to <code>680</code>. This is case insensitive.</p>

					<p>If a positive integer is passed into <code>getColNumber</code>, it will be returned unchanged.</p>

					<p>Any other number, or any string containing an invalid character, will instead be converted to <code>null</code>.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-getColNumber" contenteditable spellcheck="false">
						log(`'A': ${analyser.getColNumber('A')}`);
						log(`'ZE': ${analyser.getColNumber('ZE')}`);
						log(`0: ${analyser.getColNumber(0)}`);
						log(`12: ${analyser.getColNumber(12)}`);
						log(`-1: ${analyser.getColNumber(-1)}`);
						log(`1.5: ${analyser.getColNumber(1.5)}`);
						log(`'invalid string': ${analyser.getColNumber('invalid string')}`);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-getColNumber"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="methods-getColNumbers">
				<div class="content">
					<h3 id="methods-getColNumbers">getColNumbers <a class="anchor" href="#methods-getColNumbers"></a></h3>

					<code>getColNumbers(colsConfig: Record&lt;string, [string | number, ...unknown[]]&gt;): Record&lt;string, number&gt;</code>

					<p><code>getColNumbers</code> takes in a map of column names like the one that can be provided as part of a <code><a href="#interfaces-FileConfig">FileConfig</a></code> object, and transforms each property according to the same rules as <code><a href="#methods-getColNumber">getColNumber</a></code>.</p>

					<p>If any of those transformations results in <code>null</code>, the property will be removed from the result.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-getColNumbers" contenteditable spellcheck="false">
						log(analyser.getColNumbers({
							'A': ['A'],
							'ZE': ['ZE'],
							0: [0],
							12: [12],
							'-1': [-1],
							'1.5': [1.5],
							'invalid string': ['invalid string'],
						}));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-getColNumbers"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="methods-loadFile">
				<div class="content">
					<h3 id="methods-loadFile">loadFile <a class="anchor" href="#methods-loadFile"></a></h3>

					<code>loadFile(fileConfig: <a href="#interfaces-FileConfig">FileConfig</a>, options?: <a href="#interfaces-LoadFileOptions">LoadFileOptions</a>): Promise&lt;<a href="#interfaces-Data">Data</a>&gt;</code>

					<p>The <code>loadFile</code> method loads a single CSV file configured with a <a href="#interfaces-FileConfig">FileConfig</a> object.</p>

					<p>If the file is loaded and processed successfully, the <code>Promise</code> returned by <code>loadFile</code> will resolve to a <a href="#interfaces-Data">Data</a> object.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-loadFile" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								city: ['A', analyser.types.string],
								country: ['B', analyser.types.string],
							},
						});

						const data = await analyser.loadFile(fileConfig);

						log('Properties:', Object.keys(data).filter((key) => isNaN(Number(key))));
						log('Rows:', data);
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-loadFile"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="methods-matchByAlias">
				<div class="content">
					<h3 id="methods-matchWithAlias">matchWithAlias <a class="anchor" href="#methods-matchWithAlias"></a></h3>

					<code>matchWithAlias(testValue: unknown, matchValue: unknown, aliases?: readonly string[][]): boolean</code>

					<p>The <code>matchWithAlias</code> function allows <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">Array.prototype.filter</a></code> to be used on a <code><a href="#interfaces-Data">Data</a></code> object while respecting a data set's aliases.</p>

					<p><code>matchWithAlias</code> takes two arguments, which can each be either a single value or an array of values. If any value in both of these arguments is either a direct match or are aliases of one another, then <code>matchWithAlias</code> will return <code>true</code>. Otherwise, it will return <code>false</code>.</p>

					<p>Filtering can also be done without using <code>matchWithAlias</code>, when working with data that has no aliases or filtering by columns that don't contain string values.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-methods-matchByAlias" contenteditable spellcheck="false">
						const fileConfig = analyser.fileConfig({
							path: '/analyser/assets/data/city example.csv',
							cols: {
								name: ['A', analyser.types.string],
								country: ['B', analyser.types.string],
								population: ['C', analyser.types.number],
								capital: ['D', analyser.types.booleanCustom('true', '\'No\'')],
								publicTransport: ['E', analyser.types.array(',')],
							},

							headerRows: 1,
							footerRows: 1,

							aliases: [
								['Aotearoa', 'New Zealand'],
							],
						});

						const rows = await analyser.loadFile(fileConfig, { strict: false });

						const germanCities = rows.filter(({ country }) => {
							return analyser.matchWithAlias(country, 'Germany', rows.aliases);
						});
						log('German cities:', germanCities.map(({ name }) => name));

						const largeCitiesWithTrainOrFerry = rows.filter(({ population, publicTransport }) => {
							return population > 1000 && analyser.matchWithAlias(publicTransport, ['Train', 'Ferry'], rows.aliases);
						});
						log('Large cities with train or ferry services:', largeCitiesWithTrainOrFerry.map(({ name }) => name));

						const largeOrCapitalCities = rows.filter(({ capital, population }) => {
							return capital === true || population > 1000;
						});
						log('Large or capital cities:', largeOrCapitalCities.map(({ name }) => name));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-methods-matchByAlias"></samp>
				</div>
				</div>
			</section>
		</section>

		<section>
			<div class="content">
				<h2 id="statistics">Statistical helper functions <a class="anchor" href="#statistics"></a></h2>

				<p>Analyser provides some statistical helper functions. These functions can be accessed either via <code>analyser.statistics</code> or by importing them from the <code>@cipscis/analyser/statistics</code> submodule:</p>

				<code>import { statistics } from '@cipscis/analyser';</code><br />
				<code>import * as statistics from '@cipscis/analyser/statistics';</code>
			</div>

			<section class="js-codebook__set" data-codebook-set="statistics-sum">
				<div class="content">
					<h3 id="statistics-sum">sum <a class="anchor" href="#statistics-sum"></a></h3>

					<code>sum(...arr: number[] | [number[]]): number</code>

					<p>The <code>sum</code> method sums an array of numbers, either taking them all as a single array argument or as many number arguments.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-statistics-sum" contenteditable spellcheck="false">
						log(analyser.statistics.sum(1, 2, 3, 4, 5));
						log(analyser.statistics.sum([1, 2, 3, 4, 5]));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-statistics-sum"></samp>
				</div>
			</section>

			<section class="js-codebook__set" data-codebook-set="statistics-mean"">
				<div class="content">
					<h3 id="statistics-mean">mean <a class="anchor" href="#statistics-mean"></a></h3>

					<code>mean(...arr: number[] | [number[]]): number</code>

					<p>The <code>mean</code> method returns the mean of an array of numbers, either taking them all as a single array argument or as many number arguments.</p>
				</div>

				<div class="docs-example js-docs__example">
					<script type="text/plain" class="docs-example__code js-codebook__block" data-codebook-log="log-statistics-mean" contenteditable spellcheck="false">
						log(analyser.statistics.mean(1, 2, 3, 4, 5));
						log(analyser.statistics.mean([1, 2, 3, 4, 5]));
					</script>

					<div class="docs-example__controls">
						<button class="docs-example__control js-docs__run">Run code</button>
					</div>

					<samp class="docs-example__log js-docs__log" id="log-statistics-mean"></samp>
				</div>
			</section>
		</section>
	</main>
</body>

</html>
